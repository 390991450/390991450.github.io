<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>JDBC</title>
    <url>/2021/11/21/JDBC/</url>
    <content><![CDATA[<h1 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h1><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">//前置工作，在项目下创建一个文件夹，将mysql.jar文件拷贝到该目录下</span><br><span class="line">      //点击<span class="keyword">add</span> <span class="keyword">to</span> project加入到项目中。实现driver的抽象类。</span><br><span class="line">      // <span class="number">1</span>注册驱动</span><br><span class="line">      Driver driver = <span class="built_in">new</span> Driver();</span><br><span class="line">      //<span class="number">2</span>得到连接,mysql连接本质是socket连接</span><br><span class="line">      String url = &quot;jdbc:mysql://主机ip:端口/数据库名&quot;;</span><br><span class="line">      Properties properties = <span class="built_in">new</span> Properties();</span><br><span class="line">      properties.setProperty(&quot;user&quot;,&quot;用户名&quot;);</span><br><span class="line">      properties.setProperty(&quot;password&quot;,&quot;密码&quot;);</span><br><span class="line">      <span class="keyword">Connection</span> <span class="keyword">connect</span> = driver.<span class="keyword">connect</span>(url, properties);//这个<span class="keyword">connect</span>等同于socket</span><br><span class="line">      //<span class="number">3</span>执行<span class="keyword">sql</span></span><br><span class="line">      String <span class="keyword">sql</span> = &quot;要执行的sql语句&quot;;</span><br><span class="line">      //生成语法的执行器,返回值为更改的行数</span><br><span class="line">      <span class="keyword">Statement</span> <span class="keyword">statement</span> = <span class="keyword">connect</span>.createStatement();</span><br><span class="line">      <span class="type">int</span> <span class="keyword">rows</span> = <span class="keyword">statement</span>.executeUpdate(<span class="keyword">sql</span>);//只能存放dlm语句，<span class="keyword">select</span>用Query</span><br><span class="line">      //关闭连接资源</span><br><span class="line">      <span class="keyword">statement</span>.<span class="keyword">close</span>();</span><br><span class="line">      <span class="keyword">connect</span>.<span class="keyword">close</span>();</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h1 id="数据库连接方式"><a href="#数据库连接方式" class="headerlink" title="数据库连接方式"></a>数据库连接方式</h1><p>上面的方法可以连接数据库，但问题是这是一个静态加载，灵活性差，依赖性强。<br>可以使用反射机制取得driver，实现静态加载。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">        Class clazz = <span class="module-access"><span class="module"><span class="identifier">Class</span>.</span></span><span class="keyword">for</span><span class="constructor">Name(<span class="string">&quot;驱动路径&quot;</span>)</span>;</span><br><span class="line"><span class="comment">//下面这句话是可以不写的，在dirver中有一段静态代码，只要类加载后，会自动帮助注册驱动</span></span><br><span class="line">        Driver dirver = (Dirver)clazz.<span class="keyword">new</span><span class="constructor">Instance()</span>;</span><br></pre></td></tr></table></figure>
<p>还可以使用drivermanager来获取connect，但这个方法是静态同步调用，会造成低效率和死锁，不再展开。</p>
<h2 id="最常用的数据库连接方式："><a href="#最常用的数据库连接方式：" class="headerlink" title="最常用的数据库连接方式："></a>最常用的数据库连接方式：</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//mysql驱动5.1.6后这句类加载也可以省略，会自动调用。建议写上，防止多个驱动存在。</span><br><span class="line">//最省略的写法就是只要将驱动放入项目中，然后直接取得connection即可。</span><br><span class="line">Class clazz = Class.forName(&quot;驱动路径&quot;);</span><br><span class="line">//这里可以直接将这些信息存储到properties文件中，通过IO流取出。</span><br><span class="line">//new properties;</span><br><span class="line">//properties.load(new FileInpitStream(文件路径));</span><br><span class="line">String url = &quot;jdbc:mysql://主机ip:端口/数据库名&quot;;</span><br><span class="line">String user = </span><br><span class="line">String password = </span><br><span class="line">Connection connect = Drivermanager.getConnection(url,user,password);</span><br></pre></td></tr></table></figure>
<h1 id="ResultSet"><a href="#ResultSet" class="headerlink" title="ResultSet"></a>ResultSet</h1><p>在执行select语句后，会返回一个类似于迭代器的resultset。</p>
<figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ResultSet</span> <span class="keyword">resultset</span> = statement.executeQuery(<span class="string">&quot;查询语句&quot;</span>);</span><br><span class="line"><span class="comment">//next为向下移动，还可以使用previous向上移动</span></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">resultset</span>.next())&#123;</span><br><span class="line">        <span class="comment">//get方法中既可以填写索引，也可以填写列名。</span></span><br><span class="line">    int id = <span class="keyword">resultset</span>.getInt(<span class="number">1</span>);<span class="comment">//取出第一列，取出类型为int</span></span><br><span class="line">    <span class="params">...</span><span class="params">...</span></span><br><span class="line">&#125;</span><br><span class="line">resulset.close;</span><br><span class="line">statement.close();</span><br><span class="line">connect.close();</span><br></pre></td></tr></table></figure>
<h1 id="Statement"><a href="#Statement" class="headerlink" title="Statement"></a>Statement</h1><h2 id="执行SQl语句的三种渠道："><a href="#执行SQl语句的三种渠道：" class="headerlink" title="执行SQl语句的三种渠道："></a>执行SQl语句的三种渠道：</h2><p>1.Statement[存在SQl注入风险(注入非法的SQL语句攻击数据库)，一般不使用]。<br>2.PreparedStatement[预处理]。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">//PreparedStatement的使用方式</span></span><br><span class="line">String sql = <span class="string">&quot;select name, pwd from admin where name = ? and pwd = ?&quot;</span><span class="comment">//?相当于占位符</span></span><br><span class="line"><span class="comment">//preparedStatement有别于Statement，在创建时就要输入sql语句</span></span><br><span class="line">PreparedStatement preparedStatement = connection.prepared<span class="constructor">Statement(<span class="params">sql</span>)</span>;</span><br><span class="line">preparedStatement.set<span class="constructor">String(1,<span class="params">admin_name</span>)</span>;<span class="comment">//对应问号的位置，admin_name中存储接收的用户名</span></span><br><span class="line">preparedStatement.set<span class="constructor">String(2,<span class="params">admin_pwd</span>)</span>;</span><br><span class="line">ResultSet resultset = preparedStatement.execute<span class="constructor">Query()</span>;</span><br></pre></td></tr></table></figure>
<p>3.CallableStatement[存储过程]。</p>
<h2 id="Statement接口"><a href="#Statement接口" class="headerlink" title="Statement接口"></a>Statement接口</h2><p>executeUpdate(sql)执行dml语句，返回影响的行数。<br>executeQuery(sql)执行查询，返回ResultSet。<br>execute(sql)执行任意语句，返回布尔值，用于不需要返回行数或者结果集的语句。</p>
<h1 id="JDBCUtils的开发"><a href="#JDBCUtils的开发" class="headerlink" title="JDBCUtils的开发"></a>JDBCUtils的开发</h1><p>因为在JDBC过程中，数据库的连接和释放资源属于高重复度内容，因此一般将这些内容进行封装。</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDBCUtils</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">String</span> user;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">String</span> password;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">String</span> url;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">String</span> driver;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用静态代码块初始化</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Properties properties = <span class="keyword">new</span> <span class="type">Properties</span>();</span><br><span class="line">            properties.load(<span class="keyword">new</span> <span class="type">FileInputStream</span>(<span class="string">&quot;文件路径&quot;</span>));</span><br><span class="line">            user = properties.getProperty(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">            password = properties.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">            url = properties.getProperty(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">            driver = properties.getProperty(<span class="string">&quot;driver&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">//1.将编译异常转化为运行异常</span></span><br><span class="line">            <span class="comment">//2.调用者可以选择捕获改异常，也可以选择默认操作</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//连接数据库</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Connection getConnection()&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> DriverManager.getConnection(url,user,password);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//关闭资源</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> void close(ResultSet resultSet, Statement statement, Connection connection)&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (resultSet != <span class="literal">null</span>)&#123;</span><br><span class="line">                resultSet.close();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (statement != <span class="literal">null</span>)&#123;</span><br><span class="line">                statement.close();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (connection != <span class="literal">null</span>)&#123;</span><br><span class="line">                connection.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>首先要调用Connection.setAutoCommit(false),取消自动提交事务。<br>然后再使用Connection.commit()手动提交，使用Connection.rollback回滚事务。</p>
]]></content>
      <categories>
        <category>JDBC学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title>z字形变换</title>
    <url>/2021/11/22/z%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><pre><code>    将一个给定字符串s根据给定的行数numRows，以从上往下、从左到右进行Z字形排列。
    比如输入字符串为 &quot;PAYPALISHIRING&quot;行数为3时，排列如下：
    P   A   H   N
    A P L S I I G
    Y   I   R
    之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：&quot;PAHNAPLSIIGYIR&quot;。
</code></pre>
<span id="more"></span>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>寻找这种排布的规律。会发现每排字符的index与其所在行，以及总行数形成函数关系。<br>首先分析第一排：第一排的index差为2*(总行数-1)。<br>分析最后一排：与第一排规律相同。<br>其他排：每隔一个字符看与第一排的规律也相同，而相邻的字符存在关系，如第二个字符与第三个<br>字符间刚好差2*(当前行数-1)。则第一个字符与第二的字符的差就是：2*(总行数-1)-2*(当前行数-1)。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public String convert(String s, int numRows) &#123;</span><br><span class="line">        //如果长度为1，则直接返回</span><br><span class="line">        if (numRows == 1)&#123;</span><br><span class="line">            return s;</span><br><span class="line">        &#125;</span><br><span class="line">        char[] chars = s.toCharArray();</span><br><span class="line">        char[] answer = new char[chars.length];</span><br><span class="line">        int count = 0;</span><br><span class="line">        for (int i = 0;i&lt;numRows;i++)&#123;</span><br><span class="line">            int j= i;</span><br><span class="line">            while (j&lt;chars.length)&#123;</span><br><span class="line">                answer[count] = chars[j];</span><br><span class="line">                count++;</span><br><span class="line">                //统一处理n的两边数字，特别处理腰部的数字</span><br><span class="line">                if(!(i == 0||i == numRows-1))&#123;</span><br><span class="line">                    if ((2*numRows-2-2*i+j) &lt; chars.length) &#123;</span><br><span class="line">                        answer[count] = chars[2*numRows-2-2*i+j];</span><br><span class="line">                        count++;</span><br><span class="line">                        &#125;  </span><br><span class="line">                    &#125;</span><br><span class="line">                    j += (2*numRows-2);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return new String(answer);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode解析</category>
        <category>中等</category>
      </categories>
      <tags>
        <tag>数学分析</tag>
      </tags>
  </entry>
  <entry>
    <title>两数之和</title>
    <url>/2021/11/22/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><pre><code>    给定一个整数数组 nums和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那两个整数，并返回它们的数组下标。
    你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。
    你可以按任意顺序返回答案
</code></pre>
<h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>本题主要提供一种使用hashmap的key的思路。使map接收到一个数的差又不会接收它本身。</p>
<span id="more"></span>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">int</span>[] twoSum(<span class="built_in">int</span>[] nums, <span class="built_in">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">HashMap</span>&lt;Integer,<span class="keyword">Object</span>&gt; <span class="built_in">map</span> = <span class="keyword">new</span> <span class="keyword">HashMap</span>();</span><br><span class="line">        <span class="comment">//key种存放一个数字，value存放合适的数组</span></span><br><span class="line">        <span class="built_in">int</span>[] answer = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">        	<span class="comment">//这里为核心思路</span></span><br><span class="line">             <span class="keyword">if</span> (<span class="built_in">map</span>.containsKey(target-nums[i]))&#123;</span><br><span class="line">                <span class="built_in">int</span>[] ints = (<span class="built_in">int</span>[]) <span class="built_in">map</span>.<span class="built_in">get</span>(target-nums[i]);</span><br><span class="line">                ints[<span class="number">1</span>] = i;</span><br><span class="line">                answer = ints.clone();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">int</span>[] ints = &#123;i,<span class="number">0</span>&#125;;</span><br><span class="line">                <span class="built_in">map</span>.put(nums[i],ints );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode解析</category>
        <category>简单</category>
      </categories>
      <tags>
        <tag>hashmap</tag>
      </tags>
  </entry>
  <entry>
    <title>hashmap的扩容与&amp;运算问题</title>
    <url>/2021/11/20/hashmap%E7%9A%84%E6%89%A9%E5%AE%B9%E4%B8%8E/</url>
    <content><![CDATA[<h1 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h1><p>1、初始容量为1&lt;&lt;4<br>2、负载因子为0.75，到达负载因子时2次幂扩展<br>3、通过hashcode计算存放位置</p>
<span id="more"></span>
<h1 id="hashcode的计算"><a href="#hashcode的计算" class="headerlink" title="hashcode的计算"></a>hashcode的计算</h1><p>1、获取hash值h，将h&gt;&gt;&gt;16后再与自身异或。<br>这是因为在计算hashmap存放位置时只取低位，正常运算会丢失高位的信息。这样处理后也可以将高位<br>的信息保留，减少冲突的可能性。<br>2、取模运算:(length-1)&amp;hash。<br>在这里可以解释为什么扩容是是2次幂，一般情况下，计算位置是需要%计算，但当length的长度为2的<br>次幂的时候，取余运算可以转化成上面的位与运算，大大节省了计算时间。</p>
<p><a href="https://www.cnblogs.com/ysocean/p/9054804.html">来源</a></p>
]]></content>
      <categories>
        <category>java学习笔记</category>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>hashmap</tag>
      </tags>
  </entry>
  <entry>
    <title>区间内查询数字频率</title>
    <url>/2021/11/21/%E5%8C%BA%E9%97%B4%E5%86%85%E6%9F%A5%E8%AF%A2%E6%95%B0%E5%AD%97%E9%A2%91%E7%8E%87/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><pre><code>    请你设计一个数据结构，它能求出给定子数组内一个给定值的频率。
    子数组中一个值的频率指的是这个子数组中这个值的出现次数。
    请你实现RangeFreqQuery类：
    RangeFreqQuery(int[] arr)用下标从 0开始的整数数组arr构造一个类的实例。
    int query(int left, int right, int value)返回子数组arr[left...right]中value的频率。
    一个子数组指的是数组中一段连续的元素。arr[left...right]指的是 nums中包含下标left和
    right在内的中间一段连续元素。
</code></pre>
<span id="more"></span>
<pre><code>    输入：
    [&quot;RangeFreqQuery&quot;, &quot;query&quot;, &quot;query&quot;]
    [[[12, 33, 4, 56, 22, 2, 34, 33, 22, 12, 34, 56]], [1, 2, 4], [0, 11, 33]]
    输出：
    [null, 1, 2]
</code></pre>
<h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>这道题使用暴力算法很简单，但示例有时间和内存限制，必须对算法进行优化。<br>创建一个hashmap，key存储要查询的数字，value中存储一个list，list存储出现的位置。<br>即使这样优化也会超时，所以在遍历list的时候还要使用二分查找，在这里要深度理解二分查找。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RangeFreqQuery</span> </span>&#123;</span><br><span class="line">    int[] array;</span><br><span class="line">    <span class="comment">//ArrayList list;//存放数字出现频率</span></span><br><span class="line">    HashMap map;<span class="comment">//存放list的钥匙库</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> RangeFreqQuery(int[] arr) &#123;</span><br><span class="line">        array = <span class="keyword">new</span> <span class="type">int</span>[arr.length];</span><br><span class="line">        <span class="comment">//list = new ArrayList();</span></span><br><span class="line">        map = <span class="keyword">new</span> <span class="type">HashMap</span>();</span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!map.containsKey(arr[i]))&#123;</span><br><span class="line">                ArrayList list = <span class="keyword">new</span> <span class="type">ArrayList</span>();</span><br><span class="line">                list.add(i);</span><br><span class="line">                map.put(arr[i],list);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                ArrayList list = (ArrayList) map.<span class="keyword">get</span>(arr[i]);</span><br><span class="line">                list.add(i);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> int query(int left, int right, int value) &#123;</span><br><span class="line">        ArrayList list = (ArrayList) map.<span class="keyword">get</span>(value);</span><br><span class="line">        <span class="keyword">if</span> (list == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            int <span class="keyword">new</span><span class="type">right</span> = list.size()<span class="number">-1</span>;</span><br><span class="line">            int <span class="keyword">new</span><span class="type">left</span> = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//考虑两种找不到的情况。list的第一位比right大，list的末位比left小</span></span><br><span class="line">            <span class="keyword">if</span> ((int)list.<span class="keyword">get</span>(<span class="number">0</span>)&gt;right||(int)list.<span class="keyword">get</span>(<span class="keyword">new</span><span class="type">right</span>)&lt;left)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//使用二分查找左，右指针位置</span></span><br><span class="line">            <span class="comment">//找到的左指针要求其指向的数字&gt;=left，即指向left或者第一个大于它的数字</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">new</span><span class="type">left</span> != <span class="keyword">new</span><span class="type">right</span>)&#123;</span><br><span class="line">                int mid = (<span class="keyword">new</span><span class="type">left</span>+<span class="keyword">new</span><span class="type">right</span>)/<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span> ((int)list.<span class="keyword">get</span>(mid) &gt;= left)&#123;</span><br><span class="line">                    <span class="keyword">new</span><span class="type">right</span> = mid;<span class="comment">//因为目标数字最后总在截取范围的后段，需要不断舍去前半部分的数字</span></span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;			   <span class="comment">//所以mid尽量取小(left+right)/2。</span></span><br><span class="line">                    <span class="keyword">new</span><span class="type">left</span> = mid+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            int leftnum = <span class="keyword">new</span><span class="type">left</span>;</span><br><span class="line">            <span class="keyword">new</span><span class="type">right</span> = list.size()<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">new</span><span class="type">left</span> = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//找到的右指针要求其指向的数字&lt;=right，即指向right或者第一个小于它的数字</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">new</span><span class="type">left</span> != <span class="keyword">new</span><span class="type">right</span>)&#123;</span><br><span class="line">                int mid = (<span class="keyword">new</span><span class="type">left</span>+<span class="keyword">new</span><span class="type">right</span>+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span> ((int)list.<span class="keyword">get</span>(mid) &lt;= right)&#123;</span><br><span class="line">                    <span class="keyword">new</span><span class="type">left</span> = mid;<span class="comment">//因为目标数字最后总在截取范围的前段，需要不断舍去前后部分的数字</span></span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;			  <span class="comment">//所以mid尽量取大(left+right+1)/2。</span></span><br><span class="line">                    <span class="keyword">new</span><span class="type">right</span> = mid<span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            int rightnum = <span class="keyword">new</span><span class="type">right</span>;</span><br><span class="line">            <span class="keyword">return</span> rightnum-leftnum+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode解析</category>
        <category>困难</category>
      </categories>
      <tags>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>打乱数组</title>
    <url>/2021/11/22/%E6%89%93%E4%B9%B1%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><pre><code>    给你一个整数数组 nums ，设计算法来打乱一个没有重复元素的数组。
    实现 Solution class:
    Solution(int[] nums) 使用整数数组 nums 初始化对象
    int[] reset() 重设数组到它的初始状态并返回
    int[] shuffle() 返回数组随机打乱后的结果
</code></pre>
<span id="more"></span>
<h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>本题没有难度，用于洗牌算法的学习</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int[] arr;</span><br><span class="line">  Random random = new Random();</span><br><span class="line">   public Solution(int[] nums) &#123;</span><br><span class="line">       arr = nums;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   public int[] reset() &#123;</span><br><span class="line">       return arr;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   public int[] shuffle() &#123;</span><br><span class="line">       int[] newArr = arr.clone();</span><br><span class="line">       //每次移动视为对当前位置随机成功</span><br><span class="line">       for(int i = 0;i&lt;arr.length;i++)&#123;</span><br><span class="line">       	//nextInt方法取到的数字为左闭右开区间</span><br><span class="line">           int num = i+random.nextInt(arr.length-i);</span><br><span class="line">           int cache = newArr[i];</span><br><span class="line">           newArr[i] = newArr[num];</span><br><span class="line">           newArr[num] = cache;</span><br><span class="line">       &#125;</span><br><span class="line">       return newArr;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode解析</category>
        <category>中等</category>
      </categories>
      <tags>
        <tag>洗牌算法</tag>
      </tags>
  </entry>
  <entry>
    <title>无重复最长数组</title>
    <url>/2021/11/22/%E6%97%A0%E9%87%8D%E5%A4%8D%E6%9C%80%E9%95%BF%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><pre><code>    给定一个字符串s，请你找出其中不含有重复字符的最长子串的长度。
</code></pre>
<h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>合理使用滑动窗口对字符串进行更新,每次遇到重复字符时收缩滑动窗口左端。</p>
<span id="more"></span>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="keyword">String</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">length</span>() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = <span class="number">1</span>;<span class="comment">//end一直指向无重复的下一位</span></span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span>[] chars = s.<span class="built_in">toCharArray</span>();</span><br><span class="line">        <span class="keyword">for</span> (;end&lt;chars.length;end++)&#123;</span><br><span class="line">            <span class="keyword">int</span> point = start;</span><br><span class="line">            <span class="comment">//判断前面的数组是否重复</span></span><br><span class="line">            <span class="keyword">for</span> (;point&lt;end;point++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (chars[point] == chars[end])&#123;</span><br><span class="line">                    <span class="comment">//说明当前无重复数组到达最大，比较记录</span></span><br><span class="line">                    max = Math.<span class="built_in">max</span>(max,end-start);</span><br><span class="line">                    <span class="comment">//更新start点位</span></span><br><span class="line">                    start = point+<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//还需要计算一次max</span></span><br><span class="line">        max = Math.<span class="built_in">max</span>(max,end-start);</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode解析</category>
        <category>中等</category>
      </categories>
      <tags>
        <tag>字符串检索</tag>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title>排列序列</title>
    <url>/2021/11/20/%E6%8E%92%E5%88%97%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><pre><code>    给出集合[1,2,3,...,n]，其所有元素共有n! 种排列。
    按大小顺序列出所有排列情况，并一一标记，当n = 3 时, 所有排列如下：
    &quot;123&quot;
    &quot;132&quot;
    &quot;213&quot;
    &quot;231&quot;
    &quot;312&quot;
    &quot;321&quot;
    给定n 和k，返回第k个排列。
</code></pre>
<span id="more"></span>
<h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>因为数字从小到大排列，所以可以直接由每位的数字来确定该数字所处位置。<br>如例中所示首位确定时，后两位能产生2！种变化，当第二位确定时，最后一位便确定。k的范围是1~6，12，34，56各一组。<br>需要对k处理方便计算，令k–，则k–除以2！可以正好被拆分开，再取得余数，用于确定下一位。<br>若k为5，则第一位的数字为第(5+1/2!)+1个数字,第二位的数字为(0/1!)+1个数字，第三位为剩下的最后一个数字。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public String getPermutation(int n, int k) &#123;</span><br><span class="line">        if (n ==1)&#123;</span><br><span class="line">            return &quot;1&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        //创建一个阶乘的数组，进行统计</span><br><span class="line">        k--;</span><br><span class="line">        int[][] count = new int[n - 1][2];</span><br><span class="line">        count[0][0] = 1;</span><br><span class="line">        for (int i = 1;i&lt;count.length;i++)&#123;</span><br><span class="line">            count[i][0] = count[i-1][0]*(i+1);</span><br><span class="line">        &#125;</span><br><span class="line">        int[] ints = new int[n];</span><br><span class="line">        for (int i = 0;i&lt;n;i++)&#123;</span><br><span class="line">            ints[i] = i+1;</span><br><span class="line">        &#125;</span><br><span class="line">        //开始逐个从数组中取出数组</span><br><span class="line">        String str = new String();</span><br><span class="line">        for (int i = count.length-1;i&gt;=0;i--)&#123;</span><br><span class="line">            count[i][1] = k/count[i][0];</span><br><span class="line">            int counter = -1;</span><br><span class="line">            for (int j = 0;j&lt;ints.length;j++)&#123;</span><br><span class="line">                if (ints[j] != 0)&#123;</span><br><span class="line">                    counter++;</span><br><span class="line">                    if (counter==count[i][1])&#123;</span><br><span class="line">                        str+=ints[j];</span><br><span class="line">                        ints[j] =0;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            k %= count[i][0];</span><br><span class="line">        &#125;</span><br><span class="line">        for (int o:ints)&#123;</span><br><span class="line">            if (o != 0)&#123;</span><br><span class="line">                str+=o;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return str;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>leetcode解析</category>
        <category>困难</category>
      </categories>
      <tags>
        <tag>数学分析</tag>
      </tags>
  </entry>
  <entry>
    <title>最长和谐子序列</title>
    <url>/2021/11/20/%E6%9C%80%E9%95%BF%E5%92%8C%E8%B0%90%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><pre><code>    和谐数组是指一个数组里元素的最大值和最小值之间的差别 正好是 1 。
    现在，给你一个整数数组 nums ，请你在所有可能的子序列中找到最长的和谐子序列的长度。
    数组的子序列是一个由数组派生出来的序列，它可以通过删除一些元素或不删除元素、且不改变其余元素的顺序而得到。
示例：
    输入：nums = [1,3,2,2,5,2,3,7]
    输出：5
    解释：最长的和谐子序列是 [3,2,2,2,3]
</code></pre>
<span id="more"></span>
<h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>创建一个hashmap，再通过条件判断，直接检索答案。    </p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int findLHS(int[] nums) &#123;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        //记录每个数字的个数</span><br><span class="line">        for (int o :nums)&#123;</span><br><span class="line">            if (!map.containsKey(o))&#123;</span><br><span class="line">                map.put(o,0);</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(o, map.get(o)+1);</span><br><span class="line">        &#125;</span><br><span class="line">        if (map.size() &lt; 2)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int max = 0;</span><br><span class="line">        //从map中查询相邻数字，并且判断max</span><br><span class="line">        for (int key:map.keySet())&#123;</span><br><span class="line">            if (map.get(key+1) != null)&#123;</span><br><span class="line">                max = Math.max(max,map.get(key)+map.get(key+1));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return max;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode解析</category>
        <category>简单</category>
      </categories>
      <tags>
        <tag>hashmap</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式匹配</title>
    <url>/2021/11/23/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给你一个字符串s和一个字符规律p，请你来实现一个支持 ‘.’和’星号’的正则表达式匹配。<br>‘.’ 匹配任意单个字符<br>‘星号’ 匹配零个或多个前面的那一个元素<br>所谓匹配，是要涵盖整个字符串s的，而不是部分字符串。</p>
<span id="more"></span>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>设dp[i,j]表示第i长的s与j长的p的匹配情况。<br>下面开始分情况讨论：<br>//普通字符<br>当dp[i-1，j-1]为真的时候，如果s[i] == p[j]，则dp[i,j]为真，否则必定为假。<br>当dp[i-1，j-1]为假的时候，只要是普通字符则必定为假。<br>//星字符<br>当不使用星字符修饰的字符就能匹配时，则dp[i,j-2]必定为真。<br>当星的字符开始循环后能匹配时，查询dp[i-1,j]是否为真，若为真，且s[i] = p[j-1]，则为真，其他情况为假。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public boolean isMatch(String s, String p) &#123;</span><br><span class="line">        boolean[][] dp = new boolean[s.length() + 1][p.length() + 1];</span><br><span class="line">        //因为dp的判断点依靠左上，左侧以及上方点位，所以逐行对dp进行填充</span><br><span class="line">        //初始化第一列</span><br><span class="line">        dp[0][0] = true;</span><br><span class="line">        for (int i = 1;i&lt;dp.length;i++)&#123;</span><br><span class="line">            dp[i][0] = false;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0;i&lt;dp.length;i++)&#123;</span><br><span class="line">            for (int j = 1;j&lt;dp[0].length;j++)&#123;</span><br><span class="line">                if (p.substring(j-1,j).equals(&quot;*&quot;))&#123;</span><br><span class="line">                    if (dp[i][j-2]||</span><br><span class="line">                    	//判断*作0的情况</span><br><span class="line">                    	(i&gt;0&amp;&amp;dp[i-1][j]&amp;&amp;(s.substring(i-1,i).equals(p.substring(j-2,j-1))</span><br><span class="line">                    	||p.substring(j-2,j-1).equals(&quot;.&quot;))))&#123;</span><br><span class="line">                    	//判断*大于1的情况</span><br><span class="line">                        dp[i][j] = true;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;else &#123;</span><br><span class="line">                    if (i&gt;0&amp;&amp;dp[i-1][j-1]&amp;&amp;(p.substring(j-1,j).equals(&quot;.&quot;)||s.substring(i-1,i).equals(p.substring(j-1,j))))&#123;</span><br><span class="line">                        dp[i][j] = true;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (dp[s.length()][p.length()])&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode解析</category>
        <category>困难</category>
      </categories>
      <tags>
        <tag>字符串检索</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>最长回文子串</title>
    <url>/2021/11/22/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><pre><code>    给你一个字符串s，找到s中最长的回文子串。
</code></pre>
<h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>首先对整个字符串加#，将单数字符串与双数字符串转换为单数字符串，减少代码量。<br>接着使用manacher算法：当一个短的字符串被包含在长字符串中时，具有一定的对称性。<br>情况一：短的字符串的镜像被包含在长字符串中，如caabaac，查a的长度，这时二者的长度相等。<br>情况二：短的字符串的镜像超出了长字符串的范围，此时这个字符串的长度正好到到长字符串的顶端。<br>情况三：短的字符串的镜像刚好落在了长字符串的一端，此时这个字符串长度最短到长字符串的顶端。</p>
<span id="more"></span>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">String</span> longestPalindrome(<span class="keyword">String</span> s) &#123;</span><br><span class="line">        <span class="built_in">char</span>[] chars = s.toCharArray();</span><br><span class="line">        <span class="built_in">char</span>[] <span class="built_in">str</span> = <span class="keyword">new</span> <span class="built_in">char</span>[chars.length * <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>;i&lt;chars.length;i++)&#123;</span><br><span class="line">            <span class="built_in">str</span>[<span class="number">2</span>*i] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">            <span class="built_in">str</span>[<span class="number">2</span>*i+<span class="number">1</span>] = chars[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">str</span>[<span class="built_in">str</span>.length<span class="number">-1</span>] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">        <span class="comment">//对字符串进行处理，把奇偶两种情况都转换为奇数情况</span></span><br><span class="line">        <span class="built_in">int</span>[] length = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="built_in">str</span>.length];</span><br><span class="line">        <span class="comment">//用于记录回文半径</span></span><br><span class="line">        <span class="built_in">int</span> shadow = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//创建一个数，用来记录最大阴影。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>;i&lt;<span class="built_in">str</span>.length;i++)&#123;</span><br><span class="line">            <span class="comment">//使用manacher算法</span></span><br><span class="line">            <span class="comment">//判断数字是否在阴影中</span></span><br><span class="line">            <span class="built_in">int</span> shadowLength = shadow+length[shadow];</span><br><span class="line">            <span class="keyword">if</span> (i!=<span class="number">0</span>&amp;&amp;i&lt;shadowLength)&#123;</span><br><span class="line">                <span class="comment">//取得镜像点</span></span><br><span class="line">                <span class="built_in">int</span> mirro = shadow-(i-shadow);</span><br><span class="line">                <span class="comment">//进入manacher算法后要分三种情况</span></span><br><span class="line">                <span class="comment">//镜像长度在阴影内</span></span><br><span class="line">                <span class="keyword">if</span> (i+length[mirro]&lt;shadowLength)&#123;</span><br><span class="line">                    length[i] = length[mirro];</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (i+length[mirro] &gt;shadowLength)&#123;</span><br><span class="line">                    length[i] = shadowLength-i;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    length[i] = shadowLength-i;</span><br><span class="line">                    <span class="built_in">int</span> left = i-(shadowLength-i);</span><br><span class="line">                    <span class="built_in">int</span> right = shadowLength;</span><br><span class="line">                    <span class="keyword">while</span> (left<span class="number">-1</span>&gt;=<span class="number">0</span>&amp;&amp;right+<span class="number">1</span>&lt;<span class="built_in">str</span>.length&amp;&amp;<span class="built_in">str</span>[left<span class="number">-1</span>]==<span class="built_in">str</span>[right+<span class="number">1</span>])&#123;</span><br><span class="line">                        left--;</span><br><span class="line">                        right++;</span><br><span class="line">                        length[i]++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//不在阴影中使用传统暴力算法</span></span><br><span class="line">            <span class="built_in">int</span> left = i;</span><br><span class="line">            <span class="built_in">int</span> right = i;</span><br><span class="line">            <span class="keyword">while</span> (left<span class="number">-1</span>&gt;=<span class="number">0</span>&amp;&amp;right+<span class="number">1</span>&lt;<span class="built_in">str</span>.length&amp;&amp;<span class="built_in">str</span>[left<span class="number">-1</span>]==<span class="built_in">str</span>[right+<span class="number">1</span>])&#123;</span><br><span class="line">                left--;</span><br><span class="line">                right++;</span><br><span class="line">                length[i]++;</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//更新阴影</span></span><br><span class="line">            <span class="keyword">if</span> (shadow+length[shadow]&lt;i+length[i])&#123;</span><br><span class="line">                shadow = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">int</span> maxPoint=<span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">int</span> maxLength = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i =<span class="number">0</span>;i&lt;length.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (length[i]&gt;maxLength)&#123;</span><br><span class="line">                maxLength = length[i];</span><br><span class="line">                maxPoint = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">String</span> answer = <span class="keyword">new</span> <span class="keyword">String</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = maxPoint-maxLength;i&lt;=maxPoint+maxLength;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">str</span>[i] != <span class="string">&#x27;#&#x27;</span>)&#123;</span><br><span class="line">                answer += <span class="built_in">str</span>[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode解析</category>
        <category>中等</category>
      </categories>
      <tags>
        <tag>字符串检索</tag>
        <tag>manacher算法</tag>
      </tags>
  </entry>
</search>
