<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>JDBC</title>
    <url>/2021/11/21/JDBC/</url>
    <content><![CDATA[<h1 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h1><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">//前置工作，在项目下创建一个文件夹，将mysql.jar文件拷贝到该目录下</span><br><span class="line">      //点击<span class="keyword">add</span> <span class="keyword">to</span> project加入到项目中。实现driver的抽象类。</span><br><span class="line">      // <span class="number">1</span>注册驱动</span><br><span class="line">      Driver driver = <span class="built_in">new</span> Driver();</span><br><span class="line">      //<span class="number">2</span>得到连接,mysql连接本质是socket连接</span><br><span class="line">      String url = &quot;jdbc:mysql://主机ip:端口/数据库名&quot;;</span><br><span class="line">      Properties properties = <span class="built_in">new</span> Properties();</span><br><span class="line">      properties.setProperty(&quot;user&quot;,&quot;用户名&quot;);</span><br><span class="line">      properties.setProperty(&quot;password&quot;,&quot;密码&quot;);</span><br><span class="line">      <span class="keyword">Connection</span> <span class="keyword">connect</span> = driver.<span class="keyword">connect</span>(url, properties);//这个<span class="keyword">connect</span>等同于socket</span><br><span class="line">      //<span class="number">3</span>执行<span class="keyword">sql</span></span><br><span class="line">      String <span class="keyword">sql</span> = &quot;要执行的sql语句&quot;;</span><br><span class="line">      //生成语法的执行器,返回值为更改的行数</span><br><span class="line">      <span class="keyword">Statement</span> <span class="keyword">statement</span> = <span class="keyword">connect</span>.createStatement();</span><br><span class="line">      <span class="type">int</span> <span class="keyword">rows</span> = <span class="keyword">statement</span>.executeUpdate(<span class="keyword">sql</span>);//只能存放dlm语句，<span class="keyword">select</span>用Query</span><br><span class="line">      //关闭连接资源</span><br><span class="line">      <span class="keyword">statement</span>.<span class="keyword">close</span>();</span><br><span class="line">      <span class="keyword">connect</span>.<span class="keyword">close</span>();</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h1 id="数据库连接方式"><a href="#数据库连接方式" class="headerlink" title="数据库连接方式"></a>数据库连接方式</h1><p>上面的方法可以连接数据库，但问题是这是一个静态加载，灵活性差，依赖性强。<br>可以使用反射机制取得driver，实现静态加载。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">        Class clazz = <span class="module-access"><span class="module"><span class="identifier">Class</span>.</span></span><span class="keyword">for</span><span class="constructor">Name(<span class="string">&quot;驱动路径&quot;</span>)</span>;</span><br><span class="line"><span class="comment">//下面这句话是可以不写的，在dirver中有一段静态代码，只要类加载后，会自动帮助注册驱动</span></span><br><span class="line">        Driver dirver = (Dirver)clazz.<span class="keyword">new</span><span class="constructor">Instance()</span>;</span><br></pre></td></tr></table></figure>
<p>还可以使用drivermanager来获取connect，但这个方法是静态同步调用，会造成低效率和死锁，不再展开。</p>
<h2 id="最常用的数据库连接方式："><a href="#最常用的数据库连接方式：" class="headerlink" title="最常用的数据库连接方式："></a>最常用的数据库连接方式：</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//mysql驱动5.1.6后这句类加载也可以省略，会自动调用。建议写上，防止多个驱动存在。</span><br><span class="line">//最省略的写法就是只要将驱动放入项目中，然后直接取得connection即可。</span><br><span class="line">Class clazz = Class.forName(&quot;驱动路径&quot;);</span><br><span class="line">//这里可以直接将这些信息存储到properties文件中，通过IO流取出。</span><br><span class="line">//new properties;</span><br><span class="line">//properties.load(new FileInpitStream(文件路径));</span><br><span class="line">String url = &quot;jdbc:mysql://主机ip:端口/数据库名&quot;;</span><br><span class="line">String user = </span><br><span class="line">String password = </span><br><span class="line">Connection connect = Drivermanager.getConnection(url,user,password);</span><br></pre></td></tr></table></figure>
<h1 id="ResultSet"><a href="#ResultSet" class="headerlink" title="ResultSet"></a>ResultSet</h1><p>在执行select语句后，会返回一个类似于迭代器的resultset。</p>
<figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ResultSet</span> <span class="keyword">resultset</span> = statement.executeQuery(<span class="string">&quot;查询语句&quot;</span>);</span><br><span class="line"><span class="comment">//next为向下移动，还可以使用previous向上移动</span></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">resultset</span>.next())&#123;</span><br><span class="line">        <span class="comment">//get方法中既可以填写索引，也可以填写列名。</span></span><br><span class="line">    int id = <span class="keyword">resultset</span>.getInt(<span class="number">1</span>);<span class="comment">//取出第一列，取出类型为int</span></span><br><span class="line">    <span class="params">...</span><span class="params">...</span></span><br><span class="line">&#125;</span><br><span class="line">resulset.close;</span><br><span class="line">statement.close();</span><br><span class="line">connect.close();</span><br></pre></td></tr></table></figure>
<h1 id="Statement"><a href="#Statement" class="headerlink" title="Statement"></a>Statement</h1><h2 id="执行SQl语句的三种渠道："><a href="#执行SQl语句的三种渠道：" class="headerlink" title="执行SQl语句的三种渠道："></a>执行SQl语句的三种渠道：</h2><p>1.Statement[存在SQl注入风险(注入非法的SQL语句攻击数据库)，一般不使用]。<br>2.PreparedStatement[预处理]。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">//PreparedStatement的使用方式</span></span><br><span class="line">String sql = <span class="string">&quot;select name, pwd from admin where name = ? and pwd = ?&quot;</span><span class="comment">//?相当于占位符</span></span><br><span class="line"><span class="comment">//preparedStatement有别于Statement，在创建时就要输入sql语句</span></span><br><span class="line">PreparedStatement preparedStatement = connection.prepared<span class="constructor">Statement(<span class="params">sql</span>)</span>;</span><br><span class="line">preparedStatement.set<span class="constructor">String(1,<span class="params">admin_name</span>)</span>;<span class="comment">//对应问号的位置，admin_name中存储接收的用户名</span></span><br><span class="line">preparedStatement.set<span class="constructor">String(2,<span class="params">admin_pwd</span>)</span>;</span><br><span class="line">ResultSet resultset = preparedStatement.execute<span class="constructor">Query()</span>;</span><br></pre></td></tr></table></figure>
<p>3.CallableStatement[存储过程]。</p>
<h2 id="Statement接口"><a href="#Statement接口" class="headerlink" title="Statement接口"></a>Statement接口</h2><p>executeUpdate(sql)执行dml语句，返回影响的行数。<br>executeQuery(sql)执行查询，返回ResultSet。<br>execute(sql)执行任意语句，返回布尔值，用于不需要返回行数或者结果集的语句。</p>
<h1 id="JDBCUtils的开发"><a href="#JDBCUtils的开发" class="headerlink" title="JDBCUtils的开发"></a>JDBCUtils的开发</h1><p>因为在JDBC过程中，数据库的连接和释放资源属于高重复度内容，因此一般将这些内容进行封装。</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDBCUtils</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">String</span> user;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">String</span> password;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">String</span> url;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">String</span> driver;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用静态代码块初始化</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Properties properties = <span class="keyword">new</span> <span class="type">Properties</span>();</span><br><span class="line">            properties.load(<span class="keyword">new</span> <span class="type">FileInputStream</span>(<span class="string">&quot;文件路径&quot;</span>));</span><br><span class="line">            user = properties.getProperty(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">            password = properties.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">            url = properties.getProperty(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">            driver = properties.getProperty(<span class="string">&quot;driver&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">//1.将编译异常转化为运行异常</span></span><br><span class="line">            <span class="comment">//2.调用者可以选择捕获改异常，也可以选择默认操作</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//连接数据库</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Connection getConnection()&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> DriverManager.getConnection(url,user,password);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//关闭资源</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> void close(ResultSet resultSet, Statement statement, Connection connection)&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (resultSet != <span class="literal">null</span>)&#123;</span><br><span class="line">                resultSet.close();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (statement != <span class="literal">null</span>)&#123;</span><br><span class="line">                statement.close();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (connection != <span class="literal">null</span>)&#123;</span><br><span class="line">                connection.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>首先要调用Connection.setAutoCommit(false),取消自动提交事务。<br>然后再使用Connection.commit()手动提交，使用Connection.rollback回滚事务(一般写在catch中)。</p>
<h1 id="批处理"><a href="#批处理" class="headerlink" title="批处理"></a>批处理</h1><p>启用批处理需要修改url语句。<br>String url = “jdbc:mysql://主机ip:端口/数据库名？rewriteBatchedStatements = true”;<br>preparedStatement.addBatch();将sql语句加入到集合中。<br>preparedStatement.executeBatch();批量执行sql语句。<br>preparedStatement.clearBatch();清空集合。</p>
<h1 id="传统连接方式的弊端"><a href="#传统连接方式的弊端" class="headerlink" title="传统连接方式的弊端"></a>传统连接方式的弊端</h1><p>1.每次向数据库建立连接时都要加载connection，再验证。<br>2.如果程序异常没能正常关闭会导致内存泄露。<br>3.不能控制创建的连接数量，连接过多会导致数据库崩溃。</p>
<h1 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h1><p>给定规定的连接口，所有连接接入走连接池，并排队，由连接池统一管理。<br>实现DataSource接口。</p>
<h2 id="C3P0"><a href="#C3P0" class="headerlink" title="C3P0"></a>C3P0</h2><p>类名：ComboPooledDataSource</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//给予连接池需要的信息，让连接池创建接向数据库的连接</span><br><span class="line">new ComboPooledDataSource();</span><br><span class="line">comboPooledDataSource.setDriverClass(驱动路径);</span><br><span class="line">comboPooledDataSource.setJdbcUrl(url);</span><br><span class="line">comboPooledDataSource.setUser(user);</span><br><span class="line">comboPooledDataSource.setPassword(password);</span><br><span class="line">//设置连接池的初始连接数和最大连接数</span><br><span class="line">comboPooledDataSource.setInitialPoolSize(int);</span><br><span class="line">comboPooledDataSource.setMaxPoolSize(int);</span><br><span class="line">//从连接池取得连接,注意这里的connection不是由DriverManager创建的，所以close方法也不同。</span><br><span class="line">Connection connection = comboPooledDataSource.getConnection();</span><br><span class="line">//这里的关闭并不是关闭了连接，而是把连接还给了连接池</span><br><span class="line">connection.close();</span><br></pre></td></tr></table></figure>
<p>除了上面这种连接方式，还可以将这些信息统一写在c3p0的config文件中，初始化时直接使用。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="constructor">ComboPooledDataSource(<span class="params">cofig</span>文件的数据源名称)</span>;</span><br></pre></td></tr></table></figure>
<h2 id="Druid"><a href="#Druid" class="headerlink" title="Druid"></a>Druid</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Properties properties = new Properties();</span><br><span class="line">properties.load(new FileInputStream(&quot;德鲁伊需要的配置文件&quot;));</span><br><span class="line">DataSource dataSource = DruidDataSourceFactory.createDataSource(properties);</span><br><span class="line">Connection connection = dataSource.getConnection();</span><br><span class="line">connection.close();</span><br></pre></td></tr></table></figure>
<p>这之后就可以基于druid重写JDBCUtils。</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="keyword">class</span> JDBCUtilsByDruid&#123;</span><br><span class="line">    private static DataSource dataSource;</span><br><span class="line">    static &#123;</span><br><span class="line">        Properties properties = <span class="built_in">new</span> Properties();</span><br><span class="line">        try &#123;</span><br><span class="line">            properties.<span class="keyword">load</span>(<span class="built_in">new</span> FileInputStream(&quot;配置文件&quot;));</span><br><span class="line">            dataSource = DruidDataSourceFactory.createDataSource(properties);</span><br><span class="line">        &#125; catch (<span class="keyword">Exception</span> e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">public</span> static <span class="keyword">Connection</span> getConnection() throws SQLException &#123;</span><br><span class="line">        <span class="keyword">return</span> dataSource.getConnection();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">public</span> static <span class="type">void</span> <span class="keyword">close</span>(ResultSet resultSet, <span class="keyword">Statement</span> <span class="keyword">statement</span>, <span class="keyword">Connection</span> <span class="keyword">connection</span>)&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            <span class="keyword">if</span> (resultSet != <span class="keyword">null</span>)&#123;</span><br><span class="line">                resultSet.<span class="keyword">close</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">statement</span> != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">statement</span>.<span class="keyword">close</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">connection</span> != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">connection</span>.<span class="keyword">close</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (SQLException e) &#123;</span><br><span class="line">            throw <span class="built_in">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="ApDBUtils"><a href="#ApDBUtils" class="headerlink" title="ApDBUtils"></a>ApDBUtils</h1><p>问题1：目前，当需要对resultset进行操作时，connection不能关闭，但连接池给的连接是有限的。<br>问题2：结果集只能使用一次。<br>问题3：结果集取得信息的方法并不方便。<br>解决办法：创建一个类，每行的数据创建为一个对象，使用List连接起来。<br>向项目中加入DBUtils的包</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Connection connection = JDBCUtilsByDruid.getConnection();</span><br><span class="line">QueryRunner queryRunner = new QueryRunner();</span><br><span class="line">//query方法就是执行一个sql语句并返回一个包含结果集的list</span><br><span class="line">//最后的1是指sql语句中？要赋予的值</span><br><span class="line">//使用这个办法不需要关闭结果集，在这句话的源码中，最后会自动关闭结果集和preparedStatement。</span><br><span class="line">List&lt;Actor&gt; list = </span><br><span class="line">    queryRunner.query(connection,sql,new BeanListHandler&lt;&gt;(Actor.class),？赋值);</span><br><span class="line">//单行查询</span><br><span class="line">Actor actor = queryRunner.query(connection,sql,new BeanHandler&lt;&gt;(Actor.class),？赋值);</span><br><span class="line">//单行单列</span><br><span class="line">Object o = queryRunner.query(connection,sql,new ScalarHandler(),？赋值);</span><br><span class="line">DBUtilsByDruid.close(null,null,connection);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JDBC学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title>z字形变换</title>
    <url>/2021/11/22/z%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><pre><code>    将一个给定字符串s根据给定的行数numRows，以从上往下、从左到右进行Z字形排列。
    比如输入字符串为 &quot;PAYPALISHIRING&quot;行数为3时，排列如下：
    P   A   H   N
    A P L S I I G
    Y   I   R
    之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：&quot;PAHNAPLSIIGYIR&quot;。
</code></pre>
<span id="more"></span>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>寻找这种排布的规律。会发现每排字符的index与其所在行，以及总行数形成函数关系。<br>首先分析第一排：第一排的index差为2*(总行数-1)。<br>分析最后一排：与第一排规律相同。<br>其他排：每隔一个字符看与第一排的规律也相同，而相邻的字符存在关系，如第二个字符与第三个<br>字符间刚好差2*(当前行数-1)。则第一个字符与第二的字符的差就是：2*(总行数-1)-2*(当前行数-1)。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public String convert(String s, int numRows) &#123;</span><br><span class="line">        //如果长度为1，则直接返回</span><br><span class="line">        if (numRows == 1)&#123;</span><br><span class="line">            return s;</span><br><span class="line">        &#125;</span><br><span class="line">        char[] chars = s.toCharArray();</span><br><span class="line">        char[] answer = new char[chars.length];</span><br><span class="line">        int count = 0;</span><br><span class="line">        for (int i = 0;i&lt;numRows;i++)&#123;</span><br><span class="line">            int j= i;</span><br><span class="line">            while (j&lt;chars.length)&#123;</span><br><span class="line">                answer[count] = chars[j];</span><br><span class="line">                count++;</span><br><span class="line">                //统一处理n的两边数字，特别处理腰部的数字</span><br><span class="line">                if(!(i == 0||i == numRows-1))&#123;</span><br><span class="line">                    if ((2*numRows-2-2*i+j) &lt; chars.length) &#123;</span><br><span class="line">                        answer[count] = chars[2*numRows-2-2*i+j];</span><br><span class="line">                        count++;</span><br><span class="line">                        &#125;  </span><br><span class="line">                    &#125;</span><br><span class="line">                    j += (2*numRows-2);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return new String(answer);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode解析</category>
        <category>中等</category>
      </categories>
      <tags>
        <tag>数学分析</tag>
      </tags>
  </entry>
  <entry>
    <title>两数之和</title>
    <url>/2021/11/22/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><pre><code>    给定一个整数数组 nums和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那两个整数，并返回它们的数组下标。
    你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。
    你可以按任意顺序返回答案
</code></pre>
<h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>本题主要提供一种使用hashmap的key的思路。使map接收到一个数的差又不会接收它本身。</p>
<span id="more"></span>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">int</span>[] twoSum(<span class="built_in">int</span>[] nums, <span class="built_in">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">HashMap</span>&lt;Integer,<span class="keyword">Object</span>&gt; <span class="built_in">map</span> = <span class="keyword">new</span> <span class="keyword">HashMap</span>();</span><br><span class="line">        <span class="comment">//key种存放一个数字，value存放合适的数组</span></span><br><span class="line">        <span class="built_in">int</span>[] answer = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">        	<span class="comment">//这里为核心思路</span></span><br><span class="line">             <span class="keyword">if</span> (<span class="built_in">map</span>.containsKey(target-nums[i]))&#123;</span><br><span class="line">                <span class="built_in">int</span>[] ints = (<span class="built_in">int</span>[]) <span class="built_in">map</span>.<span class="built_in">get</span>(target-nums[i]);</span><br><span class="line">                ints[<span class="number">1</span>] = i;</span><br><span class="line">                answer = ints.clone();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">int</span>[] ints = &#123;i,<span class="number">0</span>&#125;;</span><br><span class="line">                <span class="built_in">map</span>.put(nums[i],ints );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode解析</category>
        <category>简单</category>
      </categories>
      <tags>
        <tag>hashmap</tag>
      </tags>
  </entry>
  <entry>
    <title>hashmap的扩容与&amp;运算问题</title>
    <url>/2021/11/20/hashmap%E7%9A%84%E6%89%A9%E5%AE%B9%E4%B8%8E/</url>
    <content><![CDATA[<h1 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h1><p>1、初始容量为1&lt;&lt;4<br>2、负载因子为0.75，到达负载因子时2次幂扩展<br>3、通过hashcode计算存放位置</p>
<span id="more"></span>
<h1 id="hashcode的计算"><a href="#hashcode的计算" class="headerlink" title="hashcode的计算"></a>hashcode的计算</h1><p>1、获取hash值h，将h&gt;&gt;&gt;16后再与自身异或。<br>这是因为在计算hashmap存放位置时只取低位，正常运算会丢失高位的信息。这样处理后也可以将高位<br>的信息保留，减少冲突的可能性。<br>2、取模运算:(length-1)&amp;hash。<br>在这里可以解释为什么扩容是是2次幂，一般情况下，计算位置是需要%计算，但当length的长度为2的<br>次幂的时候，取余运算可以转化成上面的位与运算，大大节省了计算时间。</p>
<p><a href="https://www.cnblogs.com/ysocean/p/9054804.html">来源</a></p>
]]></content>
      <categories>
        <category>java学习笔记</category>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>hashmap</tag>
      </tags>
  </entry>
  <entry>
    <title>区间内查询数字频率</title>
    <url>/2021/11/21/%E5%8C%BA%E9%97%B4%E5%86%85%E6%9F%A5%E8%AF%A2%E6%95%B0%E5%AD%97%E9%A2%91%E7%8E%87/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><pre><code>    请你设计一个数据结构，它能求出给定子数组内一个给定值的频率。
    子数组中一个值的频率指的是这个子数组中这个值的出现次数。
    请你实现RangeFreqQuery类：
    RangeFreqQuery(int[] arr)用下标从 0开始的整数数组arr构造一个类的实例。
    int query(int left, int right, int value)返回子数组arr[left...right]中value的频率。
    一个子数组指的是数组中一段连续的元素。arr[left...right]指的是 nums中包含下标left和
    right在内的中间一段连续元素。
</code></pre>
<span id="more"></span>
<pre><code>    输入：
    [&quot;RangeFreqQuery&quot;, &quot;query&quot;, &quot;query&quot;]
    [[[12, 33, 4, 56, 22, 2, 34, 33, 22, 12, 34, 56]], [1, 2, 4], [0, 11, 33]]
    输出：
    [null, 1, 2]
</code></pre>
<h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>这道题使用暴力算法很简单，但示例有时间和内存限制，必须对算法进行优化。<br>创建一个hashmap，key存储要查询的数字，value中存储一个list，list存储出现的位置。<br>即使这样优化也会超时，所以在遍历list的时候还要使用二分查找，在这里要深度理解二分查找。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RangeFreqQuery</span> </span>&#123;</span><br><span class="line">    int[] array;</span><br><span class="line">    <span class="comment">//ArrayList list;//存放数字出现频率</span></span><br><span class="line">    HashMap map;<span class="comment">//存放list的钥匙库</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> RangeFreqQuery(int[] arr) &#123;</span><br><span class="line">        array = <span class="keyword">new</span> <span class="type">int</span>[arr.length];</span><br><span class="line">        <span class="comment">//list = new ArrayList();</span></span><br><span class="line">        map = <span class="keyword">new</span> <span class="type">HashMap</span>();</span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!map.containsKey(arr[i]))&#123;</span><br><span class="line">                ArrayList list = <span class="keyword">new</span> <span class="type">ArrayList</span>();</span><br><span class="line">                list.add(i);</span><br><span class="line">                map.put(arr[i],list);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                ArrayList list = (ArrayList) map.<span class="keyword">get</span>(arr[i]);</span><br><span class="line">                list.add(i);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> int query(int left, int right, int value) &#123;</span><br><span class="line">        ArrayList list = (ArrayList) map.<span class="keyword">get</span>(value);</span><br><span class="line">        <span class="keyword">if</span> (list == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            int <span class="keyword">new</span><span class="type">right</span> = list.size()<span class="number">-1</span>;</span><br><span class="line">            int <span class="keyword">new</span><span class="type">left</span> = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//考虑两种找不到的情况。list的第一位比right大，list的末位比left小</span></span><br><span class="line">            <span class="keyword">if</span> ((int)list.<span class="keyword">get</span>(<span class="number">0</span>)&gt;right||(int)list.<span class="keyword">get</span>(<span class="keyword">new</span><span class="type">right</span>)&lt;left)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//使用二分查找左，右指针位置</span></span><br><span class="line">            <span class="comment">//找到的左指针要求其指向的数字&gt;=left，即指向left或者第一个大于它的数字</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">new</span><span class="type">left</span> != <span class="keyword">new</span><span class="type">right</span>)&#123;</span><br><span class="line">                int mid = (<span class="keyword">new</span><span class="type">left</span>+<span class="keyword">new</span><span class="type">right</span>)/<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span> ((int)list.<span class="keyword">get</span>(mid) &gt;= left)&#123;</span><br><span class="line">                    <span class="keyword">new</span><span class="type">right</span> = mid;<span class="comment">//因为目标数字最后总在截取范围的后段，需要不断舍去前半部分的数字</span></span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;			   <span class="comment">//所以mid尽量取小(left+right)/2。</span></span><br><span class="line">                    <span class="keyword">new</span><span class="type">left</span> = mid+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            int leftnum = <span class="keyword">new</span><span class="type">left</span>;</span><br><span class="line">            <span class="keyword">new</span><span class="type">right</span> = list.size()<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">new</span><span class="type">left</span> = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//找到的右指针要求其指向的数字&lt;=right，即指向right或者第一个小于它的数字</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">new</span><span class="type">left</span> != <span class="keyword">new</span><span class="type">right</span>)&#123;</span><br><span class="line">                int mid = (<span class="keyword">new</span><span class="type">left</span>+<span class="keyword">new</span><span class="type">right</span>+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span> ((int)list.<span class="keyword">get</span>(mid) &lt;= right)&#123;</span><br><span class="line">                    <span class="keyword">new</span><span class="type">left</span> = mid;<span class="comment">//因为目标数字最后总在截取范围的前段，需要不断舍去前后部分的数字</span></span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;			  <span class="comment">//所以mid尽量取大(left+right+1)/2。</span></span><br><span class="line">                    <span class="keyword">new</span><span class="type">right</span> = mid<span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            int rightnum = <span class="keyword">new</span><span class="type">right</span>;</span><br><span class="line">            <span class="keyword">return</span> rightnum-leftnum+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode解析</category>
        <category>困难</category>
      </categories>
      <tags>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>打乱数组</title>
    <url>/2021/11/22/%E6%89%93%E4%B9%B1%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><pre><code>    给你一个整数数组 nums ，设计算法来打乱一个没有重复元素的数组。
    实现 Solution class:
    Solution(int[] nums) 使用整数数组 nums 初始化对象
    int[] reset() 重设数组到它的初始状态并返回
    int[] shuffle() 返回数组随机打乱后的结果
</code></pre>
<span id="more"></span>
<h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>本题没有难度，用于洗牌算法的学习</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int[] arr;</span><br><span class="line">  Random random = new Random();</span><br><span class="line">   public Solution(int[] nums) &#123;</span><br><span class="line">       arr = nums;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   public int[] reset() &#123;</span><br><span class="line">       return arr;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   public int[] shuffle() &#123;</span><br><span class="line">       int[] newArr = arr.clone();</span><br><span class="line">       //每次移动视为对当前位置随机成功</span><br><span class="line">       for(int i = 0;i&lt;arr.length;i++)&#123;</span><br><span class="line">       	//nextInt方法取到的数字为左闭右开区间</span><br><span class="line">           int num = i+random.nextInt(arr.length-i);</span><br><span class="line">           int cache = newArr[i];</span><br><span class="line">           newArr[i] = newArr[num];</span><br><span class="line">           newArr[num] = cache;</span><br><span class="line">       &#125;</span><br><span class="line">       return newArr;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode解析</category>
        <category>中等</category>
      </categories>
      <tags>
        <tag>洗牌算法</tag>
      </tags>
  </entry>
  <entry>
    <title>无重复最长数组</title>
    <url>/2021/11/22/%E6%97%A0%E9%87%8D%E5%A4%8D%E6%9C%80%E9%95%BF%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><pre><code>    给定一个字符串s，请你找出其中不含有重复字符的最长子串的长度。
</code></pre>
<h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>合理使用滑动窗口对字符串进行更新,每次遇到重复字符时收缩滑动窗口左端。</p>
<span id="more"></span>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="keyword">String</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">length</span>() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = <span class="number">1</span>;<span class="comment">//end一直指向无重复的下一位</span></span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span>[] chars = s.<span class="built_in">toCharArray</span>();</span><br><span class="line">        <span class="keyword">for</span> (;end&lt;chars.length;end++)&#123;</span><br><span class="line">            <span class="keyword">int</span> point = start;</span><br><span class="line">            <span class="comment">//判断前面的数组是否重复</span></span><br><span class="line">            <span class="keyword">for</span> (;point&lt;end;point++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (chars[point] == chars[end])&#123;</span><br><span class="line">                    <span class="comment">//说明当前无重复数组到达最大，比较记录</span></span><br><span class="line">                    max = Math.<span class="built_in">max</span>(max,end-start);</span><br><span class="line">                    <span class="comment">//更新start点位</span></span><br><span class="line">                    start = point+<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//还需要计算一次max</span></span><br><span class="line">        max = Math.<span class="built_in">max</span>(max,end-start);</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode解析</category>
        <category>中等</category>
      </categories>
      <tags>
        <tag>字符串检索</tag>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title>排列序列</title>
    <url>/2021/11/20/%E6%8E%92%E5%88%97%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><pre><code>    给出集合[1,2,3,...,n]，其所有元素共有n! 种排列。
    按大小顺序列出所有排列情况，并一一标记，当n = 3 时, 所有排列如下：
    &quot;123&quot;
    &quot;132&quot;
    &quot;213&quot;
    &quot;231&quot;
    &quot;312&quot;
    &quot;321&quot;
    给定n 和k，返回第k个排列。
</code></pre>
<span id="more"></span>
<h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>因为数字从小到大排列，所以可以直接由每位的数字来确定该数字所处位置。<br>如例中所示首位确定时，后两位能产生2！种变化，当第二位确定时，最后一位便确定。k的范围是1~6，12，34，56各一组。<br>需要对k处理方便计算，令k–，则k–除以2！可以正好被拆分开，再取得余数，用于确定下一位。<br>若k为5，则第一位的数字为第(5+1/2!)+1个数字,第二位的数字为(0/1!)+1个数字，第三位为剩下的最后一个数字。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public String getPermutation(int n, int k) &#123;</span><br><span class="line">        if (n ==1)&#123;</span><br><span class="line">            return &quot;1&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        //创建一个阶乘的数组，进行统计</span><br><span class="line">        k--;</span><br><span class="line">        int[][] count = new int[n - 1][2];</span><br><span class="line">        count[0][0] = 1;</span><br><span class="line">        for (int i = 1;i&lt;count.length;i++)&#123;</span><br><span class="line">            count[i][0] = count[i-1][0]*(i+1);</span><br><span class="line">        &#125;</span><br><span class="line">        int[] ints = new int[n];</span><br><span class="line">        for (int i = 0;i&lt;n;i++)&#123;</span><br><span class="line">            ints[i] = i+1;</span><br><span class="line">        &#125;</span><br><span class="line">        //开始逐个从数组中取出数组</span><br><span class="line">        String str = new String();</span><br><span class="line">        for (int i = count.length-1;i&gt;=0;i--)&#123;</span><br><span class="line">            count[i][1] = k/count[i][0];</span><br><span class="line">            int counter = -1;</span><br><span class="line">            for (int j = 0;j&lt;ints.length;j++)&#123;</span><br><span class="line">                if (ints[j] != 0)&#123;</span><br><span class="line">                    counter++;</span><br><span class="line">                    if (counter==count[i][1])&#123;</span><br><span class="line">                        str+=ints[j];</span><br><span class="line">                        ints[j] =0;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            k %= count[i][0];</span><br><span class="line">        &#125;</span><br><span class="line">        for (int o:ints)&#123;</span><br><span class="line">            if (o != 0)&#123;</span><br><span class="line">                str+=o;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return str;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>leetcode解析</category>
        <category>困难</category>
      </categories>
      <tags>
        <tag>数学分析</tag>
      </tags>
  </entry>
  <entry>
    <title>最长和谐子序列</title>
    <url>/2021/11/20/%E6%9C%80%E9%95%BF%E5%92%8C%E8%B0%90%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><pre><code>    和谐数组是指一个数组里元素的最大值和最小值之间的差别 正好是 1 。
    现在，给你一个整数数组 nums ，请你在所有可能的子序列中找到最长的和谐子序列的长度。
    数组的子序列是一个由数组派生出来的序列，它可以通过删除一些元素或不删除元素、且不改变其余元素的顺序而得到。
示例：
    输入：nums = [1,3,2,2,5,2,3,7]
    输出：5
    解释：最长的和谐子序列是 [3,2,2,2,3]
</code></pre>
<span id="more"></span>
<h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>创建一个hashmap，再通过条件判断，直接检索答案。    </p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int findLHS(int[] nums) &#123;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        //记录每个数字的个数</span><br><span class="line">        for (int o :nums)&#123;</span><br><span class="line">            if (!map.containsKey(o))&#123;</span><br><span class="line">                map.put(o,0);</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(o, map.get(o)+1);</span><br><span class="line">        &#125;</span><br><span class="line">        if (map.size() &lt; 2)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int max = 0;</span><br><span class="line">        //从map中查询相邻数字，并且判断max</span><br><span class="line">        for (int key:map.keySet())&#123;</span><br><span class="line">            if (map.get(key+1) != null)&#123;</span><br><span class="line">                max = Math.max(max,map.get(key)+map.get(key+1));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return max;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode解析</category>
        <category>简单</category>
      </categories>
      <tags>
        <tag>hashmap</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式匹配</title>
    <url>/2021/11/23/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给你一个字符串s和一个字符规律p，请你来实现一个支持 ‘.’和’星号’的正则表达式匹配。<br>‘.’ 匹配任意单个字符<br>‘星号’ 匹配零个或多个前面的那一个元素<br>所谓匹配，是要涵盖整个字符串s的，而不是部分字符串。</p>
<span id="more"></span>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>设dp[i,j]表示第i长的s与j长的p的匹配情况。<br>下面开始分情况讨论：<br>//普通字符<br>当dp[i-1，j-1]为真的时候，如果s[i] == p[j]，则dp[i,j]为真，否则必定为假。<br>当dp[i-1，j-1]为假的时候，只要是普通字符则必定为假。<br>//星字符<br>当不使用星字符修饰的字符就能匹配时，则dp[i,j-2]必定为真。<br>当星的字符开始循环后能匹配时，查询dp[i-1,j]是否为真，若为真，且s[i] = p[j-1]，则为真，其他情况为假。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public boolean isMatch(String s, String p) &#123;</span><br><span class="line">        boolean[][] dp = new boolean[s.length() + 1][p.length() + 1];</span><br><span class="line">        //因为dp的判断点依靠左上，左侧以及上方点位，所以逐行对dp进行填充</span><br><span class="line">        //初始化第一列</span><br><span class="line">        dp[0][0] = true;</span><br><span class="line">        for (int i = 1;i&lt;dp.length;i++)&#123;</span><br><span class="line">            dp[i][0] = false;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0;i&lt;dp.length;i++)&#123;</span><br><span class="line">            for (int j = 1;j&lt;dp[0].length;j++)&#123;</span><br><span class="line">                if (p.substring(j-1,j).equals(&quot;*&quot;))&#123;</span><br><span class="line">                    if (dp[i][j-2]||</span><br><span class="line">                    	//判断*作0的情况</span><br><span class="line">                    	(i&gt;0&amp;&amp;dp[i-1][j]&amp;&amp;(s.substring(i-1,i).equals(p.substring(j-2,j-1))</span><br><span class="line">                    	||p.substring(j-2,j-1).equals(&quot;.&quot;))))&#123;</span><br><span class="line">                    	//判断*大于1的情况</span><br><span class="line">                        dp[i][j] = true;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;else &#123;</span><br><span class="line">                    if (i&gt;0&amp;&amp;dp[i-1][j-1]&amp;&amp;(p.substring(j-1,j).equals(&quot;.&quot;)||s.substring(i-1,i).equals(p.substring(j-1,j))))&#123;</span><br><span class="line">                        dp[i][j] = true;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (dp[s.length()][p.length()])&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode解析</category>
        <category>困难</category>
      </categories>
      <tags>
        <tag>字符串检索</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>最长回文子串</title>
    <url>/2021/11/22/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><pre><code>    给你一个字符串s，找到s中最长的回文子串。
</code></pre>
<h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>首先对整个字符串加#，将单数字符串与双数字符串转换为单数字符串，减少代码量。<br>接着使用manacher算法：当一个短的字符串被包含在长字符串中时，具有一定的对称性。<br>情况一：短的字符串的镜像被包含在长字符串中，如caabaac，查a的长度，这时二者的长度相等。<br>情况二：短的字符串的镜像超出了长字符串的范围，此时这个字符串的长度正好到到长字符串的顶端。<br>情况三：短的字符串的镜像刚好落在了长字符串的一端，此时这个字符串长度最短到长字符串的顶端。</p>
<span id="more"></span>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">String</span> longestPalindrome(<span class="keyword">String</span> s) &#123;</span><br><span class="line">        <span class="built_in">char</span>[] chars = s.toCharArray();</span><br><span class="line">        <span class="built_in">char</span>[] <span class="built_in">str</span> = <span class="keyword">new</span> <span class="built_in">char</span>[chars.length * <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>;i&lt;chars.length;i++)&#123;</span><br><span class="line">            <span class="built_in">str</span>[<span class="number">2</span>*i] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">            <span class="built_in">str</span>[<span class="number">2</span>*i+<span class="number">1</span>] = chars[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">str</span>[<span class="built_in">str</span>.length<span class="number">-1</span>] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">        <span class="comment">//对字符串进行处理，把奇偶两种情况都转换为奇数情况</span></span><br><span class="line">        <span class="built_in">int</span>[] length = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="built_in">str</span>.length];</span><br><span class="line">        <span class="comment">//用于记录回文半径</span></span><br><span class="line">        <span class="built_in">int</span> shadow = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//创建一个数，用来记录最大阴影。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>;i&lt;<span class="built_in">str</span>.length;i++)&#123;</span><br><span class="line">            <span class="comment">//使用manacher算法</span></span><br><span class="line">            <span class="comment">//判断数字是否在阴影中</span></span><br><span class="line">            <span class="built_in">int</span> shadowLength = shadow+length[shadow];</span><br><span class="line">            <span class="keyword">if</span> (i!=<span class="number">0</span>&amp;&amp;i&lt;shadowLength)&#123;</span><br><span class="line">                <span class="comment">//取得镜像点</span></span><br><span class="line">                <span class="built_in">int</span> mirro = shadow-(i-shadow);</span><br><span class="line">                <span class="comment">//进入manacher算法后要分三种情况</span></span><br><span class="line">                <span class="comment">//镜像长度在阴影内</span></span><br><span class="line">                <span class="keyword">if</span> (i+length[mirro]&lt;shadowLength)&#123;</span><br><span class="line">                    length[i] = length[mirro];</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (i+length[mirro] &gt;shadowLength)&#123;</span><br><span class="line">                    length[i] = shadowLength-i;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    length[i] = shadowLength-i;</span><br><span class="line">                    <span class="built_in">int</span> left = i-(shadowLength-i);</span><br><span class="line">                    <span class="built_in">int</span> right = shadowLength;</span><br><span class="line">                    <span class="keyword">while</span> (left<span class="number">-1</span>&gt;=<span class="number">0</span>&amp;&amp;right+<span class="number">1</span>&lt;<span class="built_in">str</span>.length&amp;&amp;<span class="built_in">str</span>[left<span class="number">-1</span>]==<span class="built_in">str</span>[right+<span class="number">1</span>])&#123;</span><br><span class="line">                        left--;</span><br><span class="line">                        right++;</span><br><span class="line">                        length[i]++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//不在阴影中使用传统暴力算法</span></span><br><span class="line">            <span class="built_in">int</span> left = i;</span><br><span class="line">            <span class="built_in">int</span> right = i;</span><br><span class="line">            <span class="keyword">while</span> (left<span class="number">-1</span>&gt;=<span class="number">0</span>&amp;&amp;right+<span class="number">1</span>&lt;<span class="built_in">str</span>.length&amp;&amp;<span class="built_in">str</span>[left<span class="number">-1</span>]==<span class="built_in">str</span>[right+<span class="number">1</span>])&#123;</span><br><span class="line">                left--;</span><br><span class="line">                right++;</span><br><span class="line">                length[i]++;</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//更新阴影</span></span><br><span class="line">            <span class="keyword">if</span> (shadow+length[shadow]&lt;i+length[i])&#123;</span><br><span class="line">                shadow = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">int</span> maxPoint=<span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">int</span> maxLength = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i =<span class="number">0</span>;i&lt;length.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (length[i]&gt;maxLength)&#123;</span><br><span class="line">                maxLength = length[i];</span><br><span class="line">                maxPoint = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">String</span> answer = <span class="keyword">new</span> <span class="keyword">String</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = maxPoint-maxLength;i&lt;=maxPoint+maxLength;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">str</span>[i] != <span class="string">&#x27;#&#x27;</span>)&#123;</span><br><span class="line">                answer += <span class="built_in">str</span>[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode解析</category>
        <category>中等</category>
      </categories>
      <tags>
        <tag>字符串检索</tag>
        <tag>manacher算法</tag>
      </tags>
  </entry>
  <entry>
    <title>盛水最多的容器</title>
    <url>/2021/11/24/%E7%9B%9B%E6%B0%B4%E6%9C%80%E5%A4%9A%E7%9A%84%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给你 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点(i,ai) 。<br>在坐标内画 n 条垂直线，垂直线 i的两个端点分别为(i,ai)和(i,0)。找出其中的两条线，使得它们与x轴共同构成的容器可以容纳最多的水。</p>
<span id="more"></span>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>首先将左右指针指向两端。然后寻找可能使面积更大的组合，无论左右指针哪个移动，底宽都是<br>原来-1。底宽减小，则只有min(left,right)变大才可能使面积变大，若向内移动长边，因为短边<br>没变，所以不可能使min(left,right)变大，只能移动短边，希望短边侧变长。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int maxArea(int[] height) &#123;</span><br><span class="line">        int left = 0;</span><br><span class="line">        int right = height.length-1;</span><br><span class="line">        int max = 0;</span><br><span class="line">        while (left != right)&#123;</span><br><span class="line">            int area = Math.min(height[left],height[right])*(right-left);</span><br><span class="line">            max = Math.max(area,max);</span><br><span class="line">            if (height[left] &lt; height[right])&#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        return max;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode解析</category>
        <category>中等</category>
      </categories>
      <tags>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>三数之和</title>
    <url>/2021/11/25/%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给你一个包含 n 个整数的数组nums，判断nums中是否存在三个元素 a，b，c ，使得a+b+c=0？<br>请你找出所有和为0 且不重复的三元组。<br>注意：答案中不可以包含重复的三元组。</p>
<span id="more"></span>
<h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>本题主要难度在于如何去重。首先将数组排序，从数组左方取出第一个数字，且每次取到的数字不能为重复。<br>接着从第一个数字右方取出第二个数字，从第二数字右方找到第三个数。<br>然后着手算法的优化，因为数组是排序好的，所以第三个数字可以使用二分查找。<br>因为三数和为0，且num1&lt; num2 &lt; num3，当num1大于0时不可能有解直接结束循环。<br>当num1+num2大于0时不可能有解。<br>当数组第一个数大于0或者末位小于0，或者数组长度小于3，为空解直接返回空。<br>因为for循环查询长度较长，考虑使用增强for循环。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123;</span><br><span class="line">        ArrayList&lt;List&lt;Integer&gt;&gt; lists = new ArrayList&lt;&gt;();</span><br><span class="line">        if (nums.length&lt;3)&#123;</span><br><span class="line">            return lists;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        //当数组第一个数大于0或者末位小于0，或者数组长度小于3，为空解直接返回空。</span><br><span class="line">        if (nums[0]&gt;0||nums[nums.length-1]&lt;0)&#123;</span><br><span class="line">            return lists;</span><br><span class="line">        &#125;</span><br><span class="line">        //首先将数组排序，从数组左方取出第一个数字，且每次取到的数字不能为重复。</span><br><span class="line">        int answer1 = 100001;</span><br><span class="line">        int answer2 = 100001;</span><br><span class="line">        int i = 0;</span><br><span class="line">        for (int num1:nums)&#123;</span><br><span class="line">            if (num1 == answer1)&#123;</span><br><span class="line">                i++;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            //因为三数和为0，且num1&lt; num2 &lt; num3，当num1大于0时不可能有解直接结束循环。</span><br><span class="line">            if (num1&gt;0)&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            answer1 = num1;</span><br><span class="line">            i++;</span><br><span class="line">            //接着从第一个数字右方取出第二个数字，从第二数字右方找到第三个数。</span><br><span class="line">            for (int j = i;j&lt; nums.length-1;j++)&#123;</span><br><span class="line">                if (j&gt;i&amp;&amp;nums[j] == answer2)&#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                //因为数组是排序好的，所以第三个数字可以使用二分查找。</span><br><span class="line">                answer2 = nums[j];</span><br><span class="line">                if (answer1+answer2&gt;0)&#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                int answer3 = 0-answer1-answer2;</span><br><span class="line">                int k = Arrays.binarySearch(nums,j+1,nums.length,answer3);</span><br><span class="line">                if (k&gt;0)&#123;</span><br><span class="line">                    lists.add(Arrays.asList(answer1,answer2,answer3));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return lists;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode解析</category>
        <category>中等</category>
      </categories>
      <tags>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>可怜的小猪</title>
    <url>/2021/11/25/%E5%8F%AF%E6%80%9C%E7%9A%84%E5%B0%8F%E7%8C%AA/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>有buckets桶液体，其中正好有一桶含有毒药，其余装的都是水。它们从外观看起来都一样。<br>为了弄清楚哪只水桶含有毒药，你可以喂一些猪喝，通过观察猪是否会死进行判断。不幸的是，<br>你只有minutesToTest分钟时间来确定哪桶液体是有毒的。<br>喂猪的规则如下：</p>
<span id="more"></span>
<p>选择若干活猪进行喂养,可以允许小猪同时饮用任意数量的桶中的水，并且该过程不需要时间。<br>小猪喝完水后，必须有minutesToDie分钟的冷却时间。在这段时间里，你只能观察，而不允许<br>继续喂猪。过了 minutesToDie 分钟后，所有喝到毒药的猪都会死去，其他所有猪都会活下来。<br>重复这一过程，直到时间用完。<br>给你桶的数目buckets，minutesToDie和minutesToTest，返回在规定时间内判断哪个桶有<br>毒所需的最小猪数。</p>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>这道题比较有意思，只要看到本质是很简单一道题。分析每只猪能带多少信息，如果有x轮，猪<br>可以在x中的一轮中死亡，或者不死亡。所以每只猪可以看作x+1进制的单位，只要能表示出10进<br>制的桶数即成功。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public <span class="built_in">int</span> poor<span class="constructor">Pigs(<span class="params">int</span> <span class="params">buckets</span>, <span class="params">int</span> <span class="params">minutesToDie</span>, <span class="params">int</span> <span class="params">minutesToTest</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">int</span> x = minutesToTest/minutesToDie+<span class="number">1</span>;</span><br><span class="line">        double temp = <span class="module-access"><span class="module"><span class="identifier">Math</span>.</span></span>log(buckets)/<span class="module-access"><span class="module"><span class="identifier">Math</span>.</span></span>log(x);</span><br><span class="line">        return (<span class="built_in">int</span>)<span class="module-access"><span class="module"><span class="identifier">Math</span>.</span></span>ceil(temp);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode解析</category>
        <category>困难</category>
      </categories>
      <tags>
        <tag>进制问题</tag>
      </tags>
  </entry>
  <entry>
    <title>删除倒数第n个节点</title>
    <url>/2021/11/25/%E5%88%A0%E9%99%A4%E5%80%92%E6%95%B0%E7%AC%ACn%E4%B8%AA%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点</p>
<span id="more"></span>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>使用回溯，返回时开始计数，返回到父节点。方便操作，再添加一个伪父节点</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> ListNode removeNthFromEnd(ListNode head, <span class="built_in">int</span> n) &#123;</span><br><span class="line">        ListNode fhead = <span class="keyword">new</span> ListNode(<span class="number">0</span>,head);</span><br><span class="line">        trackback(fhead,n);</span><br><span class="line">        <span class="keyword">return</span> fhead.<span class="keyword">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> trackback(ListNode head,<span class="built_in">int</span> n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(head.<span class="keyword">next</span> != <span class="literal">null</span>)&#123;</span><br><span class="line">            trackback(head.<span class="keyword">next</span>,n);</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(num == n)&#123;</span><br><span class="line">            head.<span class="keyword">next</span> = head.<span class="keyword">next</span>.<span class="keyword">next</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode解析</category>
        <category>中等</category>
      </categories>
      <tags>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>括号生成</title>
    <url>/2021/11/25/%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>数字n代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且有效的 括号组合。<br>有效括号组合需满足：左括号必须以正确的顺序闭合。</p>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>创建回溯，使str既可以添加(也可以添加)。但需要对添加的条件进行约束。<br>再对str是否完成进行判断。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt; answer;</span><br><span class="line">    public List&lt;String&gt; generateParenthesis(<span class="built_in">int</span> <span class="built_in">n</span>) &#123;</span><br><span class="line">        answer = new ArrayList&lt;String&gt;();</span><br><span class="line">        tarckback(<span class="built_in">n</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line">        return answer;</span><br><span class="line">    &#125;</span><br><span class="line">    public void tarckback(<span class="built_in">int</span> <span class="built_in">n</span>,<span class="built_in">int</span> <span class="built_in">left</span>,<span class="built_in">int</span> <span class="built_in">right</span>,String str)&#123;</span><br><span class="line">        <span class="built_in">if</span> (<span class="built_in">left</span>&lt;<span class="built_in">n</span>) &#123;</span><br><span class="line">            tarckback(<span class="built_in">n</span>,<span class="built_in">left</span>+<span class="number">1</span>,<span class="built_in">right</span>,str+<span class="string">&quot;(&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">if</span> (<span class="built_in">left</span>&gt;<span class="built_in">right</span>) &#123;</span><br><span class="line">            tarckback(<span class="built_in">n</span>,<span class="built_in">left</span>,<span class="built_in">right</span>+<span class="number">1</span>,str+<span class="string">&quot;)&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">if</span> (str.length() == <span class="number">2</span>*<span class="built_in">n</span>)&#123;</span><br><span class="line">            answer.add(str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode解析</category>
        <category>中等</category>
      </categories>
      <tags>
        <tag>回溯</tag>
      </tags>
  </entry>
</search>
