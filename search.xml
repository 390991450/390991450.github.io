<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>JDBC</title>
    <url>/2021/11/21/JDBC/</url>
    <content><![CDATA[<h1 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h1><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">//前置工作，在项目下创建一个文件夹，将mysql.jar文件拷贝到该目录下</span><br><span class="line">      //点击<span class="keyword">add</span> <span class="keyword">to</span> project加入到项目中。实现driver的抽象类。</span><br><span class="line">      // <span class="number">1</span>注册驱动</span><br><span class="line">      Driver driver = <span class="built_in">new</span> Driver();</span><br><span class="line">      //<span class="number">2</span>得到连接,mysql连接本质是socket连接</span><br><span class="line">      String url = &quot;jdbc:mysql://主机ip:端口/数据库名&quot;;</span><br><span class="line">      Properties properties = <span class="built_in">new</span> Properties();</span><br><span class="line">      properties.setProperty(&quot;user&quot;,&quot;用户名&quot;);</span><br><span class="line">      properties.setProperty(&quot;password&quot;,&quot;密码&quot;);</span><br><span class="line">      <span class="keyword">Connection</span> <span class="keyword">connect</span> = driver.<span class="keyword">connect</span>(url, properties);//这个<span class="keyword">connect</span>等同于socket</span><br><span class="line">      //<span class="number">3</span>执行<span class="keyword">sql</span></span><br><span class="line">      String <span class="keyword">sql</span> = &quot;要执行的sql语句&quot;;</span><br><span class="line">      //生成语法的执行器,返回值为更改的行数</span><br><span class="line">      <span class="keyword">Statement</span> <span class="keyword">statement</span> = <span class="keyword">connect</span>.createStatement();</span><br><span class="line">      <span class="type">int</span> <span class="keyword">rows</span> = <span class="keyword">statement</span>.executeUpdate(<span class="keyword">sql</span>);//只能存放dlm语句，<span class="keyword">select</span>用Query</span><br><span class="line">      //关闭连接资源</span><br><span class="line">      <span class="keyword">statement</span>.<span class="keyword">close</span>();</span><br><span class="line">      <span class="keyword">connect</span>.<span class="keyword">close</span>();</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h1 id="数据库连接方式"><a href="#数据库连接方式" class="headerlink" title="数据库连接方式"></a>数据库连接方式</h1><p>上面的方法可以连接数据库，但问题是这是一个静态加载，灵活性差，依赖性强。<br>可以使用反射机制取得driver，实现静态加载。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">        Class clazz = <span class="module-access"><span class="module"><span class="identifier">Class</span>.</span></span><span class="keyword">for</span><span class="constructor">Name(<span class="string">&quot;驱动路径&quot;</span>)</span>;</span><br><span class="line"><span class="comment">//下面这句话是可以不写的，在dirver中有一段静态代码，只要类加载后，会自动帮助注册驱动</span></span><br><span class="line">        Driver dirver = (Dirver)clazz.<span class="keyword">new</span><span class="constructor">Instance()</span>;</span><br></pre></td></tr></table></figure>
<p>还可以使用drivermanager来获取connect，但这个方法是静态同步调用，会造成低效率和死锁，不再展开。</p>
<h2 id="最常用的数据库连接方式："><a href="#最常用的数据库连接方式：" class="headerlink" title="最常用的数据库连接方式："></a>最常用的数据库连接方式：</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//mysql驱动5.1.6后这句类加载也可以省略，会自动调用。建议写上，防止多个驱动存在。</span><br><span class="line">//最省略的写法就是只要将驱动放入项目中，然后直接取得connection即可。</span><br><span class="line">Class clazz = Class.forName(&quot;驱动路径&quot;);</span><br><span class="line">//这里可以直接将这些信息存储到properties文件中，通过IO流取出。</span><br><span class="line">//new properties;</span><br><span class="line">//properties.load(new FileInpitStream(文件路径));</span><br><span class="line">String url = &quot;jdbc:mysql://主机ip:端口/数据库名&quot;;</span><br><span class="line">String user = </span><br><span class="line">String password = </span><br><span class="line">Connection connect = Drivermanager.getConnection(url,user,password);</span><br></pre></td></tr></table></figure>
<h1 id="ResultSet"><a href="#ResultSet" class="headerlink" title="ResultSet"></a>ResultSet</h1><p>在执行select语句后，会返回一个类似于迭代器的resultset。</p>
<figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ResultSet</span> <span class="keyword">resultset</span> = statement.executeQuery(<span class="string">&quot;查询语句&quot;</span>);</span><br><span class="line"><span class="comment">//next为向下移动，还可以使用previous向上移动</span></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">resultset</span>.next())&#123;</span><br><span class="line">        <span class="comment">//get方法中既可以填写索引，也可以填写列名。</span></span><br><span class="line">    int id = <span class="keyword">resultset</span>.getInt(<span class="number">1</span>);<span class="comment">//取出第一列，取出类型为int</span></span><br><span class="line">    <span class="params">...</span><span class="params">...</span></span><br><span class="line">&#125;</span><br><span class="line">resulset.close;</span><br><span class="line">statement.close();</span><br><span class="line">connect.close();</span><br></pre></td></tr></table></figure>
<h1 id="Statement"><a href="#Statement" class="headerlink" title="Statement"></a>Statement</h1><h2 id="执行SQl语句的三种渠道："><a href="#执行SQl语句的三种渠道：" class="headerlink" title="执行SQl语句的三种渠道："></a>执行SQl语句的三种渠道：</h2><p>1.Statement[存在SQl注入风险(注入非法的SQL语句攻击数据库)，一般不使用]。<br>2.PreparedStatement[预处理]。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">//PreparedStatement的使用方式</span></span><br><span class="line">String sql = <span class="string">&quot;select name, pwd from admin where name = ? and pwd = ?&quot;</span><span class="comment">//?相当于占位符</span></span><br><span class="line"><span class="comment">//preparedStatement有别于Statement，在创建时就要输入sql语句</span></span><br><span class="line">PreparedStatement preparedStatement = connection.prepared<span class="constructor">Statement(<span class="params">sql</span>)</span>;</span><br><span class="line">preparedStatement.set<span class="constructor">String(1,<span class="params">admin_name</span>)</span>;<span class="comment">//对应问号的位置，admin_name中存储接收的用户名</span></span><br><span class="line">preparedStatement.set<span class="constructor">String(2,<span class="params">admin_pwd</span>)</span>;</span><br><span class="line">ResultSet resultset = preparedStatement.execute<span class="constructor">Query()</span>;</span><br></pre></td></tr></table></figure>
<p>3.CallableStatement[存储过程]。</p>
<h2 id="Statement接口"><a href="#Statement接口" class="headerlink" title="Statement接口"></a>Statement接口</h2><p>executeUpdate(sql)执行dml语句，返回影响的行数。<br>executeQuery(sql)执行查询，返回ResultSet。<br>execute(sql)执行任意语句，返回布尔值，用于不需要返回行数或者结果集的语句。</p>
<h1 id="JDBCUtils的开发"><a href="#JDBCUtils的开发" class="headerlink" title="JDBCUtils的开发"></a>JDBCUtils的开发</h1><p>因为在JDBC过程中，数据库的连接和释放资源属于高重复度内容，因此一般将这些内容进行封装。</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDBCUtils</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">String</span> user;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">String</span> password;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">String</span> url;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">String</span> driver;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用静态代码块初始化</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Properties properties = <span class="keyword">new</span> <span class="type">Properties</span>();</span><br><span class="line">            properties.load(<span class="keyword">new</span> <span class="type">FileInputStream</span>(<span class="string">&quot;文件路径&quot;</span>));</span><br><span class="line">            user = properties.getProperty(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">            password = properties.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">            url = properties.getProperty(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">            driver = properties.getProperty(<span class="string">&quot;driver&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">//1.将编译异常转化为运行异常</span></span><br><span class="line">            <span class="comment">//2.调用者可以选择捕获改异常，也可以选择默认操作</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//连接数据库</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Connection getConnection()&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> DriverManager.getConnection(url,user,password);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//关闭资源</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> void close(ResultSet resultSet, Statement statement, Connection connection)&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (resultSet != <span class="literal">null</span>)&#123;</span><br><span class="line">                resultSet.close();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (statement != <span class="literal">null</span>)&#123;</span><br><span class="line">                statement.close();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (connection != <span class="literal">null</span>)&#123;</span><br><span class="line">                connection.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>首先要调用Connection.setAutoCommit(false),取消自动提交事务。<br>然后再使用Connection.commit()手动提交，使用Connection.rollback回滚事务(一般写在catch中)。</p>
<h1 id="批处理"><a href="#批处理" class="headerlink" title="批处理"></a>批处理</h1><p>启用批处理需要修改url语句。<br>String url = “jdbc:mysql://主机ip:端口/数据库名？rewriteBatchedStatements = true”;<br>preparedStatement.addBatch();将sql语句加入到集合中。<br>preparedStatement.executeBatch();批量执行sql语句。<br>preparedStatement.clearBatch();清空集合。</p>
<h1 id="传统连接方式的弊端"><a href="#传统连接方式的弊端" class="headerlink" title="传统连接方式的弊端"></a>传统连接方式的弊端</h1><p>1.每次向数据库建立连接时都要加载connection，再验证。<br>2.如果程序异常没能正常关闭会导致内存泄露。<br>3.不能控制创建的连接数量，连接过多会导致数据库崩溃。</p>
<h1 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h1><p>给定规定的连接口，所有连接接入走连接池，并排队，由连接池统一管理。<br>实现DataSource接口。</p>
<h2 id="C3P0"><a href="#C3P0" class="headerlink" title="C3P0"></a>C3P0</h2><p>类名：ComboPooledDataSource</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//给予连接池需要的信息，让连接池创建接向数据库的连接</span><br><span class="line">new ComboPooledDataSource();</span><br><span class="line">comboPooledDataSource.setDriverClass(驱动路径);</span><br><span class="line">comboPooledDataSource.setJdbcUrl(url);</span><br><span class="line">comboPooledDataSource.setUser(user);</span><br><span class="line">comboPooledDataSource.setPassword(password);</span><br><span class="line">//设置连接池的初始连接数和最大连接数</span><br><span class="line">comboPooledDataSource.setInitialPoolSize(int);</span><br><span class="line">comboPooledDataSource.setMaxPoolSize(int);</span><br><span class="line">//从连接池取得连接,注意这里的connection不是由DriverManager创建的，所以close方法也不同。</span><br><span class="line">Connection connection = comboPooledDataSource.getConnection();</span><br><span class="line">//这里的关闭并不是关闭了连接，而是把连接还给了连接池</span><br><span class="line">connection.close();</span><br></pre></td></tr></table></figure>
<p>除了上面这种连接方式，还可以将这些信息统一写在c3p0的config文件中，初始化时直接使用。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="constructor">ComboPooledDataSource(<span class="params">cofig</span>文件的数据源名称)</span>;</span><br></pre></td></tr></table></figure>
<h2 id="Druid-负责建立连接"><a href="#Druid-负责建立连接" class="headerlink" title="Druid(负责建立连接)"></a>Druid(负责建立连接)</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Properties properties = new Properties();</span><br><span class="line">properties.load(new FileInputStream(&quot;德鲁伊需要的配置文件&quot;));</span><br><span class="line">DataSource dataSource = DruidDataSourceFactory.createDataSource(properties);</span><br><span class="line">Connection connection = dataSource.getConnection();</span><br><span class="line">connection.close();</span><br></pre></td></tr></table></figure>
<p>这之后就可以基于druid重写JDBCUtils。</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="keyword">class</span> JDBCUtilsByDruid&#123;</span><br><span class="line">    private static DataSource dataSource;</span><br><span class="line">    static &#123;</span><br><span class="line">        Properties properties = <span class="built_in">new</span> Properties();</span><br><span class="line">        try &#123;</span><br><span class="line">            //废弃这个方法改用下面的新方法加载配置文件，这个加载方法会在web层出现空指针异常，原因不明</span><br><span class="line">            //properties.<span class="keyword">load</span>(<span class="built_in">new</span> FileInputStream(&quot;配置文件&quot;));</span><br><span class="line">            InputStream inputStream = JDBCUtilsByDruid.<span class="keyword">class</span>.getClassLoader().getResourceAsStream(&quot;book.properties&quot;);</span><br><span class="line">            properties.<span class="keyword">load</span>(inputStream);</span><br><span class="line">            dataSource = DruidDataSourceFactory.createDataSource(properties);</span><br><span class="line">        &#125; catch (<span class="keyword">Exception</span> e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">public</span> static <span class="keyword">Connection</span> getConnection() throws SQLException &#123;</span><br><span class="line">        <span class="keyword">return</span> dataSource.getConnection();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">public</span> static <span class="type">void</span> <span class="keyword">close</span>(ResultSet resultSet, <span class="keyword">Statement</span> <span class="keyword">statement</span>, <span class="keyword">Connection</span> <span class="keyword">connection</span>)&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            <span class="keyword">if</span> (resultSet != <span class="keyword">null</span>)&#123;</span><br><span class="line">                resultSet.<span class="keyword">close</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">statement</span> != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">statement</span>.<span class="keyword">close</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">connection</span> != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">connection</span>.<span class="keyword">close</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (SQLException e) &#123;</span><br><span class="line">            throw <span class="built_in">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="ApDBUtils-负责存储收到的信息"><a href="#ApDBUtils-负责存储收到的信息" class="headerlink" title="ApDBUtils(负责存储收到的信息)"></a>ApDBUtils(负责存储收到的信息)</h1><p>问题1：目前，当需要对resultset进行操作时，connection不能关闭，但连接池给的连接是有限的。<br>问题2：结果集只能使用一次。<br>问题3：结果集取得信息的方法并不方便。<br>解决办法：创建一个类，每行的数据创建为一个对象，使用List连接起来。<br>这个类就是下面的Actor.class,也是俗称的javabean。<br>向项目中加入DBUtils的包</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Connection connection = JDBCUtilsByDruid.getConnection();</span><br><span class="line">QueryRunner queryRunner = new QueryRunner();</span><br><span class="line">//select</span><br><span class="line">&#123;</span><br><span class="line">    //query方法就是执行一个sql语句并返回一个包含结果集的list</span><br><span class="line">    //最后的1是指sql语句中？要赋予的值</span><br><span class="line">    //使用这个办法不需要关闭结果集，在这句话的源码中，最后会自动关闭resultset和preparedStatement。</span><br><span class="line">    List&lt;Actor&gt; list =</span><br><span class="line">            queryRunner.query(connection,sql,new BeanListHandler&lt;&gt;(Actor.class),？赋值);</span><br><span class="line">    //单行查询</span><br><span class="line">    Actor actor = queryRunner.query(connection,sql,new BeanHandler&lt;&gt;(Actor.class),？赋值);</span><br><span class="line">    //单行单列</span><br><span class="line">    Object o = queryRunner.query(connection,sql,new ScalarHandler(),？赋值);</span><br><span class="line">&#125;</span><br><span class="line">//dml语句</span><br><span class="line">&#123;</span><br><span class="line">    int affectedRow = queryRunner.update(connection,sql,？赋值);</span><br><span class="line">&#125;</span><br><span class="line">DBUtilsByDruid.close(null,null,connection);</span><br></pre></td></tr></table></figure>
<h1 id="BasicDao"><a href="#BasicDao" class="headerlink" title="BasicDao"></a>BasicDao</h1><p>目前，JDBCUtilsByDruid已经实现了对Druid的封装，但DBUtils的操作依然繁琐，所以需要将<br>这整个操作进行封装，这样整个操作就简洁起来了。为了操作方便，对每个表制作一个对应的Dao。<br>在Dao的方法开发中，并不建议使用静态方法，因为这样你不再能保证connection不被两个以上的<br>线程同时调用，造成线程混乱。<br>另外BasicDao是基于泛型制定的方法，要想静态化只能将其下所有子类做静态化。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//开发BasicDao，作为其它类的父类，子类主要负责一些额外操作和确定类型</span><br><span class="line">public class BasicDao&lt;T&gt;&#123;</span><br><span class="line">    private QueryRunner qr = new QueryRunner();</span><br><span class="line">    //开发通用的dml方法，针对任意的表</span><br><span class="line">    public int update(String sql,Object...parameters)&#123;</span><br><span class="line">        //因为建立连接需要在try—catch-finally操作中，为了在finally关闭</span><br><span class="line">        //在外面先建立connection</span><br><span class="line">        Connection connection = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            connection = JDBCUtilsByDruid.getConnection();</span><br><span class="line">            int affectedRow = qr.update(connection,sql,parameters);</span><br><span class="line">            return affectedRow;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            throw new RuntimeException(e);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            //因为使用了DBUtils工具，所以只需要关闭(交还)connection即可</span><br><span class="line">            JDBCUtilsByDruid.close(null,null,connection);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //返回多行数据，针对任意的表</span><br><span class="line">    public List&lt;T&gt; queryMultiply(String sql,Class&lt;T&gt; clazz,Object... parameters)&#123;</span><br><span class="line">        Connection connection = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            connection = JDBCUtilsByDruid.getConnection();</span><br><span class="line">            List&lt;T&gt; list =</span><br><span class="line">                    qr.query(connection,sql,new BeanListHandler&lt;T&gt;(clazz),parameters);</span><br><span class="line">            return list;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            throw new RuntimeException(e);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            //因为使用了DBUtils工具，所以只需要关闭(交还)connection即可</span><br><span class="line">            JDBCUtilsByDruid.close(null,null,connection);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //返回单行数据</span><br><span class="line">    public T querySingle(String sql,Class&lt;T&gt; clazz,Object... parameters)&#123;</span><br><span class="line">        Connection connection = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            connection = JDBCUtilsByDruid.getConnection();</span><br><span class="line">            return qr.query(connection,sql,new BeanHandler&lt;T&gt;(clazz),parameters);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            throw new RuntimeException(e);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            //因为使用了DBUtils工具，所以只需要关闭(交还)connection即可</span><br><span class="line">            JDBCUtilsByDruid.close(null,null,connection);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //返回单个数据</span><br><span class="line">    public Object queryScalar(String sql,Object... parameters)&#123;</span><br><span class="line">        Connection connection = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            connection = JDBCUtilsByDruid.getConnection();</span><br><span class="line">            return qr.query(connection,sql,new ScalarHandler(),parameters);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            throw new RuntimeException(e);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            //因为使用了DBUtils工具，所以只需要关闭(交还)connection即可</span><br><span class="line">            JDBCUtilsByDruid.close(null,null,connection);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//使用具体表对应的类型继承BasicDao</span><br><span class="line">public class ActorDao extends BasicDao&lt;Actor&gt;&#123;</span><br><span class="line">        //这里根据业务需求写特有方法</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JDBC学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title>z字形变换</title>
    <url>/2021/11/22/z%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><pre><code>    将一个给定字符串s根据给定的行数numRows，以从上往下、从左到右进行Z字形排列。
    比如输入字符串为 &quot;PAYPALISHIRING&quot;行数为3时，排列如下：
    P   A   H   N
    A P L S I I G
    Y   I   R
    之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：&quot;PAHNAPLSIIGYIR&quot;。
</code></pre>
<span id="more"></span>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>寻找这种排布的规律。会发现每排字符的index与其所在行，以及总行数形成函数关系。<br>首先分析第一排：第一排的index差为2*(总行数-1)。<br>分析最后一排：与第一排规律相同。<br>其他排：每隔一个字符看与第一排的规律也相同，而相邻的字符存在关系，如第二个字符与第三个<br>字符间刚好差2*(当前行数-1)。则第一个字符与第二的字符的差就是：2*(总行数-1)-2*(当前行数-1)。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public String convert(String s, int numRows) &#123;</span><br><span class="line">        //如果长度为1，则直接返回</span><br><span class="line">        if (numRows == 1)&#123;</span><br><span class="line">            return s;</span><br><span class="line">        &#125;</span><br><span class="line">        char[] chars = s.toCharArray();</span><br><span class="line">        char[] answer = new char[chars.length];</span><br><span class="line">        int count = 0;</span><br><span class="line">        for (int i = 0;i&lt;numRows;i++)&#123;</span><br><span class="line">            int j= i;</span><br><span class="line">            while (j&lt;chars.length)&#123;</span><br><span class="line">                answer[count] = chars[j];</span><br><span class="line">                count++;</span><br><span class="line">                //统一处理n的两边数字，特别处理腰部的数字</span><br><span class="line">                if(!(i == 0||i == numRows-1))&#123;</span><br><span class="line">                    if ((2*numRows-2-2*i+j) &lt; chars.length) &#123;</span><br><span class="line">                        answer[count] = chars[2*numRows-2-2*i+j];</span><br><span class="line">                        count++;</span><br><span class="line">                        &#125;  </span><br><span class="line">                    &#125;</span><br><span class="line">                    j += (2*numRows-2);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return new String(answer);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode解析</category>
        <category>中等</category>
      </categories>
      <tags>
        <tag>数学分析</tag>
      </tags>
  </entry>
  <entry>
    <title>两数之和</title>
    <url>/2021/11/22/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><pre><code>    给定一个整数数组 nums和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那两个整数，并返回它们的数组下标。
    你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。
    你可以按任意顺序返回答案
</code></pre>
<h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>本题主要提供一种使用hashmap的key的思路。使map接收到一个数的差又不会接收它本身。</p>
<span id="more"></span>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">int</span>[] twoSum(<span class="built_in">int</span>[] nums, <span class="built_in">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">HashMap</span>&lt;Integer,<span class="keyword">Object</span>&gt; <span class="built_in">map</span> = <span class="keyword">new</span> <span class="keyword">HashMap</span>();</span><br><span class="line">        <span class="comment">//key种存放一个数字，value存放合适的数组</span></span><br><span class="line">        <span class="built_in">int</span>[] answer = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">        	<span class="comment">//这里为核心思路</span></span><br><span class="line">             <span class="keyword">if</span> (<span class="built_in">map</span>.containsKey(target-nums[i]))&#123;</span><br><span class="line">                <span class="built_in">int</span>[] ints = (<span class="built_in">int</span>[]) <span class="built_in">map</span>.<span class="built_in">get</span>(target-nums[i]);</span><br><span class="line">                ints[<span class="number">1</span>] = i;</span><br><span class="line">                answer = ints.clone();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">int</span>[] ints = &#123;i,<span class="number">0</span>&#125;;</span><br><span class="line">                <span class="built_in">map</span>.put(nums[i],ints );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode解析</category>
        <category>简单</category>
      </categories>
      <tags>
        <tag>hashmap</tag>
      </tags>
  </entry>
  <entry>
    <title>区间内查询数字频率</title>
    <url>/2021/11/21/%E5%8C%BA%E9%97%B4%E5%86%85%E6%9F%A5%E8%AF%A2%E6%95%B0%E5%AD%97%E9%A2%91%E7%8E%87/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><pre><code>    请你设计一个数据结构，它能求出给定子数组内一个给定值的频率。
    子数组中一个值的频率指的是这个子数组中这个值的出现次数。
    请你实现RangeFreqQuery类：
    RangeFreqQuery(int[] arr)用下标从 0开始的整数数组arr构造一个类的实例。
    int query(int left, int right, int value)返回子数组arr[left...right]中value的频率。
    一个子数组指的是数组中一段连续的元素。arr[left...right]指的是 nums中包含下标left和
    right在内的中间一段连续元素。
</code></pre>
<span id="more"></span>
<pre><code>    输入：
    [&quot;RangeFreqQuery&quot;, &quot;query&quot;, &quot;query&quot;]
    [[[12, 33, 4, 56, 22, 2, 34, 33, 22, 12, 34, 56]], [1, 2, 4], [0, 11, 33]]
    输出：
    [null, 1, 2]
</code></pre>
<h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>这道题使用暴力算法很简单，但示例有时间和内存限制，必须对算法进行优化。<br>创建一个hashmap，key存储要查询的数字，value中存储一个list，list存储出现的位置。<br>即使这样优化也会超时，所以在遍历list的时候还要使用二分查找，在这里要深度理解二分查找。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RangeFreqQuery</span> </span>&#123;</span><br><span class="line">    int[] array;</span><br><span class="line">    <span class="comment">//ArrayList list;//存放数字出现频率</span></span><br><span class="line">    HashMap map;<span class="comment">//存放list的钥匙库</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> RangeFreqQuery(int[] arr) &#123;</span><br><span class="line">        array = <span class="keyword">new</span> <span class="type">int</span>[arr.length];</span><br><span class="line">        <span class="comment">//list = new ArrayList();</span></span><br><span class="line">        map = <span class="keyword">new</span> <span class="type">HashMap</span>();</span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!map.containsKey(arr[i]))&#123;</span><br><span class="line">                ArrayList list = <span class="keyword">new</span> <span class="type">ArrayList</span>();</span><br><span class="line">                list.add(i);</span><br><span class="line">                map.put(arr[i],list);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                ArrayList list = (ArrayList) map.<span class="keyword">get</span>(arr[i]);</span><br><span class="line">                list.add(i);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> int query(int left, int right, int value) &#123;</span><br><span class="line">        ArrayList list = (ArrayList) map.<span class="keyword">get</span>(value);</span><br><span class="line">        <span class="keyword">if</span> (list == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            int <span class="keyword">new</span><span class="type">right</span> = list.size()<span class="number">-1</span>;</span><br><span class="line">            int <span class="keyword">new</span><span class="type">left</span> = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//考虑两种找不到的情况。list的第一位比right大，list的末位比left小</span></span><br><span class="line">            <span class="keyword">if</span> ((int)list.<span class="keyword">get</span>(<span class="number">0</span>)&gt;right||(int)list.<span class="keyword">get</span>(<span class="keyword">new</span><span class="type">right</span>)&lt;left)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//使用二分查找左，右指针位置</span></span><br><span class="line">            <span class="comment">//找到的左指针要求其指向的数字&gt;=left，即指向left或者第一个大于它的数字</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">new</span><span class="type">left</span> != <span class="keyword">new</span><span class="type">right</span>)&#123;</span><br><span class="line">                int mid = (<span class="keyword">new</span><span class="type">left</span>+<span class="keyword">new</span><span class="type">right</span>)/<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span> ((int)list.<span class="keyword">get</span>(mid) &gt;= left)&#123;</span><br><span class="line">                    <span class="keyword">new</span><span class="type">right</span> = mid;<span class="comment">//因为目标数字最后总在截取范围的后段，需要不断舍去前半部分的数字</span></span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;			   <span class="comment">//所以mid尽量取小(left+right)/2。</span></span><br><span class="line">                    <span class="keyword">new</span><span class="type">left</span> = mid+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            int leftnum = <span class="keyword">new</span><span class="type">left</span>;</span><br><span class="line">            <span class="keyword">new</span><span class="type">right</span> = list.size()<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">new</span><span class="type">left</span> = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//找到的右指针要求其指向的数字&lt;=right，即指向right或者第一个小于它的数字</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">new</span><span class="type">left</span> != <span class="keyword">new</span><span class="type">right</span>)&#123;</span><br><span class="line">                int mid = (<span class="keyword">new</span><span class="type">left</span>+<span class="keyword">new</span><span class="type">right</span>+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span> ((int)list.<span class="keyword">get</span>(mid) &lt;= right)&#123;</span><br><span class="line">                    <span class="keyword">new</span><span class="type">left</span> = mid;<span class="comment">//因为目标数字最后总在截取范围的前段，需要不断舍去前后部分的数字</span></span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;			  <span class="comment">//所以mid尽量取大(left+right+1)/2。</span></span><br><span class="line">                    <span class="keyword">new</span><span class="type">right</span> = mid<span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            int rightnum = <span class="keyword">new</span><span class="type">right</span>;</span><br><span class="line">            <span class="keyword">return</span> rightnum-leftnum+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode解析</category>
        <category>困难</category>
      </categories>
      <tags>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>打乱数组</title>
    <url>/2021/11/22/%E6%89%93%E4%B9%B1%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><pre><code>    给你一个整数数组 nums ，设计算法来打乱一个没有重复元素的数组。
    实现 Solution class:
    Solution(int[] nums) 使用整数数组 nums 初始化对象
    int[] reset() 重设数组到它的初始状态并返回
    int[] shuffle() 返回数组随机打乱后的结果
</code></pre>
<span id="more"></span>
<h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>本题没有难度，用于洗牌算法的学习</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int[] arr;</span><br><span class="line">  Random random = new Random();</span><br><span class="line">   public Solution(int[] nums) &#123;</span><br><span class="line">       arr = nums;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   public int[] reset() &#123;</span><br><span class="line">       return arr;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   public int[] shuffle() &#123;</span><br><span class="line">       int[] newArr = arr.clone();</span><br><span class="line">       //每次移动视为对当前位置随机成功</span><br><span class="line">       for(int i = 0;i&lt;arr.length;i++)&#123;</span><br><span class="line">       	//nextInt方法取到的数字为左闭右开区间</span><br><span class="line">           int num = i+random.nextInt(arr.length-i);</span><br><span class="line">           int cache = newArr[i];</span><br><span class="line">           newArr[i] = newArr[num];</span><br><span class="line">           newArr[num] = cache;</span><br><span class="line">       &#125;</span><br><span class="line">       return newArr;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode解析</category>
        <category>中等</category>
      </categories>
      <tags>
        <tag>洗牌算法</tag>
      </tags>
  </entry>
  <entry>
    <title>无重复最长数组</title>
    <url>/2021/11/22/%E6%97%A0%E9%87%8D%E5%A4%8D%E6%9C%80%E9%95%BF%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><pre><code>    给定一个字符串s，请你找出其中不含有重复字符的最长子串的长度。
</code></pre>
<h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>合理使用滑动窗口对字符串进行更新,每次遇到重复字符时收缩滑动窗口左端。</p>
<span id="more"></span>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="keyword">String</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">length</span>() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = <span class="number">1</span>;<span class="comment">//end一直指向无重复的下一位</span></span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span>[] chars = s.<span class="built_in">toCharArray</span>();</span><br><span class="line">        <span class="keyword">for</span> (;end&lt;chars.length;end++)&#123;</span><br><span class="line">            <span class="keyword">int</span> point = start;</span><br><span class="line">            <span class="comment">//判断前面的数组是否重复</span></span><br><span class="line">            <span class="keyword">for</span> (;point&lt;end;point++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (chars[point] == chars[end])&#123;</span><br><span class="line">                    <span class="comment">//说明当前无重复数组到达最大，比较记录</span></span><br><span class="line">                    max = Math.<span class="built_in">max</span>(max,end-start);</span><br><span class="line">                    <span class="comment">//更新start点位</span></span><br><span class="line">                    start = point+<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//还需要计算一次max</span></span><br><span class="line">        max = Math.<span class="built_in">max</span>(max,end-start);</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode解析</category>
        <category>中等</category>
      </categories>
      <tags>
        <tag>字符串检索</tag>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title>排列序列</title>
    <url>/2021/11/20/%E6%8E%92%E5%88%97%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><pre><code>    给出集合[1,2,3,...,n]，其所有元素共有n! 种排列。
    按大小顺序列出所有排列情况，并一一标记，当n = 3 时, 所有排列如下：
    &quot;123&quot;
    &quot;132&quot;
    &quot;213&quot;
    &quot;231&quot;
    &quot;312&quot;
    &quot;321&quot;
    给定n 和k，返回第k个排列。
</code></pre>
<span id="more"></span>
<h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>因为数字从小到大排列，所以可以直接由每位的数字来确定该数字所处位置。<br>如例中所示首位确定时，后两位能产生2！种变化，当第二位确定时，最后一位便确定。k的范围是1~6，12，34，56各一组。<br>需要对k处理方便计算，令k–，则k–除以2！可以正好被拆分开，再取得余数，用于确定下一位。<br>若k为5，则第一位的数字为第(5+1/2!)+1个数字,第二位的数字为(0/1!)+1个数字，第三位为剩下的最后一个数字。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public String getPermutation(int n, int k) &#123;</span><br><span class="line">        if (n ==1)&#123;</span><br><span class="line">            return &quot;1&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        //创建一个阶乘的数组，进行统计</span><br><span class="line">        k--;</span><br><span class="line">        int[][] count = new int[n - 1][2];</span><br><span class="line">        count[0][0] = 1;</span><br><span class="line">        for (int i = 1;i&lt;count.length;i++)&#123;</span><br><span class="line">            count[i][0] = count[i-1][0]*(i+1);</span><br><span class="line">        &#125;</span><br><span class="line">        int[] ints = new int[n];</span><br><span class="line">        for (int i = 0;i&lt;n;i++)&#123;</span><br><span class="line">            ints[i] = i+1;</span><br><span class="line">        &#125;</span><br><span class="line">        //开始逐个从数组中取出数组</span><br><span class="line">        String str = new String();</span><br><span class="line">        for (int i = count.length-1;i&gt;=0;i--)&#123;</span><br><span class="line">            count[i][1] = k/count[i][0];</span><br><span class="line">            int counter = -1;</span><br><span class="line">            for (int j = 0;j&lt;ints.length;j++)&#123;</span><br><span class="line">                if (ints[j] != 0)&#123;</span><br><span class="line">                    counter++;</span><br><span class="line">                    if (counter==count[i][1])&#123;</span><br><span class="line">                        str+=ints[j];</span><br><span class="line">                        ints[j] =0;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            k %= count[i][0];</span><br><span class="line">        &#125;</span><br><span class="line">        for (int o:ints)&#123;</span><br><span class="line">            if (o != 0)&#123;</span><br><span class="line">                str+=o;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return str;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>leetcode解析</category>
        <category>困难</category>
      </categories>
      <tags>
        <tag>数学分析</tag>
      </tags>
  </entry>
  <entry>
    <title>最长和谐子序列</title>
    <url>/2021/11/20/%E6%9C%80%E9%95%BF%E5%92%8C%E8%B0%90%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><pre><code>    和谐数组是指一个数组里元素的最大值和最小值之间的差别 正好是 1 。
    现在，给你一个整数数组 nums ，请你在所有可能的子序列中找到最长的和谐子序列的长度。
    数组的子序列是一个由数组派生出来的序列，它可以通过删除一些元素或不删除元素、且不改变其余元素的顺序而得到。
示例：
    输入：nums = [1,3,2,2,5,2,3,7]
    输出：5
    解释：最长的和谐子序列是 [3,2,2,2,3]
</code></pre>
<span id="more"></span>
<h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>创建一个hashmap，再通过条件判断，直接检索答案。    </p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int findLHS(int[] nums) &#123;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        //记录每个数字的个数</span><br><span class="line">        for (int o :nums)&#123;</span><br><span class="line">            if (!map.containsKey(o))&#123;</span><br><span class="line">                map.put(o,0);</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(o, map.get(o)+1);</span><br><span class="line">        &#125;</span><br><span class="line">        if (map.size() &lt; 2)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int max = 0;</span><br><span class="line">        //从map中查询相邻数字，并且判断max</span><br><span class="line">        for (int key:map.keySet())&#123;</span><br><span class="line">            if (map.get(key+1) != null)&#123;</span><br><span class="line">                max = Math.max(max,map.get(key)+map.get(key+1));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return max;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode解析</category>
        <category>简单</category>
      </categories>
      <tags>
        <tag>hashmap</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式匹配</title>
    <url>/2021/11/23/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给你一个字符串s和一个字符规律p，请你来实现一个支持 ‘.’和’星号’的正则表达式匹配。<br>‘.’ 匹配任意单个字符<br>‘星号’ 匹配零个或多个前面的那一个元素<br>所谓匹配，是要涵盖整个字符串s的，而不是部分字符串。</p>
<span id="more"></span>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>设dp[i,j]表示第i长的s与j长的p的匹配情况。<br>下面开始分情况讨论：<br>//普通字符<br>当dp[i-1，j-1]为真的时候，如果s[i] == p[j]，则dp[i,j]为真，否则必定为假。<br>当dp[i-1，j-1]为假的时候，只要是普通字符则必定为假。<br>//星字符<br>当不使用星字符修饰的字符就能匹配时，则dp[i,j-2]必定为真。<br>当星的字符开始循环后能匹配时，查询dp[i-1,j]是否为真，若为真，且s[i] = p[j-1]，则为真，其他情况为假。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public boolean isMatch(String s, String p) &#123;</span><br><span class="line">        boolean[][] dp = new boolean[s.length() + 1][p.length() + 1];</span><br><span class="line">        //因为dp的判断点依靠左上，左侧以及上方点位，所以逐行对dp进行填充</span><br><span class="line">        //初始化第一列</span><br><span class="line">        dp[0][0] = true;</span><br><span class="line">        for (int i = 1;i&lt;dp.length;i++)&#123;</span><br><span class="line">            dp[i][0] = false;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0;i&lt;dp.length;i++)&#123;</span><br><span class="line">            for (int j = 1;j&lt;dp[0].length;j++)&#123;</span><br><span class="line">                if (p.substring(j-1,j).equals(&quot;*&quot;))&#123;</span><br><span class="line">                    if (dp[i][j-2]||</span><br><span class="line">                    	//判断*作0的情况</span><br><span class="line">                    	(i&gt;0&amp;&amp;dp[i-1][j]&amp;&amp;(s.substring(i-1,i).equals(p.substring(j-2,j-1))</span><br><span class="line">                    	||p.substring(j-2,j-1).equals(&quot;.&quot;))))&#123;</span><br><span class="line">                    	//判断*大于1的情况</span><br><span class="line">                        dp[i][j] = true;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;else &#123;</span><br><span class="line">                    if (i&gt;0&amp;&amp;dp[i-1][j-1]&amp;&amp;(p.substring(j-1,j).equals(&quot;.&quot;)||s.substring(i-1,i).equals(p.substring(j-1,j))))&#123;</span><br><span class="line">                        dp[i][j] = true;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (dp[s.length()][p.length()])&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode解析</category>
        <category>困难</category>
      </categories>
      <tags>
        <tag>字符串检索</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>最长回文子串</title>
    <url>/2021/11/22/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><pre><code>    给你一个字符串s，找到s中最长的回文子串。
</code></pre>
<h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>首先对整个字符串加#，将单数字符串与双数字符串转换为单数字符串，减少代码量。<br>接着使用manacher算法：当一个短的字符串被包含在长字符串中时，具有一定的对称性。<br>情况一：短的字符串的镜像被包含在长字符串中，如caabaac，查a的长度，这时二者的长度相等。<br>情况二：短的字符串的镜像超出了长字符串的范围，此时这个字符串的长度正好到到长字符串的顶端。<br>情况三：短的字符串的镜像刚好落在了长字符串的一端，此时这个字符串长度最短到长字符串的顶端。</p>
<span id="more"></span>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">String</span> longestPalindrome(<span class="keyword">String</span> s) &#123;</span><br><span class="line">        <span class="built_in">char</span>[] chars = s.toCharArray();</span><br><span class="line">        <span class="built_in">char</span>[] <span class="built_in">str</span> = <span class="keyword">new</span> <span class="built_in">char</span>[chars.length * <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>;i&lt;chars.length;i++)&#123;</span><br><span class="line">            <span class="built_in">str</span>[<span class="number">2</span>*i] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">            <span class="built_in">str</span>[<span class="number">2</span>*i+<span class="number">1</span>] = chars[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">str</span>[<span class="built_in">str</span>.length<span class="number">-1</span>] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">        <span class="comment">//对字符串进行处理，把奇偶两种情况都转换为奇数情况</span></span><br><span class="line">        <span class="built_in">int</span>[] length = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="built_in">str</span>.length];</span><br><span class="line">        <span class="comment">//用于记录回文半径</span></span><br><span class="line">        <span class="built_in">int</span> shadow = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//创建一个数，用来记录最大阴影。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>;i&lt;<span class="built_in">str</span>.length;i++)&#123;</span><br><span class="line">            <span class="comment">//使用manacher算法</span></span><br><span class="line">            <span class="comment">//判断数字是否在阴影中</span></span><br><span class="line">            <span class="built_in">int</span> shadowLength = shadow+length[shadow];</span><br><span class="line">            <span class="keyword">if</span> (i!=<span class="number">0</span>&amp;&amp;i&lt;shadowLength)&#123;</span><br><span class="line">                <span class="comment">//取得镜像点</span></span><br><span class="line">                <span class="built_in">int</span> mirro = shadow-(i-shadow);</span><br><span class="line">                <span class="comment">//进入manacher算法后要分三种情况</span></span><br><span class="line">                <span class="comment">//镜像长度在阴影内</span></span><br><span class="line">                <span class="keyword">if</span> (i+length[mirro]&lt;shadowLength)&#123;</span><br><span class="line">                    length[i] = length[mirro];</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (i+length[mirro] &gt;shadowLength)&#123;</span><br><span class="line">                    length[i] = shadowLength-i;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    length[i] = shadowLength-i;</span><br><span class="line">                    <span class="built_in">int</span> left = i-(shadowLength-i);</span><br><span class="line">                    <span class="built_in">int</span> right = shadowLength;</span><br><span class="line">                    <span class="keyword">while</span> (left<span class="number">-1</span>&gt;=<span class="number">0</span>&amp;&amp;right+<span class="number">1</span>&lt;<span class="built_in">str</span>.length&amp;&amp;<span class="built_in">str</span>[left<span class="number">-1</span>]==<span class="built_in">str</span>[right+<span class="number">1</span>])&#123;</span><br><span class="line">                        left--;</span><br><span class="line">                        right++;</span><br><span class="line">                        length[i]++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//不在阴影中使用传统暴力算法</span></span><br><span class="line">            <span class="built_in">int</span> left = i;</span><br><span class="line">            <span class="built_in">int</span> right = i;</span><br><span class="line">            <span class="keyword">while</span> (left<span class="number">-1</span>&gt;=<span class="number">0</span>&amp;&amp;right+<span class="number">1</span>&lt;<span class="built_in">str</span>.length&amp;&amp;<span class="built_in">str</span>[left<span class="number">-1</span>]==<span class="built_in">str</span>[right+<span class="number">1</span>])&#123;</span><br><span class="line">                left--;</span><br><span class="line">                right++;</span><br><span class="line">                length[i]++;</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//更新阴影</span></span><br><span class="line">            <span class="keyword">if</span> (shadow+length[shadow]&lt;i+length[i])&#123;</span><br><span class="line">                shadow = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">int</span> maxPoint=<span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">int</span> maxLength = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i =<span class="number">0</span>;i&lt;length.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (length[i]&gt;maxLength)&#123;</span><br><span class="line">                maxLength = length[i];</span><br><span class="line">                maxPoint = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">String</span> answer = <span class="keyword">new</span> <span class="keyword">String</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = maxPoint-maxLength;i&lt;=maxPoint+maxLength;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">str</span>[i] != <span class="string">&#x27;#&#x27;</span>)&#123;</span><br><span class="line">                answer += <span class="built_in">str</span>[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode解析</category>
        <category>中等</category>
      </categories>
      <tags>
        <tag>字符串检索</tag>
        <tag>manacher算法</tag>
      </tags>
  </entry>
  <entry>
    <title>盛水最多的容器</title>
    <url>/2021/11/24/%E7%9B%9B%E6%B0%B4%E6%9C%80%E5%A4%9A%E7%9A%84%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给你 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点(i,ai) 。<br>在坐标内画 n 条垂直线，垂直线 i的两个端点分别为(i,ai)和(i,0)。找出其中的两条线，使得它们与x轴共同构成的容器可以容纳最多的水。</p>
<span id="more"></span>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>首先将左右指针指向两端。然后寻找可能使面积更大的组合，无论左右指针哪个移动，底宽都是<br>原来-1。底宽减小，则只有min(left,right)变大才可能使面积变大，若向内移动长边，因为短边<br>没变，所以不可能使min(left,right)变大，只能移动短边，希望短边侧变长。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int maxArea(int[] height) &#123;</span><br><span class="line">        int left = 0;</span><br><span class="line">        int right = height.length-1;</span><br><span class="line">        int max = 0;</span><br><span class="line">        while (left != right)&#123;</span><br><span class="line">            int area = Math.min(height[left],height[right])*(right-left);</span><br><span class="line">            max = Math.max(area,max);</span><br><span class="line">            if (height[left] &lt; height[right])&#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        return max;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode解析</category>
        <category>中等</category>
      </categories>
      <tags>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>三数之和</title>
    <url>/2021/11/25/%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给你一个包含 n 个整数的数组nums，判断nums中是否存在三个元素 a，b，c ，使得a+b+c=0？<br>请你找出所有和为0 且不重复的三元组。<br>注意：答案中不可以包含重复的三元组。</p>
<span id="more"></span>
<h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>本题主要难度在于如何去重。首先将数组排序，从数组左方取出第一个数字，且每次取到的数字不能为重复。<br>接着从第一个数字右方取出第二个数字，从第二数字右方找到第三个数。<br>然后着手算法的优化，因为数组是排序好的，所以第三个数字可以使用二分查找。<br>因为三数和为0，且num1&lt; num2 &lt; num3，当num1大于0时不可能有解直接结束循环。<br>当num1+num2大于0时不可能有解。<br>当数组第一个数大于0或者末位小于0，或者数组长度小于3，为空解直接返回空。<br>因为for循环查询长度较长，考虑使用增强for循环。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123;</span><br><span class="line">        ArrayList&lt;List&lt;Integer&gt;&gt; lists = new ArrayList&lt;&gt;();</span><br><span class="line">        if (nums.length&lt;3)&#123;</span><br><span class="line">            return lists;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        //当数组第一个数大于0或者末位小于0，或者数组长度小于3，为空解直接返回空。</span><br><span class="line">        if (nums[0]&gt;0||nums[nums.length-1]&lt;0)&#123;</span><br><span class="line">            return lists;</span><br><span class="line">        &#125;</span><br><span class="line">        //首先将数组排序，从数组左方取出第一个数字，且每次取到的数字不能为重复。</span><br><span class="line">        int answer1 = 100001;</span><br><span class="line">        int answer2 = 100001;</span><br><span class="line">        int i = 0;</span><br><span class="line">        for (int num1:nums)&#123;</span><br><span class="line">            if (num1 == answer1)&#123;</span><br><span class="line">                i++;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            //因为三数和为0，且num1&lt; num2 &lt; num3，当num1大于0时不可能有解直接结束循环。</span><br><span class="line">            if (num1&gt;0)&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            answer1 = num1;</span><br><span class="line">            i++;</span><br><span class="line">            //接着从第一个数字右方取出第二个数字，从第二数字右方找到第三个数。</span><br><span class="line">            for (int j = i;j&lt; nums.length-1;j++)&#123;</span><br><span class="line">                if (j&gt;i&amp;&amp;nums[j] == answer2)&#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                //因为数组是排序好的，所以第三个数字可以使用二分查找。</span><br><span class="line">                answer2 = nums[j];</span><br><span class="line">                if (answer1+answer2&gt;0)&#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                int answer3 = 0-answer1-answer2;</span><br><span class="line">                int k = Arrays.binarySearch(nums,j+1,nums.length,answer3);</span><br><span class="line">                if (k&gt;0)&#123;</span><br><span class="line">                    lists.add(Arrays.asList(answer1,answer2,answer3));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return lists;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode解析</category>
        <category>中等</category>
      </categories>
      <tags>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>可怜的小猪</title>
    <url>/2021/11/25/%E5%8F%AF%E6%80%9C%E7%9A%84%E5%B0%8F%E7%8C%AA/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>有buckets桶液体，其中正好有一桶含有毒药，其余装的都是水。它们从外观看起来都一样。<br>为了弄清楚哪只水桶含有毒药，你可以喂一些猪喝，通过观察猪是否会死进行判断。不幸的是，<br>你只有minutesToTest分钟时间来确定哪桶液体是有毒的。<br>喂猪的规则如下：</p>
<span id="more"></span>
<p>选择若干活猪进行喂养,可以允许小猪同时饮用任意数量的桶中的水，并且该过程不需要时间。<br>小猪喝完水后，必须有minutesToDie分钟的冷却时间。在这段时间里，你只能观察，而不允许<br>继续喂猪。过了 minutesToDie 分钟后，所有喝到毒药的猪都会死去，其他所有猪都会活下来。<br>重复这一过程，直到时间用完。<br>给你桶的数目buckets，minutesToDie和minutesToTest，返回在规定时间内判断哪个桶有<br>毒所需的最小猪数。</p>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>这道题比较有意思，只要看到本质是很简单一道题。分析每只猪能带多少信息，如果有x轮，猪<br>可以在x中的一轮中死亡，或者不死亡。所以每只猪可以看作x+1进制的单位，只要能表示出10进<br>制的桶数即成功。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public <span class="built_in">int</span> poor<span class="constructor">Pigs(<span class="params">int</span> <span class="params">buckets</span>, <span class="params">int</span> <span class="params">minutesToDie</span>, <span class="params">int</span> <span class="params">minutesToTest</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">int</span> x = minutesToTest/minutesToDie+<span class="number">1</span>;</span><br><span class="line">        double temp = <span class="module-access"><span class="module"><span class="identifier">Math</span>.</span></span>log(buckets)/<span class="module-access"><span class="module"><span class="identifier">Math</span>.</span></span>log(x);</span><br><span class="line">        return (<span class="built_in">int</span>)<span class="module-access"><span class="module"><span class="identifier">Math</span>.</span></span>ceil(temp);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode解析</category>
        <category>困难</category>
      </categories>
      <tags>
        <tag>进制问题</tag>
      </tags>
  </entry>
  <entry>
    <title>删除倒数第n个节点</title>
    <url>/2021/11/25/%E5%88%A0%E9%99%A4%E5%80%92%E6%95%B0%E7%AC%ACn%E4%B8%AA%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点</p>
<span id="more"></span>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>使用回溯，返回时开始计数，返回到父节点。方便操作，再添加一个伪父节点</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> ListNode removeNthFromEnd(ListNode head, <span class="built_in">int</span> n) &#123;</span><br><span class="line">        ListNode fhead = <span class="keyword">new</span> ListNode(<span class="number">0</span>,head);</span><br><span class="line">        trackback(fhead,n);</span><br><span class="line">        <span class="keyword">return</span> fhead.<span class="keyword">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> trackback(ListNode head,<span class="built_in">int</span> n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(head.<span class="keyword">next</span> != <span class="literal">null</span>)&#123;</span><br><span class="line">            trackback(head.<span class="keyword">next</span>,n);</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(num == n)&#123;</span><br><span class="line">            head.<span class="keyword">next</span> = head.<span class="keyword">next</span>.<span class="keyword">next</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode解析</category>
        <category>中等</category>
      </categories>
      <tags>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>括号生成</title>
    <url>/2021/11/25/%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>数字n代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且有效的 括号组合。<br>有效括号组合需满足：左括号必须以正确的顺序闭合。</p>
<span id="more"></span>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>创建回溯，使str既可以添加(也可以添加)。但需要对添加的条件进行约束。<br>再对str是否完成进行判断。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt; answer;</span><br><span class="line">    public List&lt;String&gt; generateParenthesis(<span class="built_in">int</span> <span class="built_in">n</span>) &#123;</span><br><span class="line">        answer = new ArrayList&lt;String&gt;();</span><br><span class="line">        tarckback(<span class="built_in">n</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line">        return answer;</span><br><span class="line">    &#125;</span><br><span class="line">    public void tarckback(<span class="built_in">int</span> <span class="built_in">n</span>,<span class="built_in">int</span> <span class="built_in">left</span>,<span class="built_in">int</span> <span class="built_in">right</span>,String str)&#123;</span><br><span class="line">        <span class="built_in">if</span> (<span class="built_in">left</span>&lt;<span class="built_in">n</span>) &#123;</span><br><span class="line">            tarckback(<span class="built_in">n</span>,<span class="built_in">left</span>+<span class="number">1</span>,<span class="built_in">right</span>,str+<span class="string">&quot;(&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">if</span> (<span class="built_in">left</span>&gt;<span class="built_in">right</span>) &#123;</span><br><span class="line">            tarckback(<span class="built_in">n</span>,<span class="built_in">left</span>,<span class="built_in">right</span>+<span class="number">1</span>,str+<span class="string">&quot;)&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">if</span> (str.length() == <span class="number">2</span>*<span class="built_in">n</span>)&#123;</span><br><span class="line">            answer.add(str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode解析</category>
        <category>中等</category>
      </categories>
      <tags>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>搜索旋转排序数组</title>
    <url>/2021/11/26/%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>整数数组nums按升序排列，数组中的值互不相同。<br>在传递给函数之前，nums在预先未知的某个下标k(0 &lt;= k &lt; nums.length)上进行了旋转，<br>使数组变为[nums[k], nums[k+1], …, nums[n-1], nums[0], nums[1], …, nums[k-1]]<br>(下标 从 0 开始 计数)。例如，[0,1,2,4,5,6,7]在下标3处经旋转后可能变为[4,5,6,7,0,1,2] 。<br>给你旋转后的数组nums和一个整数target，如果nums中存在这个目标值target,则返回它的下标,<br>否则返回-1。</p>
<span id="more"></span>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>对数组进行二分，有一半可以进行二分查找，如果目标数组在一排序好的一半则可以直接使用二分查找，<br>否则继续进行二分。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int search(int[] nums, int target) &#123;</span><br><span class="line">        //二分查找，先查排序好的，再对另一部分二分</span><br><span class="line">        int answer =  biSearch(0, nums.length-1, nums,target);</span><br><span class="line">        if (answer&lt;0)&#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            return answer;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public int biSearch(int first,int last,int[] num,int target)&#123;</span><br><span class="line">        //判断是否找到数字或者二分结束</span><br><span class="line">        int mid = (first+last)/2;</span><br><span class="line">        if (num[mid] == target)&#123;</span><br><span class="line">            return mid;</span><br><span class="line">        &#125;else if (mid == last)&#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        //判断哪部分是排序好的</span><br><span class="line">        if (num[first]&lt;num[mid])&#123;</span><br><span class="line">            if (target&gt;=num[first]&amp;&amp;target&lt;=num[mid])&#123;</span><br><span class="line">                return Arrays.binarySearch(num,first,mid+1,target);</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                return biSearch(mid+1,last,num,target);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            if (target&gt;=num[mid+1]&amp;&amp;target&lt;=num[last])&#123;</span><br><span class="line">                return Arrays.binarySearch(num,mid+1,last+1,target);</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                return biSearch(first,mid,num,target);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode解析</category>
        <category>中等</category>
      </categories>
      <tags>
        <tag>查找，二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程高并发</title>
    <url>/2021/11/26/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%AB%98%E5%B9%B6%E5%8F%91/</url>
    <content><![CDATA[<h1 id="如何确定合适的线程数"><a href="#如何确定合适的线程数" class="headerlink" title="如何确定合适的线程数"></a>如何确定合适的线程数</h1><p>根据任务需要执行计算的时间占比分配线程数。如：4核，任务中计算占比25%的任务分配16线程。</p>
<span id="more"></span>
<h1 id="缓存行编程技巧"><a href="#缓存行编程技巧" class="headerlink" title="缓存行编程技巧"></a>缓存行编程技巧</h1><p>前提知识：缓存行每次从内存拉取64bytes的内容。同一缓存行在不同cpu中同时处理时需要不断对齐。<br>例：<br>创建一个类，类中存放一个long型数据，创建一个2容量这个类的数组，启动两个线程分别对这两个<br>类的long型数据处理。时间记作t1。<br>创建一个与上面相似的类，但在其中的long型数据前和后分别填充7个无用的long型数据，再执行与<br>上面相同的操作。时间记作t2。<br>结果是t2会比t1短很多。原因是，第一个类中，两个要处理的数据会处于同一缓存行，在处理时需要不断<br>的对齐。二第二个类中，因为无用long型数据的填充，使得两个被操作的数据无法处于同一缓存行，不用对齐。</p>
<h1 id="指令重排"><a href="#指令重排" class="headerlink" title="指令重排"></a>指令重排</h1><p>问题：<br>在cpu执行语句时，happens-before规则约束后，可能会在执行过程中发生指令重排，<br>宏观表现为语句的倒转。而这种问题会导致this引用逃逸。如下面的代码就可能会输出0。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ThisEscape&#123;</span><br><span class="line">	private int num = 0;</span><br><span class="line">	public ThisEscape()&#123;</span><br><span class="line">		new Thread(()-&gt;System.out.println(this.num)).start();</span><br><span class="line">	&#125; </span><br><span class="line">	public static void mian(String[] args)throw Exception&#123;</span><br><span class="line">		new ThisEscape();</span><br><span class="line">		System.in.read();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分析：num的初始在汇编中有三步，创建空间，赋值，再指向。但this一开始就指向了他本身，所以可能<br>在num没有初始化完成时就调用了this指针，将num发送出去。<br>如何避免：不要在构造方法中启动线程</p>
<h1 id="提高并发效率"><a href="#提高并发效率" class="headerlink" title="提高并发效率"></a>提高并发效率</h1><p>合理的上锁，不要锁太多没必要的内容导致并发效率降低。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//给整个函数上锁</span><br><span class="line">public synchronized ...()&#123;&#125;</span><br><span class="line">//给部分代码上锁，注意静态方法中锁只能是本身的类对象</span><br><span class="line">synchronized(类对象)&#123;要执行的代码&#125;</span><br></pre></td></tr></table></figure>
<p>double check lock<br>在给部分代码上锁的过程中一般会进行判断，但注意不可以只在上锁前进行判断，因为线程可能会在任意<br>阶段发生切换，多个线程同时挤进判断语句中也会发生，所以在锁内要再加判断，如果情况变了，要归还锁。<br>这种上锁方式，只对内层进行上锁仍然可以起到相同的效果，但加入外层锁后可以减少上锁解锁的过程，<br>提升代码效率。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//单例模式取得对象</span><br><span class="line">if(INSTANCE == null)&#123;</span><br><span class="line">	synchronized(当前类)&#123;</span><br><span class="line">		if(INSTANCE == null)&#123;</span><br><span class="line">			INSTANCE = new 类对象;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个双锁仍旧有问题，new对象时如果发生指令重排，当只指向地址但未赋值时，此时恰好又有另一个线程访问对象，就会访问到未初始的对象。(虽然被锁定，但是上锁的代码和未上锁的代码是可以访问到中间态的)(java高版本已经解决了这个问题)<br>cpu级防止指令交换：添加屏障指令<br>jvm中防止指令交换：四种内存屏障Load-Store<br>java中防止指令交换：在修饰的前面加volatile</p>
]]></content>
      <categories>
        <category>多线程高并发</category>
      </categories>
  </entry>
  <entry>
    <title>并发编程题目</title>
    <url>/2021/11/26/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h1><p>1.进程要分配一大部分的内存，而线程只需要分配一部分栈就可以了.<br>2.一个程序至少有一个进程,一个进程至少有一个线程.<br>3.进程是资源分配的最小单位，线程是程序执行的最小单位。<br>4.一个线程可以创建和撤销另一个线程，同一个进程中的多个线程之间可以并发执行</p>
<span id="more"></span>
<p>线程栈：<br>1.方便函数调用，当调用子函数时，可以把当前函数的信息压入栈中，<br>再在栈的顶端压入返回地址，当子函数调用结束后再弹栈即可。<br>2.多任务支持，当有必要进行任务切换时，对当前信息存储，再读入<br>另一个任务的信息即可。</p>
]]></content>
      <categories>
        <category>面试题</category>
        <category>并发编程题目</category>
      </categories>
      <tags>
        <tag>进程，线程</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程基础</title>
    <url>/2021/11/27/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h1><p>1.进程要分配一大部分的内存，而线程只需要分配一部分栈就可以了.<br>2.一个程序至少有一个进程,一个进程至少有一个线程.<br>3.进程是资源分配的最小单位，线程是程序执行的最小单位。<br>4.一个线程可以创建和撤销另一个线程，同一个进程中的多个线程之间可以并发执行</p>
<span id="more"></span>    
<p>线程栈：<br>1.方便函数调用，当调用子函数时，可以把当前函数的信息压入栈中，<br>再在栈的顶端压入返回地址，当子函数调用结束后再弹栈即可。<br>2.多任务支持，当有必要进行任务切换时，对当前信息存储，再读入<br>另一个任务的信息即可。</p>
<h1 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h1><p>并发：单一cpu交替执行多任务，宏观表现同时进行的情况称为并发。<br>并行：多个cpu同时执行多个任务，宏观表现与微观均为同时进行。</p>
<h1 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h1><p>1.继承Thread类，重写run方法<br>2.实现Runnabel接口，重写run方法<br>实现Runnabel接口的启动：重写完run方法后，在主方法中创建对象，再把这个对象<br>交给Thread进行静态代理，再启动对应的thread。</p>
<h1 id="停止线程"><a href="#停止线程" class="headerlink" title="停止线程"></a>停止线程</h1><p>1.线程执行完毕自动停止<br>2.在run方法中使用一个变量控制线程，想要停止时改变run方法中的这个变量。</p>
<h1 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h1><p>1.setName<br>2.getName<br>3.start<br>4.run<br>5.setPriority<br>6.getPriority<br>7.sleep<br>8.interrupt//一般用于中断休眠<br>9.yield//尝试性礼让<br>10.join//插队</p>
<h1 id="释放锁的情况"><a href="#释放锁的情况" class="headerlink" title="释放锁的情况"></a>释放锁的情况</h1><p>1.线程结束 2.线程异常 3.线程中断 4.wait()<br>sleep，yield，suspend不会释放锁。</p>
]]></content>
      <categories>
        <category>多线程基础</category>
      </categories>
  </entry>
  <entry>
    <title>组合总和</title>
    <url>/2021/11/28/%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定一个数组candidates和一个目标数target，找出candidates中所有可以使数字和为target的组合。<br>candidates中的每个数字在每个组合中只能使用一次。<br>注意：解集不能包含重复的组合</p>
<span id="more"></span>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>本题难点在于如何去重，解决办法是将数组排序，在循环内添加判断，如果与上一个相同，跳过即可。这样处理可以去掉同层所有重复数字，但不同层的数字仍然可以重复。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; answer;</span><br><span class="line"></span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) &#123;</span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        int[] ints = new int[candidates.length + 1];</span><br><span class="line">        for (int i =0;i&lt;candidates.length;i++)&#123;</span><br><span class="line">            ints[i] = candidates[i];</span><br><span class="line">        &#125;</span><br><span class="line">        answer = new ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        tarckBack(ints, target, 0, 0, new ArrayList&lt;Integer&gt;());</span><br><span class="line">        return answer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void tarckBack(int[] candidates, int target, int start, int sum, ArrayList&lt;Integer&gt; list) &#123;</span><br><span class="line">        if (sum == target) &#123;</span><br><span class="line">            ArrayList&lt;Integer&gt; list1 = new ArrayList&lt;&gt;(list);</span><br><span class="line">            answer.add(list1);</span><br><span class="line">        &#125; else if (sum &lt; target) &#123;</span><br><span class="line">            for (int i = start; i &lt; candidates.length-1; i++) &#123;</span><br><span class="line">                //同层去重</span><br><span class="line">                if (i&gt;start&amp;&amp;candidates[i]==candidates[i-1])&#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                list.add(candidates[i]);</span><br><span class="line">                tarckBack(candidates, target, i+1, sum + candidates[i], list);</span><br><span class="line">                list.remove(list.size() - 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode解析</category>
        <category>中等</category>
      </categories>
      <tags>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式</title>
    <url>/2021/11/29/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="正则表达式语法"><a href="#正则表达式语法" class="headerlink" title="正则表达式语法"></a>正则表达式语法</h1><p>注意：要正确使用转义字符。java：\\，其他\。</p>
<span id="more"></span>
<h2 id="限定符"><a href="#限定符" class="headerlink" title="限定符"></a>限定符</h2><table>
<thead>
<tr>
<th>符号</th>
<th>解释</th>
<th>示例</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>*</td>
<td>克林闭包</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>+</td>
<td>正闭包</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>?</td>
<td>可重复0次或1次</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>{n}</td>
<td>只能输入n个字符</td>
<td>[abcd]{3}</td>
<td>abcd四字母组成的3长度字符串</td>
</tr>
<tr>
<td>{n,}</td>
<td>至少n个字符</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>{n,m}</td>
<td>至少n个，至多m个字符</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>?</td>
<td>非贪婪匹配</td>
<td>\\d+?</td>
<td>输出尽可能短的数字串，默认是输出尽可能长的</td>
</tr>
</tbody></table>
<h2 id="选择匹配符"><a href="#选择匹配符" class="headerlink" title="选择匹配符"></a>选择匹配符</h2><table>
<thead>
<tr>
<th>符号</th>
<th>解释</th>
<th>示例</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>|</td>
<td>匹配”|”之前或之后的内容</td>
<td>ab|cd</td>
<td>ab或cd</td>
</tr>
</tbody></table>
<h2 id="分组组合和反向引用符"><a href="#分组组合和反向引用符" class="headerlink" title="分组组合和反向引用符"></a>分组组合和反向引用符</h2><table>
<thead>
<tr>
<th>符号</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>(pattern)</td>
<td>非命名捕获分组，使用index查询</td>
</tr>
<tr>
<td>(?&lt;name&gt;pattern)</td>
<td>命名捕获分组，可以使用组名或index查询</td>
</tr>
<tr>
<td>(?:pattern)</td>
<td>匹配但不捕获分组index，无法靠index查找。作用：apple(?:|s)=(apple|apples)</td>
</tr>
<tr>
<td>(?=pattern)</td>
<td>匹配但不捕获分组信息。作用：win(?=7|8|9),会找到win后面是7，8，9的win，但不会匹配win10的win</td>
</tr>
<tr>
<td>(?!pattern)</td>
<td>该表达式与上一个式子作用相反。</td>
</tr>
</tbody></table>
<h2 id="字符匹配符"><a href="#字符匹配符" class="headerlink" title="字符匹配符"></a>字符匹配符</h2><table>
<thead>
<tr>
<th>符号</th>
<th>解释</th>
<th>示例</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>[]</td>
<td>可接收的字符列表</td>
<td>[efgh]</td>
<td>efgh中的任意一个字符</td>
</tr>
<tr>
<td>[^]</td>
<td>不接收的字符列表</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>-</td>
<td>连字符</td>
<td>A-Z</td>
<td>A—Z间的的所有字符</td>
</tr>
<tr>
<td>.</td>
<td>匹配除\n以外的任何字符</td>
<td>a..b</td>
<td>a开头，b结尾，4长度字符</td>
</tr>
<tr>
<td>\\d</td>
<td>匹配单个数字，相当[0-9]</td>
<td>\\d{3}(\\d)?</td>
<td>包含三个或四个数字的字符串</td>
</tr>
<tr>
<td>\\D</td>
<td>匹配单个非数字</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>\\w</td>
<td>匹配单个数字，字母</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>\\W</td>
<td>匹配单个非数字且非字母的字符</td>
<td>-</td>
<td>-</td>
</tr>
</tbody></table>
<h2 id="定位符"><a href="#定位符" class="headerlink" title="定位符"></a>定位符</h2><table>
<thead>
<tr>
<th>符号</th>
<th>解释</th>
<th>示例</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>^</td>
<td>指定起始符</td>
<td>^[0-9]+[a-z]*</td>
<td>以至少一个数字开头，后面任意长度字母的字符串</td>
</tr>
<tr>
<td>$</td>
<td>指定结束符</td>
<td>^[0-9]\-[a-z]+$</td>
<td>以数字开头接-并且至少一个字母结尾的字符串</td>
</tr>
<tr>
<td>\\b</td>
<td>匹配目标字符串的边界</td>
<td>han\\b</td>
<td>空格前或结尾的都为han</td>
</tr>
<tr>
<td>\\B</td>
<td>匹配目标字符串的非边界</td>
<td>han\\B</td>
<td>han出现在非边界的位置</td>
</tr>
</tbody></table>
<h2 id="反向引用"><a href="#反向引用" class="headerlink" title="反向引用"></a>反向引用</h2><p>使用括号捕获的内容可以在这个括号后被重复使用，从而写出比较实用的匹配模式。<br>内部反向引用：\\分组号。外部反向引用：$分组号。(用于外部函数中的调用)<br>例：(\\d)(\\d)\\2\\1,这个表达式可以匹配一个四字符长度的回文字符串。</p>
<h1 id="java中的正则表达式"><a href="#java中的正则表达式" class="headerlink" title="java中的正则表达式"></a>java中的正则表达式</h1><h2 id="正则表达式的使用"><a href="#正则表达式的使用" class="headerlink" title="正则表达式的使用"></a>正则表达式的使用</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//创建一个pattern对象</span><br><span class="line">new Pattern.complie(&quot;正则表达式&quot;);</span><br><span class="line">//创建一个匹配对象</span><br><span class="line">new pattern.matcher(文本);</span><br><span class="line">//开始循环匹配,find返回找到的内容</span><br><span class="line">while(matcher.find())&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<!-- more -->
<h2 id="matcher-group"><a href="#matcher-group" class="headerlink" title="matcher.group()"></a>matcher.group()</h2><p>group(0)中存放找到的所有内容的index。<br>group(n)中存放第n个()中的内容的index。</p>
<h2 id="常用类"><a href="#常用类" class="headerlink" title="常用类"></a>常用类</h2><table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>Pattern.matches(正则表达式,匹配内容)</td>
<td>返回一个布尔值表示是否整体匹配</td>
</tr>
<tr>
<td>matcher.start()</td>
<td>返回匹配字符串的首字符index</td>
</tr>
<tr>
<td>matcher.end()</td>
<td>返回匹配字符串末尾字符index+1</td>
</tr>
<tr>
<td>matcher.matches</td>
<td>返回一个布尔值表示是否整体匹配</td>
</tr>
<tr>
<td>matcher.replaceAll(替换内容)</td>
<td>将匹配的字符串替换为输入的替换内容。注意：原本的文本内容不会发生变换，只是返回一个被替换的字符串</td>
</tr>
<tr>
<td>matcher.replaceAll(被替换内容,替换内容)</td>
<td>将匹配到的内容的被替换内容替换为替换内容</td>
</tr>
</tbody></table>
<h2 id="String类中的正则表达式"><a href="#String类中的正则表达式" class="headerlink" title="String类中的正则表达式"></a>String类中的正则表达式</h2><p>String类有部分方法是支持正则表达式的。<br>str.matches(正则表达式) 判断是否完全匹配<br>str.split(正则表达式)依据正则表达进行分割<br>str.replaceAll(正则表达式,替换内容)将与正则表达匹配的内容替换为替换内容</p>
]]></content>
      <categories>
        <category>正则表达式</category>
      </categories>
  </entry>
  <entry>
    <title>第k个最小的素数分数</title>
    <url>/2021/11/30/%E7%AC%ACk%E4%B8%AA%E6%9C%80%E5%B0%8F%E7%9A%84%E7%B4%A0%E6%95%B0%E5%88%86%E6%95%B0/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给你一个按递增顺序排序的数组arr和一个整数k。数组arr由1和若干素数组成，且其中所有整数互不相同。<br>对于每对满足0&lt; i &lt; j &lt; arr.length 的 i 和 j ，可以得到分数 arr[i] / arr[j] 。</p>
<span id="more"></span>
<h1 id="堆排序分析"><a href="#堆排序分析" class="headerlink" title="堆排序分析"></a>堆排序分析</h1><p>这道题是对java中堆排序的练习。为了提高运算速度，需要对堆的入堆进行筛选。因为只需要取得第k个小的分数，构建一个大根堆，存放最小的7个分数，当堆大于7时，加入的分数如果大于堆顶，则没必要加入，如果小于堆顶，则弹出堆顶再加入当前分数。全部入堆结束后堆顶就是答案。</p>
<h1 id="堆排序代码"><a href="#堆排序代码" class="headerlink" title="堆排序代码"></a>堆排序代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int[] kthSmallestPrimeFraction(int[] arr, int k) &#123;</span><br><span class="line">        //把所有分数串连起来</span><br><span class="line">        ArrayList list = new ArrayList();</span><br><span class="line">        for (int i = 0;i&lt; arr.length-1;i++)&#123;</span><br><span class="line">            for (int j = 0;j&lt;i+1;j++)&#123;</span><br><span class="line">                int[] ints = &#123;arr[j],arr[i+1]&#125;;</span><br><span class="line">                list.add(ints);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //创建堆</span><br><span class="line">        Queue heap= new PriorityQueue(new Comparator() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public int compare(Object o1, Object o2) &#123;</span><br><span class="line">                int[] int1 = (int[]) o1;</span><br><span class="line">                int[] int2 = (int[]) o2;</span><br><span class="line">                return int2[0]*int1[1]-int1[0]*int2[1];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        //把这些元素放入堆中</span><br><span class="line">        for (Object o:list)&#123;</span><br><span class="line">            int[] int1 = (int[]) heap.peek();</span><br><span class="line">            int[] int2 = (int[]) o;</span><br><span class="line">            if (heap.size()&gt;=k&amp;&amp;int1[0]*int2[1]&gt;int1[1]*int2[0])&#123;</span><br><span class="line">                heap.poll();</span><br><span class="line">                heap.offer(o);</span><br><span class="line">            &#125;else if (heap.size()&lt;k)&#123;</span><br><span class="line">                heap.offer(o);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return (int[]) heap.poll();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h1 id="归并排序分析"><a href="#归并排序分析" class="headerlink" title="归并排序分析"></a>归并排序分析</h1><p>因为1/n&lt;2/n&lt;…这道题其实可以看作length-1条有序数组的排序。所以可以使用归并来处理，使用一个小根堆管理所有数组的第一个数字，此时这个堆中包含所有数组的最小数，所以当弹出时必定为整体的最小数。我们要做的就是弹出k个堆顶，每次弹出时加入数组的后一个数字。</p>
<h1 id="归并排序代码"><a href="#归并排序代码" class="headerlink" title="归并排序代码"></a>归并排序代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int[] kthSmallestPrimeFraction(int[] arr, int k) &#123;</span><br><span class="line">        int n = arr.length;</span><br><span class="line">        //制定小根堆的规则</span><br><span class="line">        PriorityQueue&lt;int[]&gt; q = new PriorityQueue&lt;&gt;((a,b)-&gt;&#123;</span><br><span class="line">            double i1 = arr[a[0]] * 1.0 / arr[a[1]], i2 = arr[b[0]] * 1.0 / arr[b[1]];</span><br><span class="line">            return Double.compare(i1, i2);</span><br><span class="line">        &#125;);</span><br><span class="line">        //加入所有数组的第一个数</span><br><span class="line">        for (int i = 1; i &lt; n; i++) q.add(new int[]&#123;0, i&#125;);</span><br><span class="line">        while (k-- &gt; 1) &#123;</span><br><span class="line">            //弹出堆顶，加入这个数的下一个数</span><br><span class="line">            int[] poll = q.poll();</span><br><span class="line">            int i = poll[0], j = poll[1];</span><br><span class="line">            if (i + 1 &lt; j) q.add(new int[]&#123;i + 1, j&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        int[] poll = q.poll();</span><br><span class="line">        return new int[]&#123;arr[poll[0]], arr[poll[1]]&#125;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode解析</category>
        <category>困难</category>
      </categories>
      <tags>
        <tag>堆</tag>
        <tag>归并</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title>javaweb</title>
    <url>/2021/11/28/javaweb/</url>
    <content><![CDATA[<h1 id="html和css"><a href="#html和css" class="headerlink" title="html和css"></a>html和css</h1><span id="more"></span>
<h2 id="html常用标签"><a href="#html常用标签" class="headerlink" title="html常用标签"></a>html常用标签</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;br/&gt;换行</span><br><span class="line">&lt;hr/&gt;水平线</span><br><span class="line">&lt;front&gt;&lt;/front&gt;修改文本大小，颜色，样式(color,face,size)</span><br><span class="line">&lt;h1-6&gt;1-6标题(align=对齐方式)</span><br><span class="line">&lt;a&gt;&lt;/a&gt;超链接(href=域名,target=选择发生跳转的页面)</span><br><span class="line">&lt;ul&gt;&lt;/ul&gt;无序列表</span><br><span class="line">&lt;li&gt;&lt;/li&gt;列表项</span><br><span class="line">&lt;img/&gt;图片(src=路径,width=宽,height=高,border=边框宽度,alt=图片消失时提示)</span><br><span class="line">&lt;ifanme&gt;&lt;/ifanme&gt;子页面(src=子页面文件路径,width,height,name用于超链接选择target)</span><br><span class="line">文本</span><br><span class="line">&lt;div&gt;&lt;/div&gt;默认独占一行</span><br><span class="line">&lt;span&gt;&lt;/span&gt;长度为封装数据的长度</span><br><span class="line">&lt;p&gt;&lt;/p&gt;上下各占一行</span><br><span class="line">表格</span><br><span class="line">&lt;table&gt;&lt;/table&gt;表格(align,border,width,height,cellspacing=单元格间距)</span><br><span class="line">&lt;tr&gt;&lt;/tr&gt;表格行</span><br><span class="line">&lt;th&gt;&lt;/th&gt;居中加粗的单元格</span><br><span class="line">&lt;td&gt;&lt;/td&gt;单元格(align,colspan=行占用单元格数量,rowspan=列占用单元格数量)</span><br><span class="line">&lt;b&gt;&lt;/b&gt;加粗</span><br><span class="line">表单</span><br><span class="line">&lt;from&gt;&lt;/form&gt;表单(action=提交的服务器地址,method=get/post提交方式)</span><br><span class="line">&lt;input/&gt;输入栏(type=输入类型,value=默认值)</span><br><span class="line">&lt;input/&gt;单选框(type=&quot;radio&quot;,name=分组)</span><br><span class="line">&lt;select&gt;&lt;/select&gt;下拉列框</span><br><span class="line">&lt;option&gt;&lt;/option&gt;选项</span><br><span class="line">&lt;textarea&gt;&lt;/textarea&gt;多行文本输入框(row,cols= 每行字数)</span><br><span class="line">&lt;input type=&quot;reset&quot; value=&quot;重置&quot;/&gt;</span><br><span class="line">&lt;input type=&quot;sbmit&quot; value=&quot;提交&quot;/&gt;</span><br><span class="line">表单提交时，数据没发给服务器的三种情况：</span><br><span class="line">1.没有使用name命名</span><br><span class="line">2.单选、复选、下拉列表的选项都需要添加value属性</span><br><span class="line">3.表单项不在form中</span><br></pre></td></tr></table></figure>
<h2 id="常用字符实体"><a href="#常用字符实体" class="headerlink" title="常用字符实体"></a>常用字符实体</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">空格：&amp;nbsp;</span><br><span class="line">小于号：&amp;lt;</span><br><span class="line">大于号：&amp;gt;</span><br><span class="line">双引号：&amp;quot;</span><br><span class="line">单引号：&amp;apos;</span><br></pre></td></tr></table></figure>
<h2 id="css和html的结合"><a href="#css和html的结合" class="headerlink" title="css和html的结合"></a>css和html的结合</h2><p>1.在标签的style属性上设置”key:value value”,修改标签样式<br>2.在head标签中使用style标签定义，style标签中使用css语法。<br>3.把css样式写为一个文件，通过link标签引入。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;文件路径&quot;/&gt;</span><br></pre></td></tr></table></figure>
<h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><p>1.标签选择器: 标签名{}<br>2.id选择器： #id{}<br>3.class选择器： 标签名.class{}<br>4.组合选择器<br>class选择器与id选择器的区别：id选择器的值是唯一的，class选择器可以多标签公用。</p>
<h1 id="js"><a href="#js" class="headerlink" title="js"></a>js</h1><h2 id="js和html代码的结合"><a href="#js和html代码的结合" class="headerlink" title="js和html代码的结合"></a>js和html代码的结合</h2><p>1.在head或者body标签中使用script标签写js代码<br>2.使用script标签引入js文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;path&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="与java语法不同部分"><a href="#与java语法不同部分" class="headerlink" title="与java语法不同部分"></a>与java语法不同部分</h2><p>赋值使用var对任意类型赋值。<br>==与===，前者只比较字面值，后者比较数值与类型。<br>逻辑运算与c相同，所有数值可做布尔类型变量。0，null，undefined，””为false。<br>&amp;&amp;运算，当表达式全为真时返回最后一个表达式的值，有假时返回第一个为假的表达式值。<br>||运算，当表达式全为假时返回最后一个表达式的值，有真时返回第一个为真的表达式值。<br>数组中可以放类型不同的数据，且长度可变。 var arr = [];<br>函数定义：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function 函数名(形参)&#123;&#125;</span><br><span class="line">var 函数名 = function(形参)&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>函数不允许重载，只会覆盖。<br>所有js函数都有隐藏参数arguments，等于java的Object…，所有参数都在他的数组中。<br>对象的定义方法与c语言结构体类似，不同的是可以在其中定义函数。</p>
<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p>事件分为静态注册与动态注册。<br>onload 加载完成事件(body)<br>onclick 单机事件(button)<br>onblur 失去焦点事件(input)<br>onchange 内容改变事件(select,input)<br>onsubmit 提交事件(form)(通过返回false阻止提交事件)</p>
<h2 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h2><p>document文件通过树结构管理所有html中的对象(所有标签对象化)<br>document结构及方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var document&#123;</span><br><span class="line">	var id = ;</span><br><span class="line">	var tagName= ;</span><br><span class="line">	var parentNode= ;</span><br><span class="line">	var children= ;</span><br><span class="line">	var value= ;</span><br><span class="line">	var tpye= ;</span><br><span class="line">	var innerHTML= ;(起始标签到终止标签的中间内容)</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line">document.getElementById()</span><br><span class="line">//下面的两种返回的是集合，操作与数组相同</span><br><span class="line">document.getElementsByName()</span><br><span class="line">document.getElementsByTagName(标签名)</span><br><span class="line">document.createElement(标签名)</span><br></pre></td></tr></table></figure>
<p>因为语句是从上往下执行，非函数内取得dom对象时可能对象还未创建，要想在外部取得，一般置于window.onload = function(){}中。</p>
<h2 id="正则表达式对文本的验证"><a href="#正则表达式对文本的验证" class="headerlink" title="正则表达式对文本的验证"></a>正则表达式对文本的验证</h2><p><a href="https://390991450.github.io/2021/11/29/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/#more">正则表达的规则</a><br>正则表达式判断用户名是否合法案例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;html lang=&quot;zh_CN&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;标题&lt;/title&gt;</span><br><span class="line">    &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">        function onclickFun()&#123;</span><br><span class="line">            var usernameObj = document.getElementById(&quot;username&quot;);</span><br><span class="line">            var userText = usernameObj.value;</span><br><span class="line">            var patt = /^\w&#123;5,12&#125;$/;</span><br><span class="line">            var spanObj = document.getElementById(&quot;tips&quot;);</span><br><span class="line">            if (patt.test(userText))&#123;</span><br><span class="line">                spanObj.innerHTML = &quot;输入正确&quot;</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                spanObj.innerHTML = &quot;请输入正确的用户名&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    用户名：&lt;input type=&quot;text&quot; id=&quot;username&quot;/&gt;</span><br><span class="line">&lt;!--这个属于静态注册--&gt;</span><br><span class="line">    &lt;span id=&quot;tips&quot; style=&quot;color: red;&quot;&gt;&lt;/span&gt;</span><br><span class="line">&lt;!--    这个属于动态注册--&gt;</span><br><span class="line">    &lt;button onclick=&quot;onclickFun()&quot;&gt;校验&lt;/button&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<h2 id="节点的常用方法或属性"><a href="#节点的常用方法或属性" class="headerlink" title="节点的常用方法或属性"></a>节点的常用方法或属性</h2><table>
<thead>
<tr>
<th>方法或属性</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>getElementsByTagName()</td>
<td>获取当前节点指定标签类型的子节点</td>
</tr>
<tr>
<td>appendChild(字节点)</td>
<td>添加一个字节点</td>
</tr>
<tr>
<td>childNodes</td>
<td>获取当前节点的所有子节点</td>
</tr>
<tr>
<td>firstChild</td>
<td>取得第一个字节点</td>
</tr>
<tr>
<td>lastChile</td>
<td>取得最后一个子节点</td>
</tr>
<tr>
<td>parentNode</td>
<td>取得当前父节点</td>
</tr>
<tr>
<td>nextSibling</td>
<td>取得下一个节点</td>
</tr>
<tr>
<td>previousSibling</td>
<td>取得上一个节点</td>
</tr>
<tr>
<td>className</td>
<td>获取或设置标签的class属性</td>
</tr>
<tr>
<td>innerHTML</td>
<td>获取或设置起始标签到结束标签的内容(可以有其他标签)</td>
</tr>
<tr>
<td>innerText</td>
<td>获取或设置起始标签到结束标签的文本</td>
</tr>
</tbody></table>
<h1 id="“jQuery”"><a href="#“jQuery”" class="headerlink" title="“jQuery”"></a>“jQuery”</h1><p>jQuery是一个框架，对js进行了封装，方便使用。</p>
<h2 id="核心函数"><a href="#核心函数" class="headerlink" title="核心函数"></a>核心函数</h2><p>1.传入参数为函数时：表示页面加载完成之后。相当于window.onload = function(){}<br>2.传入参数为HTML字符串时：会帮我们创建这些HTML标签插入到指定位置。$().appendto(标签);<br>3.传入参数为选择器字符串时：根据选择器样式用对应方法查询dom对象。(也可以填入组合选择器”,”表示或”.”表示且。结果顺序为页面中的顺序)<br>4.传入参数为dom时：会把这个对象转化为”jQuery”对象</p>
<h2 id="“jQuery”对象及方法"><a href="#“jQuery”对象及方法" class="headerlink" title="“jQuery”对象及方法"></a>“jQuery”对象及方法</h2><p>“jQuery”对象本质是dom对象的数组，同时封装了一系列函数。所有dom对象经由”jQuery”获得时都会被封装为”jQuery”对象，取得时使用index取得。<br>使用”jQuery”对象注册事件时不再需要使用动态或静态注册，而是通过调用”jQuery”所带的事件方法实现对象注册。</p>
<h3 id="属性获取"><a href="#属性获取" class="headerlink" title="属性获取"></a>属性获取</h3><table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>$(function(){})</td>
<td>页面加载完成事件</td>
</tr>
<tr>
<td>.val()</td>
<td>获取，修改“表单项”的value</td>
</tr>
<tr>
<td>.val([“value”])</td>
<td>指定表单项被选中的项(单复选框，下拉列表)</td>
</tr>
<tr>
<td>.html()</td>
<td>设置和获取所有dom的innerHTML</td>
</tr>
<tr>
<td>.text()</td>
<td>设置和获取所有dom的text</td>
</tr>
<tr>
<td>.attr()</td>
<td>设置和获取指定属性值(一个参数为获取，两个参数为设置，可以设置未定义属性)</td>
</tr>
<tr>
<td>.prop()</td>
<td>设置和获取指定属性值(可处理checked等会出现undefined情况的属性)</td>
</tr>
<tr>
<td>.each()</td>
<td>遍历dom对象,用this取得</td>
</tr>
</tbody></table>
<h3 id="增删改"><a href="#增删改" class="headerlink" title="增删改"></a>增删改</h3><table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>a.appendTo(b)</td>
<td>把a插入到b的子元素，成为最后一个子元素</td>
</tr>
<tr>
<td>a.prependTo(b)</td>
<td>把a插入到b的子元素，成为第一个子元素</td>
</tr>
<tr>
<td>a.insertAfter(b)</td>
<td>-</td>
</tr>
<tr>
<td>a.insertBefore</td>
<td>-</td>
</tr>
<tr>
<td>a.replaceWith(b)</td>
<td>用b替换a</td>
</tr>
<tr>
<td>a.replaceAll(b)</td>
<td>用a替换b</td>
</tr>
<tr>
<td>a.remove()</td>
<td>删除a</td>
</tr>
<tr>
<td>a.empty()</td>
<td>清空a内容</td>
</tr>
</tbody></table>
<h3 id="css样式"><a href="#css样式" class="headerlink" title="css样式"></a>css样式</h3><table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>.css(“key”,”value”…)</td>
<td>为当前”jQuery”中对象设置样式</td>
</tr>
<tr>
<td>.addClass()</td>
<td>添加样式</td>
</tr>
<tr>
<td>.removeClass()</td>
<td>移除样式</td>
</tr>
<tr>
<td>.toggleClass()</td>
<td>有就删除，没有就添加样式</td>
</tr>
<tr>
<td>.offset()</td>
<td>返回坐标(左上角作为坐标)</td>
</tr>
</tbody></table>
<h3 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h3><p>第一个参数为时间，第二个为回调函数(动画结束后调用的函数)。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>.show()</td>
<td>将隐藏显示</td>
</tr>
<tr>
<td>.hide()</td>
<td>-</td>
</tr>
<tr>
<td>.toggle()</td>
<td>-</td>
</tr>
<tr>
<td>.fadeIn()</td>
<td>淡入</td>
</tr>
<tr>
<td>.fadeOut()</td>
<td>-</td>
</tr>
<tr>
<td>.fadeTo()</td>
<td>指定时间内到指定透明度</td>
</tr>
</tbody></table>
<h3 id="事件-1"><a href="#事件-1" class="headerlink" title="事件"></a>事件</h3><table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>.click(function(){})</td>
<td>有函数为绑定单击事件，无函数为触发事件</td>
</tr>
<tr>
<td>.blur(function(){})</td>
<td>失去焦点事件</td>
</tr>
<tr>
<td>.load(function(){})</td>
<td>加载事件</td>
</tr>
<tr>
<td>.change(function(){})</td>
<td>内容改变事件</td>
</tr>
<tr>
<td>.submit(function(){})</td>
<td>提交事件</td>
</tr>
<tr>
<td>.mouseover(function(){})</td>
<td>鼠标移入事件</td>
</tr>
<tr>
<td>.mouseout(function(){})</td>
<td>鼠标移出事件</td>
</tr>
<tr>
<td>.bind(‘一个或多个事件’,function(){})</td>
<td>绑定事件，多个时用空格隔开</td>
</tr>
<tr>
<td>.one()</td>
<td>与bind使用方法相同，但每个事件只能响应一次</td>
</tr>
<tr>
<td>.unbind()</td>
<td>与bind相反，解除事件绑定</td>
</tr>
<tr>
<td>.live()</td>
<td>用于绑定事件，特点是即使这个元素是后面发生修改或才动态创建出来的也能绑定</td>
</tr>
</tbody></table>
<p>事件的冒泡<br>当子元素与父元素同时绑定一个事件时，当子元素触发事件时，会导致父元素也触发事件。<br>在子元素事件函数体内添加return false就可以防止事件的传递。<br>事件对象<br>每次事件触发时会生成一个保存信息的对象，通过在function()括号中写入变量名获取。</p>
<h3 id="选择器-1"><a href="#选择器-1" class="headerlink" title="选择器"></a>选择器</h3><table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>层级选择器</td>
<td></td>
</tr>
<tr>
<td>$(“基本选择器1 基本选择器2”)</td>
<td>获取所有在标签1中的所有标签2</td>
</tr>
<tr>
<td>$(“基本选择器1 基本选择器2”)</td>
<td>获取父标签是标签1的所有标签2</td>
</tr>
<tr>
<td>$(“基本选择器1 + 基本选择器2”)</td>
<td>获取上一个兄弟标签是标签1的所有标签2</td>
</tr>
<tr>
<td>$(“基本选择器1 ~ 基本选择器2”)</td>
<td>获取标签1后的所有同级的标签2</td>
</tr>
<tr>
<td>基本过滤选择器</td>
<td></td>
</tr>
<tr>
<td>$(“基本选择器1:first”)</td>
<td>获取第一个标签1</td>
</tr>
<tr>
<td>$(“基本选择器1:last”)</td>
<td>获取最后一个标签1</td>
</tr>
<tr>
<td>$(“基本选择器1:even”)</td>
<td>获取所有index为偶数的标签1</td>
</tr>
<tr>
<td>$(“基本选择器1:odd”)</td>
<td>-</td>
</tr>
<tr>
<td>$(“基本选择器1:eq(index)”)</td>
<td>-</td>
</tr>
<tr>
<td>$(“基本选择器1:gt(index)”)</td>
<td>获取所有index大于这个index的标签1</td>
</tr>
<tr>
<td>$(“基本选择器1:lt(index)”)</td>
<td>获取所有index小于这个index的标签1</td>
</tr>
<tr>
<td>$(“:header”)</td>
<td>获取所有标题元素</td>
</tr>
<tr>
<td>$(“:animated”)</td>
<td>获取所有在执行动画的标签</td>
</tr>
<tr>
<td>$(“基本选择器1:not(…)”)</td>
<td>相当于上面操作的取反</td>
</tr>
<tr>
<td>内容过滤选择器</td>
<td></td>
</tr>
<tr>
<td>$(“基本选择器:contains(‘str’)”)</td>
<td>获取文本内容包含str的标签</td>
</tr>
<tr>
<td>$(“基本选择器:empty”)</td>
<td>获取文本内容为空的标签</td>
</tr>
<tr>
<td>$(“基本选择器:parent”)</td>
<td>获取文本内容不为空或者有子元素的标签</td>
</tr>
<tr>
<td>$(“基本选择器1:has(选择器2)”)</td>
<td>获取子元素有标签2的所有标签1</td>
</tr>
<tr>
<td>属性过滤选择器</td>
<td></td>
</tr>
<tr>
<td>$(“基本选择器[属性名]”)</td>
<td>获取包含这个属性的标签</td>
</tr>
<tr>
<td>$(“基本选择器[属性名=’value’]”)</td>
<td>-</td>
</tr>
<tr>
<td>$(“基本选择器[属性名!=’value’]”)</td>
<td>获取不含有这属性和有这个属性但值不匹配的标签</td>
</tr>
<tr>
<td>$(“基本选择器[属性名^=’value’]”)</td>
<td>获取有这个属性，且属性值以此开始的标签</td>
</tr>
<tr>
<td>$(“基本选择器[属性名*=’value’]”)</td>
<td>获取有这个属性，且包含属性值的标签</td>
</tr>
<tr>
<td>$(“基本选择器[][]…”)</td>
<td>多重选择</td>
</tr>
<tr>
<td>表单过滤选择器</td>
<td></td>
</tr>
<tr>
<td>$(“:type类型”)</td>
<td>选择type类型符合的标签</td>
</tr>
<tr>
<td>$(“:enabled”)</td>
<td>选择可用的标签</td>
</tr>
<tr>
<td>$(“:disabled”)</td>
<td>选择不可用的标签</td>
</tr>
<tr>
<td>$(“:checked”)</td>
<td>选择所有选择的标签(单选复选框)</td>
</tr>
<tr>
<td>$(“:selected”)</td>
<td>匹配所有选择的option元素</td>
</tr>
<tr>
<td>元素筛选</td>
<td></td>
</tr>
<tr>
<td>.eq()</td>
<td>-</td>
</tr>
<tr>
<td>.first()</td>
<td>-</td>
</tr>
<tr>
<td>.last()</td>
<td>-</td>
</tr>
<tr>
<td>.filter(exp)</td>
<td>再次过滤</td>
</tr>
<tr>
<td>.is(exp)</td>
<td>判断是否满足这个选择器,一个为真即为真</td>
</tr>
<tr>
<td>.has(exp)</td>
<td>返回子元素满足选择器的元素</td>
</tr>
<tr>
<td>.not(exp)</td>
<td>删除满足选择器的元素</td>
</tr>
<tr>
<td>.children(exp)</td>
<td>返回此元素中满足此选择器的子元素</td>
</tr>
<tr>
<td>.find(exp)</td>
<td>返回此元素中满足此选择器的后代元素</td>
</tr>
<tr>
<td>.next()</td>
<td>-</td>
</tr>
<tr>
<td>.nextAll()</td>
<td>-</td>
</tr>
<tr>
<td>.nextUntil()</td>
<td>-</td>
</tr>
<tr>
<td>.parent()</td>
<td>-</td>
</tr>
<tr>
<td>.prev(exp)</td>
<td>-</td>
</tr>
<tr>
<td>.prevAll()</td>
<td>-</td>
</tr>
<tr>
<td>.prevUntil()</td>
<td>-</td>
</tr>
<tr>
<td>.siblings(exp)</td>
<td>-</td>
</tr>
<tr>
<td>.add(exp)</td>
<td>向当前”jQuery”加入满足选择器的元素</td>
</tr>
</tbody></table>
<h1 id="xml"><a href="#xml" class="headerlink" title="xml"></a>xml</h1><h2 id="dom4j解析技术"><a href="#dom4j解析技术" class="headerlink" title="dom4j解析技术"></a>dom4j解析技术</h2><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">new SAXReader();</span><br><span class="line">Document document = saxReader.read(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"><span class="regexp">//</span>取得根元素</span><br><span class="line">Element rootelement = document.getRootElement();</span><br><span class="line"><span class="regexp">//</span>取得标签对象</span><br><span class="line">List&lt;Element&gt;books = rootElement.elements(<span class="string">&quot;标签名&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(Element book:books)&#123;</span><br><span class="line">    <span class="regexp">//</span>asXML()方法可以把标签对象转化为标签字符串</span><br><span class="line">    <span class="regexp">//</span>依然可以通过element和elements方法取得子元素</span><br><span class="line">    <span class="regexp">//g</span>etText()用于获取标签中的文本内容</span><br><span class="line">    <span class="regexp">//</span>elementText(标签名)用于获取指定子标签的文本内容</span><br><span class="line">    <span class="regexp">//</span>attributeValue(属性名)用于获取指定属性的值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="servlet"><a href="#servlet" class="headerlink" title="servlet"></a>servlet</h1><h2 id="servlet程序的创建"><a href="#servlet程序的创建" class="headerlink" title="servlet程序的创建"></a>servlet程序的创建</h2><p>一般是直接继承其子类HttpSerlet，对doGet与doPost方法进行重写。也可以直接实现servlet接口，实现其中的方法。<br>servlet程序创建完成后，要在web.xml中配置对应的servlet标签以及在servlet-mapping标签配置资源路径。<br>还可以使用idea直接创建servlet程序。这种创建方式会自动在web.xml中配置servlet标签，但仍需要手动配置servlet-mapping标签。<br>除此之外，还可以在servlet标签中自行使用init-param标签，设置初始化参数。</p>
<h2 id="servlet程序的访问过程"><a href="#servlet程序的访问过程" class="headerlink" title="servlet程序的访问过程"></a>servlet程序的访问过程</h2><p>ip-&gt;端口-&gt;具体工程-&gt;通过web.xml文件查询资源路径<br>查询servlet-mapping标签找到资源路径对应的程序名称，再通过servlet标签定位对应类的具体位置。</p>
<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>构造器与初始化在第一次访问时会调用，服务方法会在每次访问时调用，销毁方法在工程停止时调用。</p>
<h2 id="form-get与form-post"><a href="#form-get与form-post" class="headerlink" title="form:get与form:post"></a>form:get与form:post</h2><p>这两种请求分发处理，需要通过HttpServletRequest的get.method方法获取。<br>区别：<br>get请求会把数据追加到url中发送，适合小数据量，不需要安全性的数据提交。<br>post与get相反。且post请求会发送两个包，当第一个请求发送包被回复了才发送第二个数据包。</p>
<h2 id="ServletCofig"><a href="#ServletCofig" class="headerlink" title="ServletCofig"></a>ServletCofig</h2><p>servlet与servletconfig都是由tomcat创建。servlet是第一次访问时创建，servletconfig是每个servlet创建时创建。<br>调用：可以在初始化函数中直接调用，也可以通过getServletConfig()方法获取。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>getServletName()</td>
<td>获取当前Servlet程序别名</td>
</tr>
<tr>
<td>getInitParameter(“参数名”)</td>
<td>取得需要的初始化参数</td>
</tr>
<tr>
<td>getServletContext()</td>
<td>取得ServletContext对象(整个工程的域对象)</td>
</tr>
</tbody></table>
<p>注意：当在HttpSerlet中重写init方法时要使用super.init(config)调用父类的init方法，因为getServletConfig()方法需要从HttpSerlet的父类GenericServlet中取得config对象，而这个config对象是由init方法保存的，如果只重写子类而不执行父类的这个方法，这个config对象就无法被保存。</p>
<h2 id="ServletContext"><a href="#ServletContext" class="headerlink" title="ServletContext"></a>ServletContext</h2><p>一个工程只有一个ServletContext。<br>上下文参数由web.xml中的context-param标签设置。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>getInitParameter(“参数名”)</td>
<td>取得需要的上下文参数</td>
</tr>
<tr>
<td>getContextPath()</td>
<td>取得当前工程路径</td>
</tr>
<tr>
<td>getRealPath(“/“)</td>
<td>取得真实路径</td>
</tr>
<tr>
<td>setAttribute(key,value)</td>
<td>这三个方法用于域内的传递数据</td>
</tr>
<tr>
<td>getAttribute(key)</td>
<td></td>
</tr>
<tr>
<td>removeAttribute(key)</td>
<td></td>
</tr>
</tbody></table>
<h2 id="HttpServletRequest"><a href="#HttpServletRequest" class="headerlink" title="HttpServletRequest"></a>HttpServletRequest</h2><p>表示请求信息，每次只要有请求进入tomcat，tomcat就会把请求封装到Request对象中，交给service(doGet或doPost)方法。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>getRequestURI()</td>
<td>获取统一资源标志符(资源路径)</td>
</tr>
<tr>
<td>getRequestURL()</td>
<td>获取统一资源定位符(绝对路径)，URL是URI的子集</td>
</tr>
<tr>
<td>getRemoteHost()</td>
<td>获取客户端ip</td>
</tr>
<tr>
<td>getHeader()</td>
<td>获取请求头</td>
</tr>
<tr>
<td>getParameter()</td>
<td>获取请求参数(括号中写参数的name)</td>
</tr>
<tr>
<td>getParameterValue()</td>
<td>获取请求参数(用于多选数据，多个值时使用)</td>
</tr>
<tr>
<td>getMethod()</td>
<td>获取请求方式</td>
</tr>
<tr>
<td>setAttribute()</td>
<td>设置域数据</td>
</tr>
<tr>
<td>getAttribute(key)</td>
<td></td>
</tr>
<tr>
<td>setCharacterEncoding()</td>
<td>设置编码方式(一般用于post接收汉语)</td>
</tr>
<tr>
<td>getRequestDispatcher(“资源路径”).forward</td>
<td>获取请求转发对象</td>
</tr>
</tbody></table>
<p>上面获取转发对象后，通过requestDispatcher.forward(request,response)方法传递。<br>通过转发可以把request交给web-inf内的文件(正常情况不允许访问)处理。<br>注意：当使用请求转发跳转到指定页面时，它的网址并不是资源路径。所以使用相对路径跳转时会发生错误，一般会在head标签中添加base标签，规定作为相对路径所参照的地址。</p>
<h2 id="HttpServletResponse"><a href="#HttpServletResponse" class="headerlink" title="HttpServletResponse"></a>HttpServletResponse</h2><p>表示响应信息，每次只要有请求进入tomcat，tomcat就会把请求封装到Response对象中，交给service(doGet或doPost)方法。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>getOutputStream()</td>
<td>取得字节流(常用于下载)</td>
</tr>
<tr>
<td>getWrite()</td>
<td>取得字符流(常用于回传字符串)</td>
</tr>
<tr>
<td>wirter.write(“str”)</td>
<td>回传字符串数据</td>
</tr>
<tr>
<td>setContentType(“text/html; charset=UTF-8”)</td>
<td>设置服务器和客户端都使用UTF-8字符集，还设置的响应头</td>
</tr>
</tbody></table>
<p>这两个流不能同时取得。<br>请求重定向：是指客户端给服务器发送请求，然后服务器返回客户端一个新地址让客户端访问。(无法跳入web-inf内，可以跳到当前工程外的网站)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//设置响应状态码302</span><br><span class="line">resp.setStatus(302);</span><br><span class="line">//设置响应头说明新地址</span><br><span class="line">resp.seyHeader(&quot;Location&quot;,&quot;新地址&quot;);</span><br><span class="line">//第二种方法(推荐)</span><br><span class="line">resp.sendRedirect(&quot;新地址&quot;);</span><br></pre></td></tr></table></figure>
<h1 id="jsp"><a href="#jsp" class="headerlink" title="jsp"></a>jsp</h1><p>主要作用是代替Servlet传回html页面的数据，jsp页面本质是servlet程序。</p>
<h2 id="page指令的属性"><a href="#page指令的属性" class="headerlink" title="page指令的属性"></a>page指令的属性</h2><table>
<thead>
<tr>
<th>属性名</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>language</td>
<td>表示翻译后是什么语言文件</td>
</tr>
<tr>
<td>contentType</td>
<td>表示jsp返回数据的编码类型</td>
</tr>
<tr>
<td>pageEncoding</td>
<td>表示页面字符集编码类型</td>
</tr>
<tr>
<td>import</td>
<td>导包</td>
</tr>
<tr>
<td>autoFlush</td>
<td>设置当out输出流缓冲区满了后是否自动刷新，默认是true</td>
</tr>
<tr>
<td>buffer</td>
<td>设置out缓冲区大小，默认8kb</td>
</tr>
<tr>
<td>errorPage</td>
<td>设置当jsp页面运行出错时，自动跳转的页面</td>
</tr>
<tr>
<td>isError</td>
<td>设置当前jsp页面是否是错误信息页面,默认是false,如果是true可以获取异常信息</td>
</tr>
<tr>
<td>extends</td>
<td>设置jsp翻译出的java程序继承哪些类</td>
</tr>
</tbody></table>
<h2 id="jsp脚本"><a href="#jsp脚本" class="headerlink" title="jsp脚本"></a>jsp脚本</h2><h3 id="声明脚本-极少使用"><a href="#声明脚本-极少使用" class="headerlink" title="声明脚本(极少使用):"></a>声明脚本(极少使用):</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;%! 声明java代码 %&gt;</span><br></pre></td></tr></table></figure>
<p>可以给jsp翻译出来的java类定义属性和方法,甚至是代码块或内部类.</p>
<h3 id="表达式脚本-常用"><a href="#表达式脚本-常用" class="headerlink" title="表达式脚本(常用):"></a>表达式脚本(常用):</h3><figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line">&lt;<span class="meta">%</span> =表达式 <span class="meta">%</span>&gt;</span><br></pre></td></tr></table></figure>
<p>jsp页面输出的数据,可以调用jspService中的对象.注意:不能使用分号</p>
<h3 id="代码脚本"><a href="#代码脚本" class="headerlink" title="代码脚本"></a>代码脚本</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;% java语句 %&gt;</span><br></pre></td></tr></table></figure>
<p>代码脚本会被翻译到jspService()方法中.<br>可以调用jspService中的方法以对象,if方法以及for循环语句.<br>且因为是直接复制放入,甚至可以将一段代码拆分为几部分分别放入代码脚本中,翻译后就自然拼接起来了.也可以与表达式脚本和html语句进行拼接.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot;&gt;</span><br><span class="line">&lt;% </span><br><span class="line">    for(int j = 0; j&lt; 10;j++)&#123;</span><br><span class="line">%&gt;</span><br><span class="line">    &lt;tr&gt;</span><br><span class="line">        &lt;td&gt;第&lt;%=j+1%&gt;行&lt;/td&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">&lt;%</span><br><span class="line">    &#125;</span><br><span class="line">%&gt;</span><br><span class="line">&lt;/table&gt;</span><br></pre></td></tr></table></figure>
<h2 id="内置对象"><a href="#内置对象" class="headerlink" title="内置对象"></a>内置对象</h2><table>
<thead>
<tr>
<th>-</th>
<th>-</th>
</tr>
</thead>
<tbody><tr>
<td>request</td>
<td>请求对象</td>
</tr>
<tr>
<td>response</td>
<td>响应对象</td>
</tr>
<tr>
<td>pageContext</td>
<td>jsp上下文对象</td>
</tr>
<tr>
<td>session</td>
<td>会话对象</td>
</tr>
<tr>
<td>application</td>
<td>ServletContext对象</td>
</tr>
<tr>
<td>config</td>
<td>ServletConfig对象</td>
</tr>
<tr>
<td>out</td>
<td>jsp输出流对象</td>
</tr>
<tr>
<td>page</td>
<td>指向当前jsp的对象</td>
</tr>
<tr>
<td>exception</td>
<td>异常对象</td>
</tr>
</tbody></table>
<p>其中有四个是域对象,它们的作用范围各不相同<br>域对象|作用范围<br>-|-<br>pageContext(PageContextImpl类)|当前jsp页面范围内有效<br>request(HttpServletRequest类)|一次请求内有效<br>session(HttpSession类)|一个会话范围内有效(打开浏览器,直到关闭浏览器)<br>application(ServletContext类)|整个web工程内</p>
<h2 id="out与response的区别"><a href="#out与response的区别" class="headerlink" title="out与response的区别"></a>out与response的区别</h2><p>out与response分别有自己的缓冲区,当out刷新时会把内容送入到response中,当response刷新时会把全部数据给客户端.<br>out.print:不管输入任何内容,在输出时都会转化成字符串.<br>out.write:不会专门进行字符串的转化,像int传入后会使用ascii码转成字符.</p>
<h2 id="常用标签"><a href="#常用标签" class="headerlink" title="常用标签"></a>常用标签</h2><h3 id="jsp静态包含-常用"><a href="#jsp静态包含-常用" class="headerlink" title="jsp静态包含(常用)"></a>jsp静态包含(常用)</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;%@ include file=&quot;路径&quot;%&gt;</span><br></pre></td></tr></table></figure>
<p>静态包含是把被包含的内容在解析时直接复制过来,两部分内容本质在一个文件中,公用所有参数.</p>
<h3 id="动态包含"><a href="#动态包含" class="headerlink" title="动态包含"></a>动态包含</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;jsp:include page=&quot;路径&quot;&gt;</span><br><span class="line">    &lt;jsp:param name=&quot;username&quot; value=&quot;jj&quot;/&gt;</span><br><span class="line">&lt;/jsp:include&gt;</span><br></pre></td></tr></table></figure>
<p>动态包含会把被包含的内容再独立创建一个文件,这个文件的内置对象是主文件对象的指针,本质还是共用内置对象.</p>
<h3 id="请求转发"><a href="#请求转发" class="headerlink" title="请求转发"></a>请求转发</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;jsp:forward page=&quot;路径&quot;&gt;&lt;/jsp:forward&gt;</span><br></pre></td></tr></table></figure>
<p>这里就是jsp的主要作用,当客户端要检索内容时,客户端的请求会发送给servlet由servlet执行对数据库的操作,当servlet获取到检索的内容时会把它放到request中转发给jsp,最终由jsp实现数据的回传.</p>
<h2 id="JSTL核心标签库"><a href="#JSTL核心标签库" class="headerlink" title="JSTL核心标签库"></a>JSTL核心标签库</h2><p>1.导入jstl标签库的jar包<br>2.引入标签库(使用时会自动导入)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot;%&gt;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>标签</th>
<th>使用方法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>&lt;c:set /&gt;</td>
<td>scop=”域”  var=”key”  value=”value”</td>
<td>可以往域中保存数据</td>
</tr>
<tr>
<td>&lt;c:if&gt;</c:if></td>
<td>test=”EL判断表达式”,成立执行中间的内容</td>
<td>做if判断</td>
</tr>
<tr>
<td>&lt;c:choose&gt;&lt;c:when&gt;&lt;c:otherwise&gt;</td>
<td>在when中填写test属性,且when一定要在choose标签中</td>
<td>跟switch…case…default类似,不需要break</td>
</tr>
<tr>
<td>&lt;c:forEach/&gt;</td>
<td>begin=”起始索引” end=”结束” var=”i” step=”步长”</td>
<td>数字遍历循环,i表示当前数字</td>
</tr>
<tr>
<td>&lt;c:forEach/&gt;</td>
<td>items=”数组” var=”i” varStatus=””</td>
<td>数组,集合遍历循环,i表示当前数据,可以添加起始,结束索引以及步长</td>
</tr>
</tbody></table>
<h1 id="EL表达式"><a href="#EL表达式" class="headerlink" title="EL表达式"></a>EL表达式</h1><p>主要是代替jsp页面中的表达式脚本,主要用于输出域对象数据,填入key输出value.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$&#123;表达式&#125;</span><br><span class="line">//也可以写对象以及其中的属性,会直接调用其对应的get方法进而会调用其toString方法,</span><br><span class="line">//如果没有get方法则会报错</span><br><span class="line">//调用map的具体key-value时在map后加.key即可</span><br></pre></td></tr></table></figure>
<p>比jsp表达式脚本更简洁,且null会直接输出为空串.<br>当四个域都有相同key时,会优先使用更小范围的key.</p>
<h2 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h2><p>此外EL表达式也支持java的各种运算.比java还多了以下这些运算:</p>
<table>
<thead>
<tr>
<th>表达式</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>${empty 表达式}</td>
<td>判断是否为空</td>
</tr>
<tr>
<td>.运算</td>
<td>输出Bean对象的某个属性的值</td>
</tr>
<tr>
<td>[]运算</td>
<td>输出有序集合中某个元素的值</td>
</tr>
<tr>
<td>map[a.a.a]</td>
<td>输出map的一些有特殊符号的key</td>
</tr>
</tbody></table>
<h2 id="隐含对象"><a href="#隐含对象" class="headerlink" title="隐含对象"></a>隐含对象</h2><table>
<thead>
<tr>
<th>变量</th>
<th>类型</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>pageContext</td>
<td>PageContextImpl</td>
<td>它可以获取jsp中的九大内置对象</td>
</tr>
<tr>
<td>pageScope</td>
<td>Map&lt;String,Object&gt;</td>
<td>它可以获取pageContext域中的数据</td>
</tr>
<tr>
<td>requestScope</td>
<td>Map&lt;String,Object&gt;</td>
<td>它可以获取Request域中的数据</td>
</tr>
<tr>
<td>sessionScope</td>
<td>Map&lt;String,Object&gt;</td>
<td>它可以获取Session域中的数据</td>
</tr>
<tr>
<td>applicationScope</td>
<td>Map&lt;String,Object&gt;</td>
<td>它可以获取Application域中的数据</td>
</tr>
<tr>
<td>param</td>
<td>Map&lt;String,String&gt;</td>
<td>它可以获取请求参数的值</td>
</tr>
<tr>
<td>paramValues</td>
<td>Map&lt;String,String[]&gt;</td>
<td>它可以获取请求参数的值(多个值时)</td>
</tr>
<tr>
<td>header</td>
<td>Map&lt;String,String&gt;</td>
<td>可以获取请求头的信息</td>
</tr>
<tr>
<td>headerValues</td>
<td>Map&lt;String,String[]&gt;</td>
<td>它可以获取请求头的值(多个值时)</td>
</tr>
<tr>
<td>cookie</td>
<td>Map&lt;String,Cookie&gt;</td>
<td>它可以获取当前请求的Cookie信息</td>
</tr>
<tr>
<td>initParam</td>
<td>Map&lt;String,String&gt;</td>
<td>它可以获取在web.xml中配置的<context-param>上下文参数</td>
</tr>
</tbody></table>
<h1 id="文件的上传"><a href="#文件的上传" class="headerlink" title="文件的上传"></a>文件的上传</h1><p>1.有from标签,method=post,encType=multipart/from-data(表示数据以多段(每个表单项为一段)的形式进行拼接,然后以二进制流的形式发送给服务器)<br>2.有input标签,type=file.<br>3.编写服务器代码接收(servlet那边以二进制流的形式接收,解析.解析要使用commons jar包)</p>
<h2 id="fileupload常用方法-类"><a href="#fileupload常用方法-类" class="headerlink" title="fileupload常用方法,类"></a>fileupload常用方法,类</h2><table>
<thead>
<tr>
<th>方法或类</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>ServletFileUpload类</td>
<td>用于解析上传数据</td>
</tr>
<tr>
<td>boolean ServletFileload.isMultipartContent(req)</td>
<td>判断接收到的数据是否为多段格式</td>
</tr>
<tr>
<td>public List<FileItem> parseRequest(req)</td>
<td>分段解析上传的数据</td>
</tr>
<tr>
<td>boolean FileItem.isFormField()</td>
<td>判断是否是普通表单项</td>
</tr>
<tr>
<td>String FileItem.getFileName()</td>
<td>获取表单项的名</td>
</tr>
<tr>
<td>String FileItem.getString(“UTF-8”)</td>
<td>获取当前表单项的值</td>
</tr>
<tr>
<td>String FileItem.getName()</td>
<td>获取上传的文件名</td>
</tr>
<tr>
<td>void FileItem.write(new File(path))</td>
<td>输出到指定磁盘位置</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//判断格式</span><br><span class="line">if(ServletFileload.isMultipartContent(req))&#123;</span><br><span class="line">    //创建FileItemFactory工厂实现类</span><br><span class="line">    FileItemFactory fileItemFactory = new DiskFileItemFactory();</span><br><span class="line">    //创建用于解析上传数据的工具类ServletFileUpload类</span><br><span class="line">    ServletFileUpload servletFileUpload = new ServletFileUpload(fileItemFactory);</span><br><span class="line">    //解析上传的数据,得到每个的表单项FileItem</span><br><span class="line">    List&lt;FileItem&gt; list = servletFileUpload.parseRequest(req);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="文件的下载"><a href="#文件的下载" class="headerlink" title="文件的下载"></a>文件的下载</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">doGet()&#123;</span><br><span class="line">    //取得文件名</span><br><span class="line">    String downloadName =</span><br><span class="line">    //设置取得文件的文件夹路径</span><br><span class="line">    String filePath = &quot;/file/&quot;;</span><br><span class="line">    //获取要下载的文件类型</span><br><span class="line">    ServletContext servletContext = getServletContext;</span><br><span class="line">    String mimeType = servletContext.getMimeType(filePath+downloadFileName);</span><br><span class="line">    //设置响应头告诉客户端返回的数据类型</span><br><span class="line">    resp.setContextType(mimeType);</span><br><span class="line">    //设置响应头告诉客户端这是用于下载的(不设置会直接显示),这里的编码方式是对应谷歌,ie浏览器</span><br><span class="line">    resp.setHeader(&quot;Content-Disposition&quot;,&quot;attachment;filename=&quot;+URLEncoder.encode(&quot;有汉字的字符串&quot;,&quot;UTF-8&quot;));</span><br><span class="line">    //取得要下载的文件内容</span><br><span class="line">    InputStream resourceAsStream = servletContext.getResourceAsStream(filePath+downloadFileName);</span><br><span class="line">    //获取输出流</span><br><span class="line">    OutputStream outputStream = resp.getOutputStream();</span><br><span class="line">    //使用commons包工具类导出</span><br><span class="line">    IOUtils.copy(resourceAsStream,outputStream);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h1><h2 id="阶段一"><a href="#阶段一" class="headerlink" title="阶段一"></a>阶段一</h2><p>表单验证的实现</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    $(function () &#123;</span><br><span class="line">        //给注册绑定事件</span><br><span class="line">        $(&quot;#sub_btn&quot;).click(function () &#123;</span><br><span class="line">            var username = $(&quot;#username&quot;).val()</span><br><span class="line">            var usernamePatt = /^\w&#123;5,12&#125;$/</span><br><span class="line">            //确认用户名</span><br><span class="line">            if (!usernamePatt.test(username))&#123;</span><br><span class="line">                //定位错误信息输出文本，并输出对应的文字</span><br><span class="line">                $(&quot;span.errorMsg&quot;).text(&quot;用户名不合法&quot;)</span><br><span class="line">                //防止页面跳转</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            //合法后要去处显示的信息</span><br><span class="line">            var password = $(&quot;#password&quot;).val();</span><br><span class="line">            var passwordPatt = /^\w&#123;5,12&#125;$/</span><br><span class="line">            $(&quot;span.errorMsg&quot;).text(&quot;&quot;);</span><br><span class="line">            //确认密码</span><br><span class="line">            if (!passwordPatt.test(password))&#123;</span><br><span class="line">                $(&quot;span.errorMsg&quot;).text(&quot;密码不合法&quot;)</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            $(&quot;span.errorMsg&quot;).text(&quot;&quot;);</span><br><span class="line">            var repwd = $(&quot;#repwd&quot;).val()</span><br><span class="line">            //确认确认的密码</span><br><span class="line">            if (repwd!=password)&#123;</span><br><span class="line">                $(&quot;span.errorMsg&quot;).text(&quot;两次密码不一致&quot;)</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            $(&quot;span.errorMsg&quot;).text(&quot;&quot;);</span><br><span class="line">            var email = $(&quot;#email&quot;).val()</span><br><span class="line">            var emailPatt = /\w*@\w*.com/</span><br><span class="line">            //确认邮箱</span><br><span class="line">            if (!emailPatt.test(email))&#123;</span><br><span class="line">                $(&quot;span.errorMsg&quot;).text(&quot;邮箱不合法&quot;)</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            $(&quot;span.errorMsg&quot;).text(&quot;&quot;);</span><br><span class="line">            var code = $(&quot;#code&quot;).val();</span><br><span class="line">            //确认验证码</span><br><span class="line">            if (code==null||code==&quot;&quot;)&#123;</span><br><span class="line">                $(&quot;span.errorMsg&quot;).text(&quot;输入正确的验证码&quot;)</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            $(&quot;span.errorMsg&quot;).text(&quot;&quot;);</span><br><span class="line"></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h2 id="阶段二"><a href="#阶段二" class="headerlink" title="阶段二"></a>阶段二</h2><p>1.创建数据库与用户表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE DATABASE book</span><br><span class="line">USE book</span><br><span class="line">CREATE TABLE `user`(</span><br><span class="line">    `id` INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">    `usernam` VARCHAR(20) NOT NULL UNIQUE,</span><br><span class="line">    `password` VARCHAR(32) NOT NULL,</span><br><span class="line">    `email` VARCHAR(200)</span><br><span class="line">)</span><br><span class="line">ALTER TABLE `user` CHANGE `usernam`  `username` VARCHAR(20) NOT NULL UNIQUE</span><br><span class="line">INSERT INTO `user`(`username`,`password`,`email`)VALUES(&#x27;admin&#x27;,&#x27;admin&#x27;,NULL)</span><br></pre></td></tr></table></figure>
<p>2.编写对应的javabean类<br>3.编写Dao持久层(实现对数据库的各种操作)<br>    搭建常用工具类：导入DBUtils包，MySQL包，durid包。编写durid工具包，编写BasicDao，UserDao，UserDaoImpl。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class UserDaoImpl extends BasicDao&lt;User&gt; implements UserDao &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public User queryUserByUsername(String username) &#123;</span><br><span class="line">        String sql = &quot;select * from `user` where `username` = ?&quot;;</span><br><span class="line">        return querySingle(sql,User.class,username);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public User queryUserByUsernameAndPassword(String username, String password) &#123;</span><br><span class="line">        String sql = &quot;select * from `user` where `username` = ? and `password` = ?&quot;;</span><br><span class="line">        return querySingle(sql,User.class,username,password);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int saveUser(User user) &#123;</span><br><span class="line">        String sql = &quot;insert into `user`(username,password,email) values(?,?,?)&quot;;</span><br><span class="line"></span><br><span class="line">        return update(sql,user.getName(),user.getPassword(),user.getEmail());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4.编写Service业务层(实现各种方法)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class UserServiceImpl implements UserService &#123;</span><br><span class="line">    private UserDao userDao = new UserDaoImpl();</span><br><span class="line">    @Override</span><br><span class="line">    public void registUser(User user) &#123;</span><br><span class="line">        userDao.saveUser(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public User login(String username, String password) &#123;</span><br><span class="line">        return userDao.queryUserByUsernameAndPassword(username,password);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean canUseName(String username) &#123;</span><br><span class="line">        User user = userDao.queryUserByUsername(username);</span><br><span class="line">        if (user==null)&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>5.编写web层(将请求路径与工程进行绑定,将得到的请求进行解析,交给业务层实现,接收业务层的结果,处理后,输出给客户端)<br>    导入servlet包。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class RegistServlet extends HttpServlet &#123;</span><br><span class="line">    UserService userService = new UserServiceImpl();</span><br><span class="line">    @Override</span><br><span class="line">    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;</span><br><span class="line">        String username = req.getParameter(&quot;username&quot;);</span><br><span class="line">        String password = req.getParameter(&quot;password&quot;);</span><br><span class="line">        String email = req.getParameter(&quot;email&quot;);</span><br><span class="line">        String code = req.getParameter(&quot;code&quot;);</span><br><span class="line">        //验证验证码</span><br><span class="line">        if (userService.canUseName(username))&#123;</span><br><span class="line">            User user = new User(0,username, password, email);</span><br><span class="line">            userService.registUser(user);</span><br><span class="line">            req.getRequestDispatcher(&quot;pages/user/regist_success.html&quot;).forward(req,resp);</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            req.getRequestDispatcher(&quot;pages/user/regist.html&quot;).forward(req,resp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>java web</category>
      </categories>
  </entry>
  <entry>
    <title>第n位数字</title>
    <url>/2021/11/30/%E7%AC%ACn%E4%BD%8D%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给你一个整数n，请你在无限的整数序列[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, …]中找出并返回第n位上的数字。</p>
<span id="more"></span>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>本题有时间限制，所以要找到一些规律：n位数字中有n<em>9</em>10^(n-1)位数字，根据这个规律判断数字的位数。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int findNthDigit(int n) &#123;</span><br><span class="line">        if (n&lt;10)&#123;</span><br><span class="line">            return n;</span><br><span class="line">        &#125;</span><br><span class="line">        //答案的长度</span><br><span class="line">        int numLength = 0;</span><br><span class="line">        //可能范围,使用long防止溢出</span><br><span class="line">        long count = 0;</span><br><span class="line">        while (count&lt;n)&#123;</span><br><span class="line">            numLength++;</span><br><span class="line">            count+=numLength*9*Math.pow(10,numLength-1);</span><br><span class="line">        &#125;</span><br><span class="line">        count-=numLength*9*Math.pow(10,numLength-1);</span><br><span class="line">        //判断第几位数字</span><br><span class="line">        int k = (int) (n-count)%numLength;</span><br><span class="line">        if (k==0)&#123;</span><br><span class="line">            k=numLength;</span><br><span class="line">        &#125;</span><br><span class="line">        //判断第几个数字</span><br><span class="line">        int index = (int) (n-count+1)/numLength;</span><br><span class="line">        //找到这个数字</span><br><span class="line">        int answerNum = (int) Math.pow(10,numLength-1)+index-1;</span><br><span class="line">        return Integer.valueOf(String.valueOf(answerNum).substring(k-1,k));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode解析</category>
        <category>中等</category>
      </categories>
      <tags>
        <tag>数学分析</tag>
      </tags>
  </entry>
  <entry>
    <title>不同路径(m个a和n个b的组合问题)</title>
    <url>/2021/12/01/%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>一个机器人位于一个 m x n网格的左上角（起始点在下图中标记为“Start”）。<br>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。<br>问总共有多少条不同的路径？</p>
<span id="more"></span>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>通过分析可知，每个点位的路径是由上方点位和左方点位的路径和。所以可以制表求解。<br>有趣的是这道题也相当于求m-1个a和n-1个b的组合问题，这为这个问题的求解提供了一种方法，比递归求解要效率很多。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int uniquePaths(int m, int n) &#123;</span><br><span class="line">        int[][] ints = new int[m][n];</span><br><span class="line">        for (int i = 0;i&lt;m;i++)&#123;</span><br><span class="line">            ints[i][0]=1;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0;i&lt;n;i++)&#123;</span><br><span class="line">            ints[0][i]=1;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i=1;i&lt;m;i++)&#123;</span><br><span class="line">            for (int j=1;j&lt;n;j++)&#123;</span><br><span class="line">                ints[i][j] = ints[i-1][j]+ints[i][j-1];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ints[m-1][n-1];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode解析</category>
        <category>中等</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>git操作手册</title>
    <url>/2021/11/19/git%E6%93%8D%E4%BD%9C%E6%89%8B%E5%86%8C/</url>
    <content><![CDATA[<p>此为git常用命令备忘</p>
<span id="more"></span>

<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>本地库操作</td>
<td></td>
</tr>
<tr>
<td>git init</td>
<td>初始化本地库</td>
</tr>
<tr>
<td>git status</td>
<td>显示本地库状态</td>
</tr>
<tr>
<td>git add 文件名</td>
<td>提交文件至暂存区</td>
</tr>
<tr>
<td>git rm –cached 文件名</td>
<td>删除暂存区文件</td>
</tr>
<tr>
<td>git commit -m “日志” 文件名</td>
<td>将暂存区文件提交到本地库(当合并冲突导致进入合并中状态时，提交文件不允许添加文件名)</td>
</tr>
<tr>
<td>git reflog</td>
<td>查看引用日志信息</td>
</tr>
<tr>
<td>git log</td>
<td>查看详细日志</td>
</tr>
<tr>
<td>git reset –hard 版本号</td>
<td>版本穿梭</td>
</tr>
<tr>
<td>git branch -v</td>
<td>查看分支</td>
</tr>
<tr>
<td>git branch 分支名</td>
<td>创建分支</td>
</tr>
<tr>
<td>git checkout 分支名</td>
<td>切换分支</td>
</tr>
<tr>
<td>git merge 分支名</td>
<td>合并分支</td>
</tr>
<tr>
<td>远程库操作</td>
<td></td>
</tr>
<tr>
<td>git remote -v</td>
<td>查看远程地址别名</td>
</tr>
<tr>
<td>git remote add 别名 地址</td>
<td>为远程地址命名</td>
</tr>
<tr>
<td>git push 别名 分支</td>
<td>推到远程库</td>
</tr>
<tr>
<td>git pull 别名 分支</td>
<td>拉到本地库</td>
</tr>
<tr>
<td>git clone 链接</td>
<td>克隆到本地</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>git操作手册</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>javase题目</title>
    <url>/2021/12/03/javase%E9%A2%98%E7%9B%AE/</url>
    <content><![CDATA[<h1 id="hashmap的扩容与-amp-运算问题"><a href="#hashmap的扩容与-amp-运算问题" class="headerlink" title="hashmap的扩容与&amp;运算问题"></a>hashmap的扩容与&amp;运算问题</h1><p>基本知识<br>1、初始容量为1&lt;&lt;4<br>2、负载因子为0.75，到达负载因子时2次幂扩展<br>3、通过hashcode计算存放位置</p>
<span id="more"></span>
<p>hashcode的计算<br>1、获取hash值h，将h&gt;&gt;&gt;16后再与自身异或。<br>这是因为在计算hashmap存放位置时只取低位，正常运算会丢失高位的信息。这样处理后也可以将高位<br>的信息保留，减少冲突的可能性。<br>2、取模运算:(length-1)&amp;hash。<br>在这里可以解释为什么扩容是是2次幂，一般情况下，计算位置是需要%计算，但当length的长度为2的<br>次幂的时候，取余运算可以转化成上面的位与运算，大大节省了计算时间。</p>
<p><a href="https://www.cnblogs.com/ysocean/p/9054804.html">来源</a></p>
<h1 id="为什么重写-equals-还要重写-hashcode？"><a href="#为什么重写-equals-还要重写-hashcode？" class="headerlink" title="为什么重写 equals 还要重写 hashcode？"></a>为什么重写 equals 还要重写 hashcode？</h1><p>因为不重写hashcode在插入到哈希表时不能保证插入到同一位置，不插入到同一位置就无法触发equals判断。</p>
<h1 id="和-equals-比较的区别"><a href="#和-equals-比较的区别" class="headerlink" title="== 和 equals 比较的区别"></a>== 和 equals 比较的区别</h1><p>对于对象而言，==是在判断地址是否相同，equals是判断内容。</p>
<h1 id="为什么浮点数运算会不精准"><a href="#为什么浮点数运算会不精准" class="headerlink" title="为什么浮点数运算会不精准"></a>为什么浮点数运算会不精准</h1><p>因为计算机的浮点数是用二进制的科学计数保存的，它可以保存1/2，1/4等，但却因为进制问题不能表示0.1这种数字，只能近似，所以在保存这些数字的时候会丢失精度。</p>
<h1 id="为什么定义long类型与float类型时要加l和f"><a href="#为什么定义long类型与float类型时要加l和f" class="headerlink" title="为什么定义long类型与float类型时要加l和f"></a>为什么定义long类型与float类型时要加l和f</h1><p>这是因为定义变量的过程本质是使用指针将两个内存块连接的过程。long类型常量不加l修饰会这个常量只会被当作int型，分配的空间也只有int型的大小。而浮点型默认是double，如果不加f，相当于把double直接赋予float，编译器会不通过。</p>
<h1 id="创建子类对象"><a href="#创建子类对象" class="headerlink" title="创建子类对象"></a>创建子类对象</h1><p>创建子类对象时会默认调用父类的无参构造器方法来初始化属性，如果没有无参构造器，则需要使用super方法声明构造器的使用。<br>调用父类构造器是考虑到父类的一些私有属性可能要使用自己的构造器进行初始化。</p>
<h1 id="什么是多态"><a href="#什么是多态" class="headerlink" title="什么是多态"></a>什么是多态</h1><p>多态是指不同的子类在继承父类后分别重写父类的方法，使得可以统一编译父类，通过不同子类的运行，实现不同的方法。</p>
<h1 id="为什么子类重写父类的方法不能低于其在父类中的访问权限"><a href="#为什么子类重写父类的方法不能低于其在父类中的访问权限" class="headerlink" title="为什么子类重写父类的方法不能低于其在父类中的访问权限"></a>为什么子类重写父类的方法不能低于其在父类中的访问权限</h1><p>因为这样操作会影响多态，当父类方法是公开，而子类重写方法是私有时，父类在实现多态时会无法调用子类的方法。</p>
<h1 id="动态绑定"><a href="#动态绑定" class="headerlink" title="动态绑定"></a>动态绑定</h1><p>当调用对象方法时，该方法会和该对象的运行类型相绑定。而调用对象属性时不会有动态绑定，而是从该对象开始向上搜寻。</p>
<h1 id="哪些情况会导致类被加载"><a href="#哪些情况会导致类被加载" class="headerlink" title="哪些情况会导致类被加载"></a>哪些情况会导致类被加载</h1><p>1.创建对象时<br>2.子类创建对象时<br>3.使用静态成员时</p>
<h1 id="final的作用"><a href="#final的作用" class="headerlink" title="final的作用"></a>final的作用</h1><p>1.防止类被继承<br>2.防止方法被重写<br>3.防止属性或变量被更改<br>4.与static搭配使用可以提高效率，被final static修饰的属性(方法不可以)被调用时不会导致类加载，也就是说这么修饰的属性不需要类加载也能获得。</p>
<h1 id="哪些情况Integer不会创建新对象"><a href="#哪些情况Integer不会创建新对象" class="headerlink" title="哪些情况Integer不会创建新对象"></a>哪些情况Integer不会创建新对象</h1><p>在Integr值在-128到127之间时。这是因为Integer有一个公用的闪存数组，数字在这个区间时会直接返回闪存数组中的对象。</p>
<h1 id="String的两种创建方式的区别"><a href="#String的两种创建方式的区别" class="headerlink" title="String的两种创建方式的区别"></a>String的两种创建方式的区别</h1><p>不调用构造器直接赋值：<br>先从常量池查看是否有这个字符串，如果有就直接指向，没有则创建再指向，一级指针指向常量池。<br>调用构造器赋值：<br>先在堆中创建空间，里面维护value属性，指向常量池，如果常量池没有，则重新创建再指向，有就直接指向，一级指针指向堆。<br>使用intern方法后会进行规范化，指向常量池。使用字符串加和创建的字符串一级指针也是指向堆。</p>
<h1 id="StringBuffer的优点"><a href="#StringBuffer的优点" class="headerlink" title="StringBuffer的优点"></a>StringBuffer的优点</h1><p>StringBuffer创建的字符串不进入常量池，而是在堆中存放，使用append方法添加字符串时也不会像String一样在常量池中重新创建新的字符串，而是在原有的字符串基础上进行扩容，当循环使用时比String要快很多。</p>
<h1 id="java的集合类"><a href="#java的集合类" class="headerlink" title="java的集合类"></a>java的集合类</h1><p><img src="/images/2.png" alt="2.png"></p>
<h1 id="java8新特性"><a href="#java8新特性" class="headerlink" title="java8新特性"></a>java8新特性</h1><p>1.lambda表达式<br>2.函数式接口<br>3.Stream API</p>
<h1 id="JDK1-7与1-8中hashmap的差异"><a href="#JDK1-7与1-8中hashmap的差异" class="headerlink" title="JDK1.7与1.8中hashmap的差异"></a>JDK1.7与1.8中hashmap的差异</h1><p>1、1.7计算hashcode经过了4此移位和异或运算，1.8只有一次移位和异或运算。<br>2、1.8的hashmap当哈希表大小到64时会树化。<br>3、1.8的hashmap的链表插入方法为尾插，1.7是头插。<br>4、扩容方式不同。<br>5、1.7是先判断扩容再插入，1.8是先插入再判断扩容。<br>好处：降低事件复杂度，改用尾插法就去除了并发条件下成环的问题。</p>
]]></content>
      <categories>
        <category>面试题</category>
        <category>javase题目</category>
      </categories>
  </entry>
  <entry>
    <title>sqrt</title>
    <url>/2021/12/02/sqrt/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给你一个非负整数x，计算并返回x的算术平方根 。<br>由于返回类型是整数，结果只保留整数部分，小数部分将被舍去。</p>
<span id="more"></span>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>因为答案一定在0-x之间，所以可以使用二分查找。再对right上限设定为46340，针对溢出。<br>关于mid的设置应该是(right+left)/2还是(right+left+1)/2，因为两个数字的情况下要保留前面的数字，所以要让指针指向后面的数字以便舍弃。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int mySqrt(int x) &#123;</span><br><span class="line">        int left = 0;</span><br><span class="line">        int right = x;</span><br><span class="line">        if (right&gt;46340)&#123;</span><br><span class="line">            right = 46340;</span><br><span class="line">        &#125;</span><br><span class="line">        while (left!=right)&#123;</span><br><span class="line">            int mid = (left+right+1)/2;</span><br><span class="line">            if (mid*mid==x)&#123;</span><br><span class="line">                return mid;</span><br><span class="line">            &#125;else if (mid*mid&gt;x)&#123;</span><br><span class="line">                right = mid-1;</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                left = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return left;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode解析</category>
        <category>简单</category>
      </categories>
      <tags>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>linux常用命令</title>
    <url>/2021/11/19/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>一些常用的命令</p>
<span id="more"></span>
]]></content>
      <categories>
        <category>linux常用命令</category>
      </categories>
  </entry>
  <entry>
    <title>数据库题目</title>
    <url>/2021/12/03/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%A2%98%E7%9B%AE/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>面试题</category>
        <category>数据库题目</category>
      </categories>
  </entry>
  <entry>
    <title>mySQL笔记</title>
    <url>/2021/12/03/mySQL%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="前提知识"><a href="#前提知识" class="headerlink" title="前提知识"></a>前提知识</h1><p>MySQL 在 Windows 下不区分大小写，但在 Linux 下默认是区分大小写。因此，数据库名、 表名、字段名，都不允许出现任何大写字母，避免节外生枝。</p>
<span id="more"></span>
<h1 id="数据库指令"><a href="#数据库指令" class="headerlink" title="数据库指令"></a>数据库指令</h1><h2 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h2><table>
<thead>
<tr>
<th>指令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>create database 库名</td>
<td>创建数据库，默认utf8字符集，utf8_general_ci校对</td>
</tr>
<tr>
<td>use database 库名</td>
<td>切换数据库</td>
</tr>
<tr>
<td>character set …</td>
<td>设定字符集</td>
</tr>
<tr>
<td>collate …</td>
<td>设定校对规则 utf8_general_ci(不区分大小写)，utf8_bin(区分)</td>
</tr>
<tr>
<td>show databases</td>
<td>查看当前数据库服务器中所有数据库</td>
</tr>
<tr>
<td>show create database</td>
<td>查看前面创建的数据库信息</td>
</tr>
<tr>
<td>drop database</td>
<td>删库跑路</td>
</tr>
<tr>
<td>mysqldump -u 用户名 -p -B 数据库 &gt; 文件名.sql</td>
<td>(dos)备份数据库</td>
</tr>
<tr>
<td>source 文件名.sql</td>
<td>(mysql命令行)恢复数据库</td>
</tr>
</tbody></table>
<h2 id="表操作、列操作"><a href="#表操作、列操作" class="headerlink" title="表操作、列操作"></a>表操作、列操作</h2><table>
<thead>
<tr>
<th>指令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>desc</td>
<td>查看表结构</td>
</tr>
<tr>
<td>create table 表名(列名，数据格式)</td>
<td>创建表，可以设置字符集，校对规则和引擎</td>
</tr>
<tr>
<td>alter table 表名 add(列名，数据格式)</td>
<td>为表添加列</td>
</tr>
<tr>
<td>alter table 表名 modify(列名，数据格式)</td>
<td>修改列</td>
</tr>
<tr>
<td>alter table 表名 drop(列名)</td>
<td>删列</td>
</tr>
<tr>
<td>not null default ‘内容’</td>
<td>不允许为空，替换为’’内的内容</td>
</tr>
<tr>
<td>delete from 表名</td>
<td>删除数据</td>
</tr>
</tbody></table>
<h2 id="行操作"><a href="#行操作" class="headerlink" title="行操作"></a>行操作</h2><p>select整体语句结构：<br>select…from…group by…having…order by…limit…</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>insert into 表名 (列名) values (值)</td>
<td>插入数据，values后面用多个括号可以添加多条数据，不写列名视为给所有字段添加信息</td>
</tr>
<tr>
<td>update 表名 set 列名=值</td>
<td>修改数据</td>
</tr>
<tr>
<td>where</td>
<td>限定操作执行的范围</td>
</tr>
<tr>
<td>select</td>
<td></td>
</tr>
<tr>
<td>select distinct *或列名 from 表</td>
<td>查表，distinct用于去重</td>
</tr>
<tr>
<td>select 运算 as 别名 from</td>
<td>进行规定的运算并以别名显示</td>
</tr>
<tr>
<td>order by …(desc)</td>
<td>升序(降序)排序</td>
</tr>
</tbody></table>
<h2 id="where子句常用运算符"><a href="#where子句常用运算符" class="headerlink" title="where子句常用运算符"></a>where子句常用运算符</h2><table>
<thead>
<tr>
<th>符号</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>between…and…</td>
<td>-</td>
</tr>
<tr>
<td>in(set)</td>
<td>显示在in列表中的值</td>
</tr>
<tr>
<td>like ‘’</td>
<td>模糊查询</td>
</tr>
<tr>
<td>not like ‘’</td>
<td>模糊查询</td>
</tr>
<tr>
<td>is null</td>
<td>为空</td>
</tr>
</tbody></table>
<h2 id="统计函数"><a href="#统计函数" class="headerlink" title="统计函数"></a>统计函数</h2><table>
<thead>
<tr>
<th>指令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>select count(*)或count(列名)</td>
<td>查询数据的数量</td>
</tr>
<tr>
<td>select sum(列名,列名…) from tablename</td>
<td>对数据求和</td>
</tr>
<tr>
<td>select avg(列名,列名…) from tablename</td>
<td></td>
</tr>
<tr>
<td>select max(列名,列名…) from tablename</td>
<td></td>
</tr>
<tr>
<td>select min(列名,列名…) from tablename</td>
<td></td>
</tr>
<tr>
<td>select …. group by column (having…)</td>
<td>以某列数据为分组进行统计查询，使用having对查询结果进一步过滤</td>
</tr>
</tbody></table>
<h2 id="字符串相关函数"><a href="#字符串相关函数" class="headerlink" title="字符串相关函数"></a>字符串相关函数</h2><table>
<thead>
<tr>
<th>指令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>charset(column)</td>
<td>返回字符串使用的字符集</td>
</tr>
<tr>
<td>concat(column,s2…)</td>
<td>连接字符串，将同行数据拼接后显示</td>
</tr>
<tr>
<td>ucase(column)</td>
<td>转大写显示行</td>
</tr>
<tr>
<td>lcase(column)</td>
<td>转小写</td>
</tr>
<tr>
<td>length(column)</td>
<td>按字符串长度显示(按字节返回)</td>
</tr>
<tr>
<td>replace(column,search_str,replace_str)</td>
<td>查询某列，如果有search_str就替换为replace_str</td>
</tr>
<tr>
<td>substring(column,n1,n2)</td>
<td>截取某列部分字符串(这里字符串计数从1开始)</td>
</tr>
</tbody></table>
<h2 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a>数学函数</h2><table>
<thead>
<tr>
<th>指令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>abc(c)</td>
<td>绝对值</td>
</tr>
<tr>
<td>ceiling(c)</td>
<td>向上取整</td>
</tr>
<tr>
<td>floor(c)</td>
<td>向下取整</td>
</tr>
<tr>
<td>format(c,num)</td>
<td>保留要求的小数位数</td>
</tr>
<tr>
<td>rand(seed)</td>
<td>随机生成数，有seed可以保证随机数不变</td>
</tr>
</tbody></table>
<h2 id="时间函数"><a href="#时间函数" class="headerlink" title="时间函数"></a>时间函数</h2><table>
<thead>
<tr>
<th>指令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>current_date()</td>
<td>当前日期</td>
</tr>
<tr>
<td>current_time()</td>
<td>当前时间</td>
</tr>
<tr>
<td>current_timestamp()</td>
<td>当前时间戳</td>
</tr>
<tr>
<td>date(datetime)</td>
<td>返回datetime的日期部分</td>
</tr>
<tr>
<td>date_add(date,interval 时间)</td>
<td>在date中加上时间或日期</td>
</tr>
<tr>
<td>date_sub(date,interval 时间)</td>
<td>在date中减去时间或日期</td>
</tr>
<tr>
<td>datediff(date1,date2)</td>
<td>返回两个日期差</td>
</tr>
<tr>
<td>now()</td>
<td>当前日期时间</td>
</tr>
<tr>
<td>unix_timestamp</td>
<td>从1970到现在的秒数</td>
</tr>
<tr>
<td>from_unixtime(秒数,’%y-%m-%d’)</td>
<td>秒转日期</td>
</tr>
</tbody></table>
<p>在这些时间前使用year,month,date可以只返回这部分时间</p>
<h2 id="加密和系统函数"><a href="#加密和系统函数" class="headerlink" title="加密和系统函数"></a>加密和系统函数</h2><table>
<thead>
<tr>
<th>指令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>user()</td>
<td>查询用户</td>
</tr>
<tr>
<td>datebase()</td>
<td>数据库名称</td>
</tr>
<tr>
<td>MD5(str)</td>
<td>为字符串算出一个加密字符串</td>
</tr>
</tbody></table>
<h2 id="流程控制函数"><a href="#流程控制函数" class="headerlink" title="流程控制函数"></a>流程控制函数</h2><table>
<thead>
<tr>
<th>指令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>if(expr1,expr2,expr3)</td>
<td>如果expr1为true则返回expr2，如果2也为true返回3</td>
</tr>
<tr>
<td>ifnull(expr1,exp2)</td>
<td>如果expr1不为空则返回expr1，否则返回expr2</td>
</tr>
<tr>
<td>select case when expr1 then expr2 else expr3</td>
<td>如果满足expr1则返回expr2，否则返回expr3</td>
</tr>
</tbody></table>
<h1 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h1><p>多表查询可以同时生成多表的笛卡尔集以及复用单表的笛卡尔集。</p>
<h1 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h1><p>select语句可以放入where语句中进行子查询。也可以放入from语句作为临时表进行子查询。<br>可以使用all和any对子select语句进行约束，进行查询。<br>多列子查询：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from emp</span><br><span class="line">	where(deptno,job) = (</span><br><span class="line">			select deptno,job</span><br><span class="line">			from emp</span><br><span class="line">			where ename = &#x27;SMITH&#x27;</span><br><span class="line">			)</span><br></pre></td></tr></table></figure>
<h1 id="表复制"><a href="#表复制" class="headerlink" title="表复制"></a>表复制</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//一个表到另一个表</span><br><span class="line">insert into my_tab01</span><br><span class="line">	(id ,name ,sal ,job ,deptno)</span><br><span class="line">	select empno,ename,sal,job,detno from emp;</span><br><span class="line">//自我复制</span><br><span class="line">insert into my_tab01</span><br><span class="line">	select * from my_tab01;</span><br><span class="line">//复制表结构</span><br><span class="line">create table my_tab02 like my_tab01</span><br></pre></td></tr></table></figure>
<h1 id="去重"><a href="#去重" class="headerlink" title="去重"></a>去重</h1><p>1.创建一张与原表结构相同的临时表<br>2.把原表内容使用select distinct * from把原表复制到另一个表。<br>3.再删除掉原表数据<br>4.把临时表数据复制给原表，删除临时表</p>
<h1 id="合并查询"><a href="#合并查询" class="headerlink" title="合并查询"></a>合并查询</h1><p>可以使用union all 连接两个select语句进行合并查询(不会去重)，union可以去重。</p>
<h1 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h1><p>引入：当使用多表查询对员工与部门表进行查询时，无法显示出没有员工的部门。<br>左外连接：左侧表完全显示。<br>from 表1 left join 表2 on 条件。<br>右外连接：右侧表完全显示。<br>from 表1 right join 表2 on 条件。</p>
<h1 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h1><p>not null，unique，primary key，foreign key，check。</p>
<h2 id="主键primary-key"><a href="#主键primary-key" class="headerlink" title="主键primary key"></a>主键primary key</h2><p>用于唯一的标识表行数据，主键约束后该列不能重复且不能为空。</p>
<h2 id="外键foreign-key"><a href="#外键foreign-key" class="headerlink" title="外键foreign key"></a>外键foreign key</h2><p>当主表与副表有一共有列，且要求副表列中出现的元素属于主表中时，可以使用外键对副表进行约束。<br>foreign key (副表列名) references 主表表名(列名)</p>
<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p>提高数据库性能。<br>索引类型：<br>1.主键索引：主键自动为索引<br>2.唯一索引：unique修饰自动为索引<br>3.普通索引：手动指定<br>4.全文索引：开发中一般不用，使用全文搜索Solr和ElasticSearch</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//创建索引(会占用空间),只对这列查询提速</span><br><span class="line">create (unique)index 索引名 on 表名(列名)</span><br><span class="line">//添加主键(索引)</span><br><span class="line">alert table 表名 add index 索引名 (列名)</span><br><span class="line">//删除索引</span><br><span class="line">drop index 索引名 on 表名</span><br><span class="line">//删除主键索引</span><br><span class="line">alert table 表名 primary key</span><br><span class="line">//查询索引</span><br><span class="line">show index from 表名</span><br><span class="line">show keys from 表名</span><br><span class="line">desc 表名</span><br></pre></td></tr></table></figure>
<h2 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h2><p>1.最左前缀法则：如果建立的是复合索引，索引的顺序要按照建立的顺序，即从左到右。<br>    这是因为复合索引是多个字段作为索引存放在b+树中，且存放顺序是左边字段的优先级要高于右边的字段，一旦跳过左边字段直接查找右边字段，右边的字段是乱序的。<br>2.不要对索引进行计算，函数以及转型，会导致索引失效。<br>3.不可以在范围查找语句右边使用索引，会导致索引失效。<br>    因为b+树的叶节点是是一个有序链表，当进行范围查找时会会把整段链表直接取出等待下一步查找，这种情况下，除非取出的这整一段的范围查找的字段都相等，否则下一个字段一定是乱序的。<br>4.减少select* 的使用，尽量进行覆盖索引，即select查询字段与where中索引字段一致。<br>    而且在使用order by时要进量使用覆盖索引，因为不使用覆盖索引进行排序会发生文件内排序。或者在java中进行排序。<br>5.不要在使用like查找索引字段时在字段前面加%。<br>    这是因为字符串在b+树里存储的时候，是按照ascii码的大小存储的，此时，这个结构与复合索引结构是一样的，当为字符串增加前缀时，违反了最左前缀法则。</p>
<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><table>
<thead>
<tr>
<th>指令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>set autocommit = 0</td>
<td>设为手动提交事务</td>
</tr>
<tr>
<td>start transaction</td>
<td>开始事务</td>
</tr>
<tr>
<td>savepoint 点名</td>
<td>设置保存点</td>
</tr>
<tr>
<td>rollback to 点名</td>
<td>回滚</td>
</tr>
<tr>
<td>rollback</td>
<td>回滚至开始</td>
</tr>
<tr>
<td>commit</td>
<td>提交事务</td>
</tr>
</tbody></table>
<h2 id="四种隔离级别"><a href="#四种隔离级别" class="headerlink" title="四种隔离级别"></a>四种隔离级别</h2><p>脏读:一个事务读到了另一个事务未提交的的修改。<br>不可重复读:一个事务多次查询，由于其他事务的修改和删除导致每次读取内容不同。<br>幻读:一个事务多次查询，由于其他事务的插入操作导致每次读取内容不同。<br>不可重复读可以通过对数据的加锁解决，但幻读需要在数据间加间隙锁才能解决。</p>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
<th>加锁</th>
</tr>
</thead>
<tbody><tr>
<td>read uncommitted：可以读到未提交的其他事务</td>
<td>V</td>
<td>V</td>
<td>V</td>
<td>X</td>
</tr>
<tr>
<td>read committed：可以读到已经提交的其他事务</td>
<td>X</td>
<td>V</td>
<td>V</td>
<td>X</td>
</tr>
<tr>
<td>repeatable read：只能读到开启事务前的数据</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
</tr>
<tr>
<td>serializable:可串行化</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>V</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>指令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>set session transaction isolation level 隔离级别</td>
<td>设置隔离级别</td>
</tr>
<tr>
<td>set global transaction isolation level 隔离级别</td>
<td>设置系统隔离级别</td>
</tr>
<tr>
<td>select @@tx_isolation</td>
<td>查看当前会话隔离级别</td>
</tr>
<tr>
<td>select @@global.tx_isolation</td>
<td></td>
</tr>
</tbody></table>
<h1 id="引擎"><a href="#引擎" class="headerlink" title="引擎"></a>引擎</h1><table>
<thead>
<tr>
<th>特点</th>
<th>myisam</th>
<th>innodb</th>
<th>memory</th>
</tr>
</thead>
<tbody><tr>
<td>批量插入速度</td>
<td>高</td>
<td>低</td>
<td>高(内存存储)</td>
</tr>
<tr>
<td>事务安全</td>
<td></td>
<td>支持</td>
<td></td>
</tr>
<tr>
<td>全文索引</td>
<td>支持</td>
<td></td>
<td></td>
</tr>
<tr>
<td>锁机制</td>
<td>表锁</td>
<td>行锁</td>
<td>表锁</td>
</tr>
<tr>
<td>存储限制</td>
<td>无</td>
<td>64TB</td>
<td>有</td>
</tr>
</tbody></table>
<p>1.myisam不支持事务，也不支持外键，但其访问速度快，对事务完整性没要求。<br>2.innodb为事务安全型引擎。但是比起myisam，innodb写的效率会差，且要占用空间保留索引。<br>3.memory引擎基于hash存储在内存中，访问速度快，但一旦服务关闭，数据就会丢失，表的结构还在。</p>
<p>当innodb的索引失效时，这时没有索引导致无法再使用行锁，会自动升级为表锁，大大降低并发度。<br>行锁：锁力度小，开销大，上锁速度慢，会出现死锁，并发高。<br>表锁：锁力度大，开销小，上锁速度快，不会出现死锁，并发低。</p>
]]></content>
      <categories>
        <category>MySQL笔记</category>
      </categories>
  </entry>
  <entry>
    <title>简化路径</title>
    <url>/2021/12/03/%E7%AE%80%E5%8C%96%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给你一个路径，这个路径可以被解析，请你简化路径。</p>
<span id="more"></span>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>这道题要处理三种情况，多余的”/“，”.”和”..”的处理。首先使用split方法将字符串拆分，可以消除全部的”/“，且多余的会转化为空字符串。”.”可以直接去除，”..”要返回上一级。在这里可以利用一个双端队列，先把它作为一个栈使用，遇到”.”和””不入栈，遇到”..”弹栈，遇到其他字符串入栈，这样全部处理结束后就是简化后的路径，再从头部依次取出。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public String simplifyPath(String path) &#123;</span><br><span class="line">        String[] split = path.split(&quot;/&quot;);</span><br><span class="line">        ArrayDeque&lt;String&gt; stack = new ArrayDeque&lt;&gt;();</span><br><span class="line">        for (String s:split)&#123;</span><br><span class="line">            if (s.equals(&quot;..&quot;))&#123;</span><br><span class="line">                stack.pollLast();</span><br><span class="line">            &#125;else if (s.equals(&quot;.&quot;)||s.equals(&quot;&quot;))&#123;</span><br><span class="line"></span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                stack.offerLast(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        String answer = new String();</span><br><span class="line">        while (!stack.isEmpty())&#123;</span><br><span class="line">            answer+=&quot;/&quot;;</span><br><span class="line">            answer+=stack.pollFirst();</span><br><span class="line">        &#125;</span><br><span class="line">        if (answer.length()==0)&#123;</span><br><span class="line">            return &quot;/&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        return answer;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode解析</category>
        <category>中等</category>
      </categories>
      <tags>
        <tag>双端队列</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>编辑距离</title>
    <url>/2021/12/03/%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/</url>
    <content><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>给你两个单词word1和word2，请你计算出将word1转换成word2所使用的最少操作数。<br>你可以对一个单词进行如下三种操作：<br>插入一个字符<br>删除一个字符<br>替换一个字符</p>
<span id="more"></span>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>使用动态规划，首先假设a，b两个字符串已经匹配结束。那么当a长度增加时，使用删除，操作+1。当b长度增加时，使用插入，操作+1。当a，b都增加时如果这两个字符相同，不需要操作，如果这两个字符不同时只需要替换其中一个，操作+1。<br>就有dp[i][j] = min(dp[i-1][j]+1,dp[i][j-1]+1,dp[i-1][j-1]+(1))。<br>在a，b字符串加空字符，方便对第一行与第一列进行初始化。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int minDistance(String word1, String word2) &#123;</span><br><span class="line">        int[][] dp = new int[word1.length() + 1][word2.length() + 1];</span><br><span class="line">        char[] chars1 = word1.toCharArray();</span><br><span class="line">        char[] chars2 = word2.toCharArray();</span><br><span class="line">        for (int i = 0;i&lt;word1.length()+1;i++)&#123;</span><br><span class="line">            dp[i][0]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 1;i&lt;word2.length()+1;i++)&#123;</span><br><span class="line">            dp[0][i]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 1;i&lt;word1.length()+1;i++)&#123;</span><br><span class="line">            for (int j = 1;j&lt;word2.length()+1;j++)&#123;</span><br><span class="line">                dp[i][j] = Math.min(dp[i-1][j]+1,dp[i][j-1]+1);</span><br><span class="line">                if (chars1[i-1]==chars2[j-1])&#123;</span><br><span class="line">                    dp[i][j] = Math.min(dp[i][j],dp[i-1][j-1]);</span><br><span class="line">                &#125;else &#123;</span><br><span class="line">                    dp[i][j] = Math.min(dp[i][j],dp[i-1][j-1]+1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[word1.length()][word2.length()];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode解析</category>
        <category>困难</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>从二叉树一个节点到另一个节点每一步的方向</title>
    <url>/2021/12/05/%E4%BB%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9%E5%88%B0%E5%8F%A6%E4%B8%80%E4%B8%AA/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给你一棵 二叉树的根节点root，这棵二叉树总共有n个节点。每个节点的值为1到n中的一个整数，且互不相同。给你一个整数startValue，表示起点节点 s的值，和另一个不同的整数destValue，表示终点节点t的值。<br>请找到从节点s到节点 t的 最短路径，并以字符串的形式返回每一步的方向。每一步用 大写字母’L’，’R’和’U’分别表示一种方向：<br>‘L’表示从一个节点前往它的 左孩子节点。<br>‘R’表示从一个节点前往它的 右孩子节点。<br>‘U’表示从一个节点前往它的 父节点。<br>请你返回从 s到 t最短路径每一步的方向。</p>
<span id="more"></span>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>这道题可以使用dfs对两个目标节点检索，检索的同时记录好路径。检索完毕后处理两个路径，首先把他们相同的首部分去除，这样就找到了他们相同的根节点，接着对第一条路径处理，把所有字符替换为U，两个字符串加和就是答案。但对java而言，因为这道题会给超大型树且有时间要求，必须对算法进行优化，因为String是final类型数据，每次加和字符串时就会在常量池重新创建新的字符串，所以要使用StringBuffer来对整个算法进行优化，使得不再超时。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">StringBuffer path;</span><br><span class="line">   StringBuffer path1;</span><br><span class="line">   public String get<span class="constructor">Directions(TreeNode <span class="params">root</span>, <span class="params">int</span> <span class="params">startValue</span>, <span class="params">int</span> <span class="params">destValue</span>)</span> &#123;</span><br><span class="line">       String anwer1;</span><br><span class="line">       String anwer2;</span><br><span class="line">       path = <span class="keyword">new</span> <span class="constructor">StringBuffer()</span>;</span><br><span class="line">       tree<span class="constructor">Search(<span class="params">root</span>,<span class="params">startValue</span>)</span>;</span><br><span class="line">       anwer1 = path1.<span class="keyword">to</span><span class="constructor">String()</span>;</span><br><span class="line">       tree<span class="constructor">Search(<span class="params">root</span>,<span class="params">destValue</span>)</span>;</span><br><span class="line">       anwer2 = path1.<span class="keyword">to</span><span class="constructor">String()</span>;</span><br><span class="line">       <span class="built_in">char</span><span class="literal">[]</span> chars1 = anwer1.<span class="keyword">to</span><span class="constructor">CharArray()</span>;</span><br><span class="line">       <span class="built_in">char</span><span class="literal">[]</span> chars2 = anwer2.<span class="keyword">to</span><span class="constructor">CharArray()</span>;</span><br><span class="line">       <span class="built_in">int</span> i =<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">while</span> (i&lt;chars1.length&amp;&amp;i&lt;chars2.length&amp;&amp;chars1<span class="literal">[<span class="identifier">i</span>]</span>==chars2<span class="literal">[<span class="identifier">i</span>]</span>)&#123;</span><br><span class="line">           i++;</span><br><span class="line">       &#125;</span><br><span class="line">       StringBuffer str1 = <span class="keyword">new</span> <span class="constructor">StringBuffer()</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="built_in">int</span> j = chars1.length-i;j&gt;<span class="number">0</span>;j--)&#123;</span><br><span class="line">           str1.append(<span class="character">&#x27;U&#x27;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       String str2 = anwer2.substring(i,anwer2.length<span class="literal">()</span>);</span><br><span class="line">       return str1+str2;</span><br><span class="line">   &#125;</span><br><span class="line">   public void tree<span class="constructor">Search(TreeNode <span class="params">root</span>,<span class="params">int</span> <span class="params">value</span>)</span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (root!=null)&#123;</span><br><span class="line">           <span class="keyword">if</span> (root.<span class="keyword">val</span>!=value)&#123;</span><br><span class="line">               path.append(<span class="character">&#x27;L&#x27;</span>);</span><br><span class="line">             tree<span class="constructor">Search(<span class="params">root</span>.<span class="params">left</span>,<span class="params">value</span>)</span>;</span><br><span class="line">             path.delete<span class="constructor">CharAt(<span class="params">path</span>.<span class="params">length</span>()</span>-<span class="number">1</span>);</span><br><span class="line">             path.append(<span class="character">&#x27;R&#x27;</span>);</span><br><span class="line">             tree<span class="constructor">Search(<span class="params">root</span>.<span class="params">right</span>,<span class="params">value</span>)</span>;</span><br><span class="line">             path.delete<span class="constructor">CharAt(<span class="params">path</span>.<span class="params">length</span>()</span>-<span class="number">1</span>);</span><br><span class="line">           &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">               path1 = <span class="keyword">new</span> <span class="constructor">StringBuffer(<span class="params">path</span>)</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode解析</category>
        <category>中等</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
        <tag>dfs</tag>
        <tag>StringBuffer</tag>
      </tags>
  </entry>
  <entry>
    <title>子集</title>
    <url>/2021/12/04/%E5%AD%90%E9%9B%86/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给你一个整数数组nums，数组中的元素互不相同。返回该数组所有可能的子集（幂集）。<br>解集不能包含重复的子集。你可以按任意顺序返回解集。</p>
<span id="more"></span>
<h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>这道题如果长度固定就是最普通的回溯问题，所以只要把从0-数组长度的所有数字交给回溯即可。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">List&lt;List&lt;<span class="type">Integer</span>&gt;&gt; lists;</span><br><span class="line">ArrayList&lt;<span class="type">Integer</span>&gt; list;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">public</span> List&lt;List&lt;<span class="type">Integer</span>&gt;&gt; subsets(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="type">int</span> length = nums.length;</span><br><span class="line">        lists = <span class="built_in">new</span> ArrayList&lt;List&lt;<span class="type">Integer</span>&gt;&gt;();</span><br><span class="line">        list = <span class="built_in">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i&lt;=length;i++)&#123;</span><br><span class="line">            trackBack(nums,<span class="number">0</span>,i);</span><br><span class="line">            list.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lists;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">public</span> <span class="type">void</span> trackBack(<span class="type">int</span>[] nums,<span class="type">int</span> <span class="keyword">start</span>,<span class="type">int</span> length)&#123;</span><br><span class="line">        <span class="keyword">if</span> (list.size()&lt;length)&#123;</span><br><span class="line">            <span class="keyword">for</span> (;<span class="keyword">start</span>&lt;nums.length;<span class="keyword">start</span>++)&#123;</span><br><span class="line">                list.<span class="keyword">add</span>(nums[<span class="keyword">start</span>]);</span><br><span class="line">                trackBack(nums,<span class="keyword">start</span>+<span class="number">1</span>,length);</span><br><span class="line">                list.remove(list.size()<span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            List&lt;<span class="type">Integer</span>&gt; answer = <span class="built_in">new</span> ArrayList&lt;<span class="type">Integer</span>&gt;(this.list);</span><br><span class="line">            lists.<span class="keyword">add</span>(answer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode解析</category>
        <category>中等</category>
      </categories>
      <tags>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>超级次方</title>
    <url>/2021/12/05/%E8%B6%85%E7%BA%A7%E6%AC%A1%E6%96%B9/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>你的任务是计算a^b对1337取模，a是一个正整数，b是一个非常大的正整数且会以数组形式给出。</p>
<span id="more"></span>
<h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>首先要知道在计算过程中取模再计算并不影响最后的取模结果。<br>接着需要设计一种快速计算次幂的方法，我们可以让a一直与自身相乘减少计算次数，且每次这样处理会使需要的次幂折半，而因为奇数折半会损失一次，所以要在处理前将这个数字先乘入答案。<br>然后要处理超长的b数组，转换为数字必然不可能，但可以设计一个指针指向这个数组的第一个数，将这个过程拆分。比如a的32次幂可以变成(a^3)^10*a^2。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int val = 1337;</span><br><span class="line">    public int superPow(int a, int[] b) &#123;</span><br><span class="line">        int anwer = 1;</span><br><span class="line">        a %= val;</span><br><span class="line">        for (int i = 0;i&lt; b.length;i++)&#123;</span><br><span class="line">            anwer = pow(anwer,10)%val;</span><br><span class="line">            anwer = anwer*pow(a,b[i])%val;</span><br><span class="line">        &#125;</span><br><span class="line">        return anwer;</span><br><span class="line">    &#125;</span><br><span class="line">    public int pow(int a,int n)&#123;</span><br><span class="line">        int answer = 1;</span><br><span class="line">        //a每乘自己一次，所要的次幂就除以2，如果是奇数，因为5/2=2，所以要先把这个数乘进answer</span><br><span class="line">        for (int i = n;i&gt;0;i /=2)&#123;</span><br><span class="line">          if (i &gt;&gt; 1 &lt;&lt; 1 != i)&#123;</span><br><span class="line">              answer = a*answer%val;</span><br><span class="line">          &#125;</span><br><span class="line">          a = a*a%val;</span><br><span class="line">        &#125;</span><br><span class="line">        return answer;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode解析</category>
        <category>中等</category>
      </categories>
  </entry>
  <entry>
    <title>删除有序数组中的重复项</title>
    <url>/2021/12/06/%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给你一个有序数组nums ，请你原地删除重复出现的元素，使每个元素最多出现两次，返回删除后数组的新长度。<br>不要使用额外的数组空间，你必须在原地修改输入数组并在使用O(1)额外空间的条件下完成。</p>
<span id="more"></span>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>可以设计两个指针，慢指针指向填入的位置，快指针一直遍历，如果快指针的数字不是第三个数字，则放入，接着移动慢指针。<br>nums[slow-2]！=nums[fast]则说明这个数可以填入。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int removeDuplicates(int[] nums) &#123;</span><br><span class="line">        int slow = 2;</span><br><span class="line">        int fast = 2;</span><br><span class="line">        for (;fast&lt;nums.length&amp;&amp;slow&lt;nums.length;fast++)&#123;</span><br><span class="line">        	if(nums[slow-2]!= nums[fast])&#123;</span><br><span class="line">        		nums[slow] = nums [fast];</span><br><span class="line">        		slow++;</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;    </span><br><span class="line">        return slow;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode解析</category>
        <category>中等</category>
      </categories>
      <tags>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>单词搜索</title>
    <url>/2021/12/06/%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定一个mxn二维字符网格board和一个字符串单词word。如果word存在于网格中，返回true；否则，返回 false 。<br>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p>
<span id="more"></span>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>这道题看后就知道应该是一个回溯和dfs，但重点在于如何剪枝以及不再走重复的格子。这里在dfs的开始进行剪枝，使用回溯对棋盘染色，确保不走重复路径。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int m;</span><br><span class="line">   int n;</span><br><span class="line">   char[][] board;</span><br><span class="line">   String word;</span><br><span class="line">   int length;</span><br><span class="line">   public boolean exist(char[][] board, String word) &#123;</span><br><span class="line">       this.m = board.length;</span><br><span class="line">       this.n = board[0].length;</span><br><span class="line">       this.board = board;</span><br><span class="line">       this.word = word;</span><br><span class="line">       length = word.length();</span><br><span class="line">       //找到字符串的开始</span><br><span class="line">       for (int i = 0;i&lt;m;i++)&#123;</span><br><span class="line">           for (int j = 0; j&lt; n;j++)&#123;</span><br><span class="line">               if (board[i][j]==word.charAt(0))&#123;</span><br><span class="line">                   if (dfs(i,j,0))&#123;</span><br><span class="line">                       return true;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return false;</span><br><span class="line">   &#125;</span><br><span class="line">   public boolean dfs(int i,int j,int length)&#123;</span><br><span class="line">       //判断是否检索完毕</span><br><span class="line">       if (length == this.length)&#123;</span><br><span class="line">           return true;</span><br><span class="line">       //判断数组是否越界</span><br><span class="line">       &#125;else if (i&lt;0||i&gt;=m||j&lt;0||j&gt;=n)&#123;</span><br><span class="line">           return false;</span><br><span class="line">       //判断字符是否合格</span><br><span class="line">       &#125;else if (board[i][j]==word.charAt(length))&#123;</span><br><span class="line">           //这里采用回溯思想，对走过的路进行染色，如果失败，则还原</span><br><span class="line">           char count = board[i][j];</span><br><span class="line">           board[i][j] = &#x27;*&#x27;;</span><br><span class="line">           length++;</span><br><span class="line">           boolean res = dfs(i-1,j,length)||dfs(i+1,j,length)||dfs(i,j-1,length)||dfs(i,j+1,length);</span><br><span class="line">           board[i][j] = count;</span><br><span class="line">           return res;</span><br><span class="line">       &#125;else &#123;</span><br><span class="line">           return false;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode解析</category>
        <category>中等</category>
      </categories>
      <tags>
        <tag>回溯</tag>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title>mySQL题目</title>
    <url>/2021/12/07/mySQL%E9%A2%98%E7%9B%AE/</url>
    <content><![CDATA[<h1 id="InnoDB-和-MyIsam-引擎的区别？"><a href="#InnoDB-和-MyIsam-引擎的区别？" class="headerlink" title="InnoDB 和 MyIsam 引擎的区别？"></a>InnoDB 和 MyIsam 引擎的区别？</h1><span id="more"></span>
<p>1.InnoDB支持事务，MyIsam不支持事务。<br>2.InnoDB支持外键，MyIsam不支持。<br>3.InnoDB是聚簇索引，MyIsam是非聚簇索引。<br>4.InnoDB不支持全文索引但能拿插件实现且效果更好，MyIsam支持全文索引。<br>5.InnoDB最小锁粒度是行锁，MyIsam最小锁粒度是表锁。</p>
<h1 id="聚簇索引和非聚簇索引"><a href="#聚簇索引和非聚簇索引" class="headerlink" title="聚簇索引和非聚簇索引"></a>聚簇索引和非聚簇索引</h1><p>聚簇索引：数据与索引一体，表数据的顺序与索引顺序一致。<br>    聚簇索引默认是主键，如果表中没有主键，InnoDB会选择一个唯一非空索引代替。<br>    如果没有这样的索引InnoDB会在内部生成一个隐式索引。<br>非聚簇索引：数据与索引分开存放，表数据顺序与索引顺序无关。</p>
<h1 id="行锁与表锁的比较"><a href="#行锁与表锁的比较" class="headerlink" title="行锁与表锁的比较"></a>行锁与表锁的比较</h1><p>行锁：锁力度小，开销大，上锁速度慢，会出现死锁，并发高。<br>表锁：锁力度大，开销小，上锁速度快，不会出现死锁，并发低。</p>
<h1 id="mySQL索引的最左原则"><a href="#mySQL索引的最左原则" class="headerlink" title="mySQL索引的最左原则"></a>mySQL索引的最左原则</h1><p>当使用复合索引时，进行检索时，要使用索引建立的顺序且不可中断，一旦违反这个原则，索引就会失效。<br>这事因为在b+树中存储时，优先级是字段左到右的顺序，一旦不使用前面的字段，后面的字段就会无序。</p>
<h1 id="索引的优化"><a href="#索引的优化" class="headerlink" title="索引的优化"></a>索引的优化</h1><p>1.最左前缀法则<br>2.不要对索引进行计算，函数以及转型，会导致索引失效。<br>3.不可以在范围查找语句右边使用索引，会导致索引失效。<br>4.减少select* 的使用，尽量进行覆盖索引，即select查询字段与where中索引字段一致。<br>5.不要在使用like查找索引字段时在字段前面加%。</p>
<h1 id="为什么范围查找会导致索引失效"><a href="#为什么范围查找会导致索引失效" class="headerlink" title="为什么范围查找会导致索引失效"></a>为什么范围查找会导致索引失效</h1><p>因为b+树的叶节点是是一个有序链表，当进行范围查找时会会把整段链表直接取出等待下一步查找，这种情况下，除非取出的这整一段的范围查找的字段都相等，否则下一个字段一定是乱序的。</p>
<h1 id="为什么在like中添加前缀会导致索引失效"><a href="#为什么在like中添加前缀会导致索引失效" class="headerlink" title="为什么在like中添加前缀会导致索引失效"></a>为什么在like中添加前缀会导致索引失效</h1><p>这是因为字符串在b+树里存储的时候，是按照ascii码的大小存储的，此时，这个结构与复合索引结构是一样的，当为字符串增加前缀时，违反了最左前缀法则。</p>
<h1 id="使用order-by查询时如何优化速度"><a href="#使用order-by查询时如何优化速度" class="headerlink" title="使用order by查询时如何优化速度"></a>使用order by查询时如何优化速度</h1><p>使用order by时要进量使用覆盖索引，因为不使用覆盖索引进行排序会发生文件内排序。或者在java中进行排序。</p>
<h1 id="什么是慢查询，如何定位"><a href="#什么是慢查询，如何定位" class="headerlink" title="什么是慢查询，如何定位"></a>什么是慢查询，如何定位</h1><p>记录所有执行时间超过一个限度的查询和不适用索引的查询到慢查询日志，以待分析处理。<br>根据SHOW VARIABLES LIKE ‘%query%’语句查询文件路径。</p>
]]></content>
      <categories>
        <category>面试题</category>
        <category>javase题目</category>
      </categories>
  </entry>
  <entry>
    <title>柱状图中最大的矩形</title>
    <url>/2021/12/08/%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定n个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为1 。<br>求在该柱状图中，能够勾勒出来的矩形的最大面积。<br><img src="/images/histogram.jpg" alt="histogram"></p>
<span id="more"></span>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>首先考虑如何获得所有可能的最大面积，我们要做的就是在限制的高度下尽可能的向两边延伸直到遇到边界或者比限制高度还低。有了这个思路首先对数组两边各加一个0使得遇到边界问题也转化为比限制高度低的问题。求取可能的最大面积需要知道的是限制高度以及左右两边比它低的数字，当找到这些时，这个高度的最大面积也就知道了。<br>所以我们要在遍历数组时，当出现比目标数小的数字时要取得这个数，且取得目标数，再取得前面第一个比这个数小的数。此时我们就能使用单调栈来存储这些数据。当数据递增时说明还未找到最大情况，通过查看栈顶数来看最大值，一旦出现比这个数小的数，说明栈顶的最大数到这个数为止的数都找到了最大情况，进行弹栈，弹出的为目标数，准备入栈的数和新栈顶为两边。所以在入栈时要存储这个数的大小以及它的位置。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int largestRectangleArea(int[] heights) &#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();</span><br><span class="line">        int[] ints = new int[heights.length + 2];</span><br><span class="line">        for (int i = 0;i&lt;heights.length;i++)&#123;</span><br><span class="line">            ints[i+1] = heights[i];</span><br><span class="line">        &#125;</span><br><span class="line">        int max = 0;</span><br><span class="line">        int area = 0;</span><br><span class="line">        stack.add(0);</span><br><span class="line">        for (int i =1;i&lt;ints.length;i++)&#123;</span><br><span class="line">            int top = stack.peek();</span><br><span class="line">                //弹出所有比入栈数大的数</span><br><span class="line">                while (ints[i]&lt;ints[top])&#123;</span><br><span class="line">                    stack.pop();</span><br><span class="line">                    area = ints[top]*(i-stack.peek()-1);</span><br><span class="line">                    max = Math.max(area,max);</span><br><span class="line">                    top = stack.peek();</span><br><span class="line">                &#125;</span><br><span class="line">                //正常入栈</span><br><span class="line">                stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        return max;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode解析</category>
        <category>困难</category>
      </categories>
      <tags>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title>最大矩形</title>
    <url>/2021/12/09/%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定一个仅包含0和1、大小为rows x cols的二维二进制矩阵，找出只包含1的最大矩形，并返回其面积</p>
<p><img src="/images/%7DL%5DEJQ98UFV6O%259%5BXGIAH8Q.png" alt="图片"></p>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>我们可以对这个数组进行一个处理,把它转化成i个柱状图中最大矩形的问题.如图:<br><img src="/images/C39A31043170653A36EB2B610DEAA37C.png" alt="图片"></p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int maximalRectangle(char[][] matrix) &#123;</span><br><span class="line">        //可以每行都看作一个柱状图最大矩形的问题</span><br><span class="line">        int[][] grap = new int[matrix.length][matrix[0].length];</span><br><span class="line">        for (int i=matrix.length-1;i&gt;=0;i--)&#123;</span><br><span class="line">            for (int j = 0;j&lt;matrix[0].length;j++)&#123;</span><br><span class="line">                if (matrix[i][j]==&#x27;1&#x27;)&#123;</span><br><span class="line">                    grap[i][j]++;</span><br><span class="line">                    int k = 1;</span><br><span class="line">                    while (i-k&gt;=0&amp;&amp;matrix[i-k][j]==&#x27;1&#x27;)&#123;</span><br><span class="line">                        k++;</span><br><span class="line">                        grap[i][j]++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int max = 0;</span><br><span class="line">        for (int[] o:grap)&#123;</span><br><span class="line">            max=Math.max(max,largestRectangleArea(o));</span><br><span class="line">        &#125;</span><br><span class="line">        return max;</span><br><span class="line">    &#125;</span><br><span class="line">    //柱状图最大矩形问题</span><br><span class="line">    public int largestRectangleArea(int[] heights) &#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();</span><br><span class="line">        int[] ints = new int[heights.length + 2];</span><br><span class="line">        for (int i = 0;i&lt;heights.length;i++)&#123;</span><br><span class="line">            ints[i+1] = heights[i];</span><br><span class="line">        &#125;</span><br><span class="line">        int max = 0;</span><br><span class="line">        int area = 0;</span><br><span class="line">        stack.add(0);</span><br><span class="line">        for (int i =1;i&lt;ints.length;i++)&#123;</span><br><span class="line">            int top = stack.peek();</span><br><span class="line">                //弹出所有比入栈数大的数</span><br><span class="line">                while (ints[i]&lt;ints[top])&#123;</span><br><span class="line">                    stack.pop();</span><br><span class="line">                    area = ints[top]*(i-stack.peek()-1);</span><br><span class="line">                    max = Math.max(area,max);</span><br><span class="line">                    top = stack.peek();</span><br><span class="line">                &#125;</span><br><span class="line">                //正常入栈</span><br><span class="line">                stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        return max;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode解析</category>
        <category>困难</category>
      </categories>
      <tags>
        <tag>单调栈</tag>
      </tags>
  </entry>
</search>
