<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>JDBC</title>
    <url>/2021/11/21/JDBC/</url>
    <content><![CDATA[<h1 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h1><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">//前置工作，在项目下创建一个文件夹，将mysql.jar文件拷贝到该目录下</span><br><span class="line">      //点击<span class="keyword">add</span> <span class="keyword">to</span> project加入到项目中。实现driver的抽象类。</span><br><span class="line">      // <span class="number">1</span>注册驱动</span><br><span class="line">      Driver driver = <span class="built_in">new</span> Driver();</span><br><span class="line">      //<span class="number">2</span>得到连接,mysql连接本质是socket连接</span><br><span class="line">      String url = &quot;jdbc:mysql://主机ip:端口/数据库名&quot;;</span><br><span class="line">      Properties properties = <span class="built_in">new</span> Properties();</span><br><span class="line">      properties.setProperty(&quot;user&quot;,&quot;用户名&quot;);</span><br><span class="line">      properties.setProperty(&quot;password&quot;,&quot;密码&quot;);</span><br><span class="line">      <span class="keyword">Connection</span> <span class="keyword">connect</span> = driver.<span class="keyword">connect</span>(url, properties);//这个<span class="keyword">connect</span>等同于socket</span><br><span class="line">      //<span class="number">3</span>执行<span class="keyword">sql</span></span><br><span class="line">      String <span class="keyword">sql</span> = &quot;要执行的sql语句&quot;;</span><br><span class="line">      //生成语法的执行器,返回值为更改的行数</span><br><span class="line">      <span class="keyword">Statement</span> <span class="keyword">statement</span> = <span class="keyword">connect</span>.createStatement();</span><br><span class="line">      <span class="type">int</span> <span class="keyword">rows</span> = <span class="keyword">statement</span>.executeUpdate(<span class="keyword">sql</span>);//只能存放dlm语句，<span class="keyword">select</span>用Query</span><br><span class="line">      //关闭连接资源</span><br><span class="line">      <span class="keyword">statement</span>.<span class="keyword">close</span>();</span><br><span class="line">      <span class="keyword">connect</span>.<span class="keyword">close</span>();</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h1 id="数据库连接方式"><a href="#数据库连接方式" class="headerlink" title="数据库连接方式"></a>数据库连接方式</h1><p>上面的方法可以连接数据库，但问题是这是一个静态加载，灵活性差，依赖性强。<br>可以使用反射机制取得driver，实现静态加载。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">        Class clazz = <span class="module-access"><span class="module"><span class="identifier">Class</span>.</span></span><span class="keyword">for</span><span class="constructor">Name(<span class="string">&quot;驱动路径&quot;</span>)</span>;</span><br><span class="line"><span class="comment">//下面这句话是可以不写的，在dirver中有一段静态代码，只要类加载后，会自动帮助注册驱动</span></span><br><span class="line">        Driver dirver = (Dirver)clazz.<span class="keyword">new</span><span class="constructor">Instance()</span>;</span><br></pre></td></tr></table></figure>
<p>还可以使用drivermanager来获取connect，但这个方法是静态同步调用，会造成低效率和死锁，不再展开。</p>
<h2 id="最常用的数据库连接方式："><a href="#最常用的数据库连接方式：" class="headerlink" title="最常用的数据库连接方式："></a>最常用的数据库连接方式：</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//mysql驱动5.1.6后这句类加载也可以省略，会自动调用。建议写上，防止多个驱动存在。</span><br><span class="line">//最省略的写法就是只要将驱动放入项目中，然后直接取得connection即可。</span><br><span class="line">Class clazz = Class.forName(&quot;驱动路径&quot;);</span><br><span class="line">//这里可以直接将这些信息存储到properties文件中，通过IO流取出。</span><br><span class="line">//new properties;</span><br><span class="line">//properties.load(new FileInpitStream(文件路径));</span><br><span class="line">String url = &quot;jdbc:mysql://主机ip:端口/数据库名&quot;;</span><br><span class="line">String user = </span><br><span class="line">String password = </span><br><span class="line">Connection connect = Drivermanager.getConnection(url,user,password);</span><br></pre></td></tr></table></figure>
<h1 id="ResultSet"><a href="#ResultSet" class="headerlink" title="ResultSet"></a>ResultSet</h1><p>在执行select语句后，会返回一个类似于迭代器的resultset。</p>
<figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ResultSet</span> <span class="keyword">resultset</span> = statement.executeQuery(<span class="string">&quot;查询语句&quot;</span>);</span><br><span class="line"><span class="comment">//next为向下移动，还可以使用previous向上移动</span></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">resultset</span>.next())&#123;</span><br><span class="line">        <span class="comment">//get方法中既可以填写索引，也可以填写列名。</span></span><br><span class="line">    int id = <span class="keyword">resultset</span>.getInt(<span class="number">1</span>);<span class="comment">//取出第一列，取出类型为int</span></span><br><span class="line">    <span class="params">...</span><span class="params">...</span></span><br><span class="line">&#125;</span><br><span class="line">resulset.close;</span><br><span class="line">statement.close();</span><br><span class="line">connect.close();</span><br></pre></td></tr></table></figure>
<h1 id="Statement"><a href="#Statement" class="headerlink" title="Statement"></a>Statement</h1><h2 id="执行SQl语句的三种渠道："><a href="#执行SQl语句的三种渠道：" class="headerlink" title="执行SQl语句的三种渠道："></a>执行SQl语句的三种渠道：</h2><p>1.Statement[存在SQl注入风险(注入非法的SQL语句攻击数据库)，一般不使用]。<br>2.PreparedStatement[预处理]。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">//PreparedStatement的使用方式</span></span><br><span class="line">String sql = <span class="string">&quot;select name, pwd from admin where name = ? and pwd = ?&quot;</span><span class="comment">//?相当于占位符</span></span><br><span class="line"><span class="comment">//preparedStatement有别于Statement，在创建时就要输入sql语句</span></span><br><span class="line">PreparedStatement preparedStatement = connection.prepared<span class="constructor">Statement(<span class="params">sql</span>)</span>;</span><br><span class="line">preparedStatement.set<span class="constructor">String(1,<span class="params">admin_name</span>)</span>;<span class="comment">//对应问号的位置，admin_name中存储接收的用户名</span></span><br><span class="line">preparedStatement.set<span class="constructor">String(2,<span class="params">admin_pwd</span>)</span>;</span><br><span class="line">ResultSet resultset = preparedStatement.execute<span class="constructor">Query()</span>;</span><br></pre></td></tr></table></figure>
<p>3.CallableStatement[存储过程]。</p>
<h2 id="Statement接口"><a href="#Statement接口" class="headerlink" title="Statement接口"></a>Statement接口</h2><p>executeUpdate(sql)执行dml语句，返回影响的行数。<br>executeQuery(sql)执行查询，返回ResultSet。<br>execute(sql)执行任意语句，返回布尔值，用于不需要返回行数或者结果集的语句。</p>
<h1 id="JDBCUtils的开发"><a href="#JDBCUtils的开发" class="headerlink" title="JDBCUtils的开发"></a>JDBCUtils的开发</h1><p>因为在JDBC过程中，数据库的连接和释放资源属于高重复度内容，因此一般将这些内容进行封装。</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDBCUtils</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">String</span> user;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">String</span> password;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">String</span> url;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">String</span> driver;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用静态代码块初始化</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Properties properties = <span class="keyword">new</span> <span class="type">Properties</span>();</span><br><span class="line">            properties.load(<span class="keyword">new</span> <span class="type">FileInputStream</span>(<span class="string">&quot;文件路径&quot;</span>));</span><br><span class="line">            user = properties.getProperty(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">            password = properties.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">            url = properties.getProperty(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">            driver = properties.getProperty(<span class="string">&quot;driver&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">//1.将编译异常转化为运行异常</span></span><br><span class="line">            <span class="comment">//2.调用者可以选择捕获改异常，也可以选择默认操作</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//连接数据库</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Connection getConnection()&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> DriverManager.getConnection(url,user,password);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//关闭资源</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> void close(ResultSet resultSet, Statement statement, Connection connection)&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (resultSet != <span class="literal">null</span>)&#123;</span><br><span class="line">                resultSet.close();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (statement != <span class="literal">null</span>)&#123;</span><br><span class="line">                statement.close();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (connection != <span class="literal">null</span>)&#123;</span><br><span class="line">                connection.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>首先要调用Connection.setAutoCommit(false),取消自动提交事务。<br>然后再使用Connection.commit()手动提交，使用Connection.rollback回滚事务(一般写在catch中)。</p>
<h1 id="批处理"><a href="#批处理" class="headerlink" title="批处理"></a>批处理</h1><p>启用批处理需要修改url语句。<br>String url = “jdbc:mysql://主机ip:端口/数据库名？rewriteBatchedStatements = true”;<br>preparedStatement.addBatch();将sql语句加入到集合中。<br>preparedStatement.executeBatch();批量执行sql语句。<br>preparedStatement.clearBatch();清空集合。</p>
<h1 id="传统连接方式的弊端"><a href="#传统连接方式的弊端" class="headerlink" title="传统连接方式的弊端"></a>传统连接方式的弊端</h1><p>1.每次向数据库建立连接时都要加载connection，再验证。<br>2.如果程序异常没能正常关闭会导致内存泄露。<br>3.不能控制创建的连接数量，连接过多会导致数据库崩溃。</p>
<h1 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h1><p>给定规定的连接口，所有连接接入走连接池，并排队，由连接池统一管理。<br>实现DataSource接口。</p>
<h2 id="C3P0"><a href="#C3P0" class="headerlink" title="C3P0"></a>C3P0</h2><p>类名：ComboPooledDataSource</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//给予连接池需要的信息，让连接池创建接向数据库的连接</span><br><span class="line">new ComboPooledDataSource();</span><br><span class="line">comboPooledDataSource.setDriverClass(驱动路径);</span><br><span class="line">comboPooledDataSource.setJdbcUrl(url);</span><br><span class="line">comboPooledDataSource.setUser(user);</span><br><span class="line">comboPooledDataSource.setPassword(password);</span><br><span class="line">//设置连接池的初始连接数和最大连接数</span><br><span class="line">comboPooledDataSource.setInitialPoolSize(int);</span><br><span class="line">comboPooledDataSource.setMaxPoolSize(int);</span><br><span class="line">//从连接池取得连接,注意这里的connection不是由DriverManager创建的，所以close方法也不同。</span><br><span class="line">Connection connection = comboPooledDataSource.getConnection();</span><br><span class="line">//这里的关闭并不是关闭了连接，而是把连接还给了连接池</span><br><span class="line">connection.close();</span><br></pre></td></tr></table></figure>
<p>除了上面这种连接方式，还可以将这些信息统一写在c3p0的config文件中，初始化时直接使用。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="constructor">ComboPooledDataSource(<span class="params">cofig</span>文件的数据源名称)</span>;</span><br></pre></td></tr></table></figure>
<h2 id="Druid-负责建立连接"><a href="#Druid-负责建立连接" class="headerlink" title="Druid(负责建立连接)"></a>Druid(负责建立连接)</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Properties properties = new Properties();</span><br><span class="line">properties.load(new FileInputStream(&quot;德鲁伊需要的配置文件&quot;));</span><br><span class="line">DataSource dataSource = DruidDataSourceFactory.createDataSource(properties);</span><br><span class="line">Connection connection = dataSource.getConnection();</span><br><span class="line">connection.close();</span><br></pre></td></tr></table></figure>
<p>这之后就可以基于druid重写JDBCUtils。</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="keyword">class</span> JDBCUtilsByDruid&#123;</span><br><span class="line">    private static DataSource dataSource;</span><br><span class="line">    static &#123;</span><br><span class="line">        Properties properties = <span class="built_in">new</span> Properties();</span><br><span class="line">        try &#123;</span><br><span class="line">            properties.<span class="keyword">load</span>(<span class="built_in">new</span> FileInputStream(&quot;配置文件&quot;));</span><br><span class="line">            dataSource = DruidDataSourceFactory.createDataSource(properties);</span><br><span class="line">        &#125; catch (<span class="keyword">Exception</span> e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">public</span> static <span class="keyword">Connection</span> getConnection() throws SQLException &#123;</span><br><span class="line">        <span class="keyword">return</span> dataSource.getConnection();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">public</span> static <span class="type">void</span> <span class="keyword">close</span>(ResultSet resultSet, <span class="keyword">Statement</span> <span class="keyword">statement</span>, <span class="keyword">Connection</span> <span class="keyword">connection</span>)&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            <span class="keyword">if</span> (resultSet != <span class="keyword">null</span>)&#123;</span><br><span class="line">                resultSet.<span class="keyword">close</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">statement</span> != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">statement</span>.<span class="keyword">close</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">connection</span> != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">connection</span>.<span class="keyword">close</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (SQLException e) &#123;</span><br><span class="line">            throw <span class="built_in">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="ApDBUtils-负责存储收到的信息"><a href="#ApDBUtils-负责存储收到的信息" class="headerlink" title="ApDBUtils(负责存储收到的信息)"></a>ApDBUtils(负责存储收到的信息)</h1><p>问题1：目前，当需要对resultset进行操作时，connection不能关闭，但连接池给的连接是有限的。<br>问题2：结果集只能使用一次。<br>问题3：结果集取得信息的方法并不方便。<br>解决办法：创建一个类，每行的数据创建为一个对象，使用List连接起来。<br>向项目中加入DBUtils的包</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Connection connection = JDBCUtilsByDruid.getConnection();</span><br><span class="line">QueryRunner queryRunner = new QueryRunner();</span><br><span class="line">//select</span><br><span class="line">&#123;</span><br><span class="line">    //query方法就是执行一个sql语句并返回一个包含结果集的list</span><br><span class="line">    //最后的1是指sql语句中？要赋予的值</span><br><span class="line">    //使用这个办法不需要关闭结果集，在这句话的源码中，最后会自动关闭resultset和preparedStatement。</span><br><span class="line">    List&lt;Actor&gt; list =</span><br><span class="line">            queryRunner.query(connection,sql,new BeanListHandler&lt;&gt;(Actor.class),？赋值);</span><br><span class="line">    //单行查询</span><br><span class="line">    Actor actor = queryRunner.query(connection,sql,new BeanHandler&lt;&gt;(Actor.class),？赋值);</span><br><span class="line">    //单行单列</span><br><span class="line">    Object o = queryRunner.query(connection,sql,new ScalarHandler(),？赋值);</span><br><span class="line">&#125;</span><br><span class="line">//dml语句</span><br><span class="line">&#123;</span><br><span class="line">    int affectedRow = queryRunner.update(connection,sql,？赋值);</span><br><span class="line">&#125;</span><br><span class="line">DBUtilsByDruid.close(null,null,connection);</span><br></pre></td></tr></table></figure>
<h1 id="BasicDao"><a href="#BasicDao" class="headerlink" title="BasicDao"></a>BasicDao</h1><p>目前，JDBCUtilsByDruid已经实现了对Druid的封装，但DBUtils的操作依然繁琐，所以需要将<br>这整个操作进行封装，这样整个操作就简洁起来了。为了操作方便，对每个表制作一个对应的Dao。<br>在Dao的方法开发中，并不建议使用静态方法，因为这样你不再能保证connection不被两个以上的<br>线程同时调用，造成线程混乱。<br>另外BasicDao是基于泛型制定的方法，要想静态化只能将其下所有子类做静态化。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//开发BasicDao，作为其它类的父类，子类主要负责一些额外操作和确定类型</span><br><span class="line">public class BasicDao&lt;T&gt;&#123;</span><br><span class="line">    private QueryRunner qr = new QueryRunner();</span><br><span class="line">    //开发通用的dml方法，针对任意的表</span><br><span class="line">    public int update(String sql,Object...parameters)&#123;</span><br><span class="line">        //因为建立连接需要在try—catch-finally操作中，为了在finally关闭</span><br><span class="line">        //在外面先建立connection</span><br><span class="line">        Connection connection = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            connection = JDBCUtilsByDruid.getConnection();</span><br><span class="line">            int affectedRow = qr.update(connection,sql,parameters);</span><br><span class="line">            return affectedRow;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            throw new Runnable(e);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            //因为使用了DBUtils工具，所以只需要关闭(交还)connection即可</span><br><span class="line">            connection.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //返回多行数据，针对任意的表</span><br><span class="line">    public List&lt;T&gt; queryMultiply(String sql,Class&lt;T&gt; clazz,Object... parameters)&#123;</span><br><span class="line">        Connection connection = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            connection = JDBCUtilsByDruid.getConnection();</span><br><span class="line">            List&lt;T&gt; list =</span><br><span class="line">                    qr.query(connection,sql,new BeanListHandler&lt;T&gt;(clazz),parameters);</span><br><span class="line">            return list;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            throw new RuntimeException(e);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            //因为使用了DBUtils工具，所以只需要关闭(交还)connection即可</span><br><span class="line">            connection.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //返回单行数据</span><br><span class="line">    public T querySingle(String str,Class&lt;T&gt; clazz,Object... parameters)&#123;</span><br><span class="line">        Connection connection = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            connection = JDBCUtilsByDruid.getConnection();</span><br><span class="line">            return qr.query(connection,sql,new BeanHandler&lt;T&gt;(clazz),parameters);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            throw new RuntimeException(e);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            //因为使用了DBUtils工具，所以只需要关闭(交还)connection即可</span><br><span class="line">            connection.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //返回单个数据</span><br><span class="line">    public Object queryScalar(String sql,Object... parameters)&#123;</span><br><span class="line">        Connection connection = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            connection = JDBCUtilsByDruid.getConnection();</span><br><span class="line">            return qr.query(connection,sql,new ScalarHandler(),parameters);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            throw new RuntimeException(e);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            //因为使用了DBUtils工具，所以只需要关闭(交还)connection即可</span><br><span class="line">            connection.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//使用具体表对应的类型继承BasicDao</span><br><span class="line">public class ActorDao extend BasicDao&lt;Actor&gt;&#123;</span><br><span class="line">    //这里根据业务需求写特有方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JDBC学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title>z字形变换</title>
    <url>/2021/11/22/z%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><pre><code>    将一个给定字符串s根据给定的行数numRows，以从上往下、从左到右进行Z字形排列。
    比如输入字符串为 &quot;PAYPALISHIRING&quot;行数为3时，排列如下：
    P   A   H   N
    A P L S I I G
    Y   I   R
    之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：&quot;PAHNAPLSIIGYIR&quot;。
</code></pre>
<span id="more"></span>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>寻找这种排布的规律。会发现每排字符的index与其所在行，以及总行数形成函数关系。<br>首先分析第一排：第一排的index差为2*(总行数-1)。<br>分析最后一排：与第一排规律相同。<br>其他排：每隔一个字符看与第一排的规律也相同，而相邻的字符存在关系，如第二个字符与第三个<br>字符间刚好差2*(当前行数-1)。则第一个字符与第二的字符的差就是：2*(总行数-1)-2*(当前行数-1)。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public String convert(String s, int numRows) &#123;</span><br><span class="line">        //如果长度为1，则直接返回</span><br><span class="line">        if (numRows == 1)&#123;</span><br><span class="line">            return s;</span><br><span class="line">        &#125;</span><br><span class="line">        char[] chars = s.toCharArray();</span><br><span class="line">        char[] answer = new char[chars.length];</span><br><span class="line">        int count = 0;</span><br><span class="line">        for (int i = 0;i&lt;numRows;i++)&#123;</span><br><span class="line">            int j= i;</span><br><span class="line">            while (j&lt;chars.length)&#123;</span><br><span class="line">                answer[count] = chars[j];</span><br><span class="line">                count++;</span><br><span class="line">                //统一处理n的两边数字，特别处理腰部的数字</span><br><span class="line">                if(!(i == 0||i == numRows-1))&#123;</span><br><span class="line">                    if ((2*numRows-2-2*i+j) &lt; chars.length) &#123;</span><br><span class="line">                        answer[count] = chars[2*numRows-2-2*i+j];</span><br><span class="line">                        count++;</span><br><span class="line">                        &#125;  </span><br><span class="line">                    &#125;</span><br><span class="line">                    j += (2*numRows-2);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return new String(answer);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode解析</category>
        <category>中等</category>
      </categories>
      <tags>
        <tag>数学分析</tag>
      </tags>
  </entry>
  <entry>
    <title>两数之和</title>
    <url>/2021/11/22/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><pre><code>    给定一个整数数组 nums和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那两个整数，并返回它们的数组下标。
    你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。
    你可以按任意顺序返回答案
</code></pre>
<h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>本题主要提供一种使用hashmap的key的思路。使map接收到一个数的差又不会接收它本身。</p>
<span id="more"></span>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">int</span>[] twoSum(<span class="built_in">int</span>[] nums, <span class="built_in">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">HashMap</span>&lt;Integer,<span class="keyword">Object</span>&gt; <span class="built_in">map</span> = <span class="keyword">new</span> <span class="keyword">HashMap</span>();</span><br><span class="line">        <span class="comment">//key种存放一个数字，value存放合适的数组</span></span><br><span class="line">        <span class="built_in">int</span>[] answer = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">        	<span class="comment">//这里为核心思路</span></span><br><span class="line">             <span class="keyword">if</span> (<span class="built_in">map</span>.containsKey(target-nums[i]))&#123;</span><br><span class="line">                <span class="built_in">int</span>[] ints = (<span class="built_in">int</span>[]) <span class="built_in">map</span>.<span class="built_in">get</span>(target-nums[i]);</span><br><span class="line">                ints[<span class="number">1</span>] = i;</span><br><span class="line">                answer = ints.clone();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">int</span>[] ints = &#123;i,<span class="number">0</span>&#125;;</span><br><span class="line">                <span class="built_in">map</span>.put(nums[i],ints );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode解析</category>
        <category>简单</category>
      </categories>
      <tags>
        <tag>hashmap</tag>
      </tags>
  </entry>
  <entry>
    <title>hashmap的扩容与&amp;运算问题</title>
    <url>/2021/11/20/hashmap%E7%9A%84%E6%89%A9%E5%AE%B9%E4%B8%8E/</url>
    <content><![CDATA[<h1 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h1><p>1、初始容量为1&lt;&lt;4<br>2、负载因子为0.75，到达负载因子时2次幂扩展<br>3、通过hashcode计算存放位置</p>
<span id="more"></span>
<h1 id="hashcode的计算"><a href="#hashcode的计算" class="headerlink" title="hashcode的计算"></a>hashcode的计算</h1><p>1、获取hash值h，将h&gt;&gt;&gt;16后再与自身异或。<br>这是因为在计算hashmap存放位置时只取低位，正常运算会丢失高位的信息。这样处理后也可以将高位<br>的信息保留，减少冲突的可能性。<br>2、取模运算:(length-1)&amp;hash。<br>在这里可以解释为什么扩容是是2次幂，一般情况下，计算位置是需要%计算，但当length的长度为2的<br>次幂的时候，取余运算可以转化成上面的位与运算，大大节省了计算时间。</p>
<p><a href="https://www.cnblogs.com/ysocean/p/9054804.html">来源</a></p>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>hashmap</tag>
      </tags>
  </entry>
  <entry>
    <title>区间内查询数字频率</title>
    <url>/2021/11/21/%E5%8C%BA%E9%97%B4%E5%86%85%E6%9F%A5%E8%AF%A2%E6%95%B0%E5%AD%97%E9%A2%91%E7%8E%87/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><pre><code>    请你设计一个数据结构，它能求出给定子数组内一个给定值的频率。
    子数组中一个值的频率指的是这个子数组中这个值的出现次数。
    请你实现RangeFreqQuery类：
    RangeFreqQuery(int[] arr)用下标从 0开始的整数数组arr构造一个类的实例。
    int query(int left, int right, int value)返回子数组arr[left...right]中value的频率。
    一个子数组指的是数组中一段连续的元素。arr[left...right]指的是 nums中包含下标left和
    right在内的中间一段连续元素。
</code></pre>
<span id="more"></span>
<pre><code>    输入：
    [&quot;RangeFreqQuery&quot;, &quot;query&quot;, &quot;query&quot;]
    [[[12, 33, 4, 56, 22, 2, 34, 33, 22, 12, 34, 56]], [1, 2, 4], [0, 11, 33]]
    输出：
    [null, 1, 2]
</code></pre>
<h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>这道题使用暴力算法很简单，但示例有时间和内存限制，必须对算法进行优化。<br>创建一个hashmap，key存储要查询的数字，value中存储一个list，list存储出现的位置。<br>即使这样优化也会超时，所以在遍历list的时候还要使用二分查找，在这里要深度理解二分查找。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RangeFreqQuery</span> </span>&#123;</span><br><span class="line">    int[] array;</span><br><span class="line">    <span class="comment">//ArrayList list;//存放数字出现频率</span></span><br><span class="line">    HashMap map;<span class="comment">//存放list的钥匙库</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> RangeFreqQuery(int[] arr) &#123;</span><br><span class="line">        array = <span class="keyword">new</span> <span class="type">int</span>[arr.length];</span><br><span class="line">        <span class="comment">//list = new ArrayList();</span></span><br><span class="line">        map = <span class="keyword">new</span> <span class="type">HashMap</span>();</span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!map.containsKey(arr[i]))&#123;</span><br><span class="line">                ArrayList list = <span class="keyword">new</span> <span class="type">ArrayList</span>();</span><br><span class="line">                list.add(i);</span><br><span class="line">                map.put(arr[i],list);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                ArrayList list = (ArrayList) map.<span class="keyword">get</span>(arr[i]);</span><br><span class="line">                list.add(i);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> int query(int left, int right, int value) &#123;</span><br><span class="line">        ArrayList list = (ArrayList) map.<span class="keyword">get</span>(value);</span><br><span class="line">        <span class="keyword">if</span> (list == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            int <span class="keyword">new</span><span class="type">right</span> = list.size()<span class="number">-1</span>;</span><br><span class="line">            int <span class="keyword">new</span><span class="type">left</span> = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//考虑两种找不到的情况。list的第一位比right大，list的末位比left小</span></span><br><span class="line">            <span class="keyword">if</span> ((int)list.<span class="keyword">get</span>(<span class="number">0</span>)&gt;right||(int)list.<span class="keyword">get</span>(<span class="keyword">new</span><span class="type">right</span>)&lt;left)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//使用二分查找左，右指针位置</span></span><br><span class="line">            <span class="comment">//找到的左指针要求其指向的数字&gt;=left，即指向left或者第一个大于它的数字</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">new</span><span class="type">left</span> != <span class="keyword">new</span><span class="type">right</span>)&#123;</span><br><span class="line">                int mid = (<span class="keyword">new</span><span class="type">left</span>+<span class="keyword">new</span><span class="type">right</span>)/<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span> ((int)list.<span class="keyword">get</span>(mid) &gt;= left)&#123;</span><br><span class="line">                    <span class="keyword">new</span><span class="type">right</span> = mid;<span class="comment">//因为目标数字最后总在截取范围的后段，需要不断舍去前半部分的数字</span></span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;			   <span class="comment">//所以mid尽量取小(left+right)/2。</span></span><br><span class="line">                    <span class="keyword">new</span><span class="type">left</span> = mid+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            int leftnum = <span class="keyword">new</span><span class="type">left</span>;</span><br><span class="line">            <span class="keyword">new</span><span class="type">right</span> = list.size()<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">new</span><span class="type">left</span> = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//找到的右指针要求其指向的数字&lt;=right，即指向right或者第一个小于它的数字</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">new</span><span class="type">left</span> != <span class="keyword">new</span><span class="type">right</span>)&#123;</span><br><span class="line">                int mid = (<span class="keyword">new</span><span class="type">left</span>+<span class="keyword">new</span><span class="type">right</span>+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span> ((int)list.<span class="keyword">get</span>(mid) &lt;= right)&#123;</span><br><span class="line">                    <span class="keyword">new</span><span class="type">left</span> = mid;<span class="comment">//因为目标数字最后总在截取范围的前段，需要不断舍去前后部分的数字</span></span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;			  <span class="comment">//所以mid尽量取大(left+right+1)/2。</span></span><br><span class="line">                    <span class="keyword">new</span><span class="type">right</span> = mid<span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            int rightnum = <span class="keyword">new</span><span class="type">right</span>;</span><br><span class="line">            <span class="keyword">return</span> rightnum-leftnum+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode解析</category>
        <category>困难</category>
      </categories>
      <tags>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>打乱数组</title>
    <url>/2021/11/22/%E6%89%93%E4%B9%B1%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><pre><code>    给你一个整数数组 nums ，设计算法来打乱一个没有重复元素的数组。
    实现 Solution class:
    Solution(int[] nums) 使用整数数组 nums 初始化对象
    int[] reset() 重设数组到它的初始状态并返回
    int[] shuffle() 返回数组随机打乱后的结果
</code></pre>
<span id="more"></span>
<h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>本题没有难度，用于洗牌算法的学习</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int[] arr;</span><br><span class="line">  Random random = new Random();</span><br><span class="line">   public Solution(int[] nums) &#123;</span><br><span class="line">       arr = nums;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   public int[] reset() &#123;</span><br><span class="line">       return arr;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   public int[] shuffle() &#123;</span><br><span class="line">       int[] newArr = arr.clone();</span><br><span class="line">       //每次移动视为对当前位置随机成功</span><br><span class="line">       for(int i = 0;i&lt;arr.length;i++)&#123;</span><br><span class="line">       	//nextInt方法取到的数字为左闭右开区间</span><br><span class="line">           int num = i+random.nextInt(arr.length-i);</span><br><span class="line">           int cache = newArr[i];</span><br><span class="line">           newArr[i] = newArr[num];</span><br><span class="line">           newArr[num] = cache;</span><br><span class="line">       &#125;</span><br><span class="line">       return newArr;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode解析</category>
        <category>中等</category>
      </categories>
      <tags>
        <tag>洗牌算法</tag>
      </tags>
  </entry>
  <entry>
    <title>无重复最长数组</title>
    <url>/2021/11/22/%E6%97%A0%E9%87%8D%E5%A4%8D%E6%9C%80%E9%95%BF%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><pre><code>    给定一个字符串s，请你找出其中不含有重复字符的最长子串的长度。
</code></pre>
<h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>合理使用滑动窗口对字符串进行更新,每次遇到重复字符时收缩滑动窗口左端。</p>
<span id="more"></span>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="keyword">String</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">length</span>() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = <span class="number">1</span>;<span class="comment">//end一直指向无重复的下一位</span></span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span>[] chars = s.<span class="built_in">toCharArray</span>();</span><br><span class="line">        <span class="keyword">for</span> (;end&lt;chars.length;end++)&#123;</span><br><span class="line">            <span class="keyword">int</span> point = start;</span><br><span class="line">            <span class="comment">//判断前面的数组是否重复</span></span><br><span class="line">            <span class="keyword">for</span> (;point&lt;end;point++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (chars[point] == chars[end])&#123;</span><br><span class="line">                    <span class="comment">//说明当前无重复数组到达最大，比较记录</span></span><br><span class="line">                    max = Math.<span class="built_in">max</span>(max,end-start);</span><br><span class="line">                    <span class="comment">//更新start点位</span></span><br><span class="line">                    start = point+<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//还需要计算一次max</span></span><br><span class="line">        max = Math.<span class="built_in">max</span>(max,end-start);</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode解析</category>
        <category>中等</category>
      </categories>
      <tags>
        <tag>字符串检索</tag>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title>排列序列</title>
    <url>/2021/11/20/%E6%8E%92%E5%88%97%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><pre><code>    给出集合[1,2,3,...,n]，其所有元素共有n! 种排列。
    按大小顺序列出所有排列情况，并一一标记，当n = 3 时, 所有排列如下：
    &quot;123&quot;
    &quot;132&quot;
    &quot;213&quot;
    &quot;231&quot;
    &quot;312&quot;
    &quot;321&quot;
    给定n 和k，返回第k个排列。
</code></pre>
<span id="more"></span>
<h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>因为数字从小到大排列，所以可以直接由每位的数字来确定该数字所处位置。<br>如例中所示首位确定时，后两位能产生2！种变化，当第二位确定时，最后一位便确定。k的范围是1~6，12，34，56各一组。<br>需要对k处理方便计算，令k–，则k–除以2！可以正好被拆分开，再取得余数，用于确定下一位。<br>若k为5，则第一位的数字为第(5+1/2!)+1个数字,第二位的数字为(0/1!)+1个数字，第三位为剩下的最后一个数字。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public String getPermutation(int n, int k) &#123;</span><br><span class="line">        if (n ==1)&#123;</span><br><span class="line">            return &quot;1&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        //创建一个阶乘的数组，进行统计</span><br><span class="line">        k--;</span><br><span class="line">        int[][] count = new int[n - 1][2];</span><br><span class="line">        count[0][0] = 1;</span><br><span class="line">        for (int i = 1;i&lt;count.length;i++)&#123;</span><br><span class="line">            count[i][0] = count[i-1][0]*(i+1);</span><br><span class="line">        &#125;</span><br><span class="line">        int[] ints = new int[n];</span><br><span class="line">        for (int i = 0;i&lt;n;i++)&#123;</span><br><span class="line">            ints[i] = i+1;</span><br><span class="line">        &#125;</span><br><span class="line">        //开始逐个从数组中取出数组</span><br><span class="line">        String str = new String();</span><br><span class="line">        for (int i = count.length-1;i&gt;=0;i--)&#123;</span><br><span class="line">            count[i][1] = k/count[i][0];</span><br><span class="line">            int counter = -1;</span><br><span class="line">            for (int j = 0;j&lt;ints.length;j++)&#123;</span><br><span class="line">                if (ints[j] != 0)&#123;</span><br><span class="line">                    counter++;</span><br><span class="line">                    if (counter==count[i][1])&#123;</span><br><span class="line">                        str+=ints[j];</span><br><span class="line">                        ints[j] =0;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            k %= count[i][0];</span><br><span class="line">        &#125;</span><br><span class="line">        for (int o:ints)&#123;</span><br><span class="line">            if (o != 0)&#123;</span><br><span class="line">                str+=o;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return str;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>leetcode解析</category>
        <category>困难</category>
      </categories>
      <tags>
        <tag>数学分析</tag>
      </tags>
  </entry>
  <entry>
    <title>最长和谐子序列</title>
    <url>/2021/11/20/%E6%9C%80%E9%95%BF%E5%92%8C%E8%B0%90%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><pre><code>    和谐数组是指一个数组里元素的最大值和最小值之间的差别 正好是 1 。
    现在，给你一个整数数组 nums ，请你在所有可能的子序列中找到最长的和谐子序列的长度。
    数组的子序列是一个由数组派生出来的序列，它可以通过删除一些元素或不删除元素、且不改变其余元素的顺序而得到。
示例：
    输入：nums = [1,3,2,2,5,2,3,7]
    输出：5
    解释：最长的和谐子序列是 [3,2,2,2,3]
</code></pre>
<span id="more"></span>
<h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>创建一个hashmap，再通过条件判断，直接检索答案。    </p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int findLHS(int[] nums) &#123;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        //记录每个数字的个数</span><br><span class="line">        for (int o :nums)&#123;</span><br><span class="line">            if (!map.containsKey(o))&#123;</span><br><span class="line">                map.put(o,0);</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(o, map.get(o)+1);</span><br><span class="line">        &#125;</span><br><span class="line">        if (map.size() &lt; 2)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int max = 0;</span><br><span class="line">        //从map中查询相邻数字，并且判断max</span><br><span class="line">        for (int key:map.keySet())&#123;</span><br><span class="line">            if (map.get(key+1) != null)&#123;</span><br><span class="line">                max = Math.max(max,map.get(key)+map.get(key+1));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return max;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode解析</category>
        <category>简单</category>
      </categories>
      <tags>
        <tag>hashmap</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式匹配</title>
    <url>/2021/11/23/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给你一个字符串s和一个字符规律p，请你来实现一个支持 ‘.’和’星号’的正则表达式匹配。<br>‘.’ 匹配任意单个字符<br>‘星号’ 匹配零个或多个前面的那一个元素<br>所谓匹配，是要涵盖整个字符串s的，而不是部分字符串。</p>
<span id="more"></span>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>设dp[i,j]表示第i长的s与j长的p的匹配情况。<br>下面开始分情况讨论：<br>//普通字符<br>当dp[i-1，j-1]为真的时候，如果s[i] == p[j]，则dp[i,j]为真，否则必定为假。<br>当dp[i-1，j-1]为假的时候，只要是普通字符则必定为假。<br>//星字符<br>当不使用星字符修饰的字符就能匹配时，则dp[i,j-2]必定为真。<br>当星的字符开始循环后能匹配时，查询dp[i-1,j]是否为真，若为真，且s[i] = p[j-1]，则为真，其他情况为假。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public boolean isMatch(String s, String p) &#123;</span><br><span class="line">        boolean[][] dp = new boolean[s.length() + 1][p.length() + 1];</span><br><span class="line">        //因为dp的判断点依靠左上，左侧以及上方点位，所以逐行对dp进行填充</span><br><span class="line">        //初始化第一列</span><br><span class="line">        dp[0][0] = true;</span><br><span class="line">        for (int i = 1;i&lt;dp.length;i++)&#123;</span><br><span class="line">            dp[i][0] = false;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0;i&lt;dp.length;i++)&#123;</span><br><span class="line">            for (int j = 1;j&lt;dp[0].length;j++)&#123;</span><br><span class="line">                if (p.substring(j-1,j).equals(&quot;*&quot;))&#123;</span><br><span class="line">                    if (dp[i][j-2]||</span><br><span class="line">                    	//判断*作0的情况</span><br><span class="line">                    	(i&gt;0&amp;&amp;dp[i-1][j]&amp;&amp;(s.substring(i-1,i).equals(p.substring(j-2,j-1))</span><br><span class="line">                    	||p.substring(j-2,j-1).equals(&quot;.&quot;))))&#123;</span><br><span class="line">                    	//判断*大于1的情况</span><br><span class="line">                        dp[i][j] = true;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;else &#123;</span><br><span class="line">                    if (i&gt;0&amp;&amp;dp[i-1][j-1]&amp;&amp;(p.substring(j-1,j).equals(&quot;.&quot;)||s.substring(i-1,i).equals(p.substring(j-1,j))))&#123;</span><br><span class="line">                        dp[i][j] = true;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (dp[s.length()][p.length()])&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode解析</category>
        <category>困难</category>
      </categories>
      <tags>
        <tag>字符串检索</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>最长回文子串</title>
    <url>/2021/11/22/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><pre><code>    给你一个字符串s，找到s中最长的回文子串。
</code></pre>
<h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>首先对整个字符串加#，将单数字符串与双数字符串转换为单数字符串，减少代码量。<br>接着使用manacher算法：当一个短的字符串被包含在长字符串中时，具有一定的对称性。<br>情况一：短的字符串的镜像被包含在长字符串中，如caabaac，查a的长度，这时二者的长度相等。<br>情况二：短的字符串的镜像超出了长字符串的范围，此时这个字符串的长度正好到到长字符串的顶端。<br>情况三：短的字符串的镜像刚好落在了长字符串的一端，此时这个字符串长度最短到长字符串的顶端。</p>
<span id="more"></span>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">String</span> longestPalindrome(<span class="keyword">String</span> s) &#123;</span><br><span class="line">        <span class="built_in">char</span>[] chars = s.toCharArray();</span><br><span class="line">        <span class="built_in">char</span>[] <span class="built_in">str</span> = <span class="keyword">new</span> <span class="built_in">char</span>[chars.length * <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>;i&lt;chars.length;i++)&#123;</span><br><span class="line">            <span class="built_in">str</span>[<span class="number">2</span>*i] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">            <span class="built_in">str</span>[<span class="number">2</span>*i+<span class="number">1</span>] = chars[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">str</span>[<span class="built_in">str</span>.length<span class="number">-1</span>] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">        <span class="comment">//对字符串进行处理，把奇偶两种情况都转换为奇数情况</span></span><br><span class="line">        <span class="built_in">int</span>[] length = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="built_in">str</span>.length];</span><br><span class="line">        <span class="comment">//用于记录回文半径</span></span><br><span class="line">        <span class="built_in">int</span> shadow = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//创建一个数，用来记录最大阴影。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>;i&lt;<span class="built_in">str</span>.length;i++)&#123;</span><br><span class="line">            <span class="comment">//使用manacher算法</span></span><br><span class="line">            <span class="comment">//判断数字是否在阴影中</span></span><br><span class="line">            <span class="built_in">int</span> shadowLength = shadow+length[shadow];</span><br><span class="line">            <span class="keyword">if</span> (i!=<span class="number">0</span>&amp;&amp;i&lt;shadowLength)&#123;</span><br><span class="line">                <span class="comment">//取得镜像点</span></span><br><span class="line">                <span class="built_in">int</span> mirro = shadow-(i-shadow);</span><br><span class="line">                <span class="comment">//进入manacher算法后要分三种情况</span></span><br><span class="line">                <span class="comment">//镜像长度在阴影内</span></span><br><span class="line">                <span class="keyword">if</span> (i+length[mirro]&lt;shadowLength)&#123;</span><br><span class="line">                    length[i] = length[mirro];</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (i+length[mirro] &gt;shadowLength)&#123;</span><br><span class="line">                    length[i] = shadowLength-i;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    length[i] = shadowLength-i;</span><br><span class="line">                    <span class="built_in">int</span> left = i-(shadowLength-i);</span><br><span class="line">                    <span class="built_in">int</span> right = shadowLength;</span><br><span class="line">                    <span class="keyword">while</span> (left<span class="number">-1</span>&gt;=<span class="number">0</span>&amp;&amp;right+<span class="number">1</span>&lt;<span class="built_in">str</span>.length&amp;&amp;<span class="built_in">str</span>[left<span class="number">-1</span>]==<span class="built_in">str</span>[right+<span class="number">1</span>])&#123;</span><br><span class="line">                        left--;</span><br><span class="line">                        right++;</span><br><span class="line">                        length[i]++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//不在阴影中使用传统暴力算法</span></span><br><span class="line">            <span class="built_in">int</span> left = i;</span><br><span class="line">            <span class="built_in">int</span> right = i;</span><br><span class="line">            <span class="keyword">while</span> (left<span class="number">-1</span>&gt;=<span class="number">0</span>&amp;&amp;right+<span class="number">1</span>&lt;<span class="built_in">str</span>.length&amp;&amp;<span class="built_in">str</span>[left<span class="number">-1</span>]==<span class="built_in">str</span>[right+<span class="number">1</span>])&#123;</span><br><span class="line">                left--;</span><br><span class="line">                right++;</span><br><span class="line">                length[i]++;</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//更新阴影</span></span><br><span class="line">            <span class="keyword">if</span> (shadow+length[shadow]&lt;i+length[i])&#123;</span><br><span class="line">                shadow = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">int</span> maxPoint=<span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">int</span> maxLength = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i =<span class="number">0</span>;i&lt;length.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (length[i]&gt;maxLength)&#123;</span><br><span class="line">                maxLength = length[i];</span><br><span class="line">                maxPoint = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">String</span> answer = <span class="keyword">new</span> <span class="keyword">String</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = maxPoint-maxLength;i&lt;=maxPoint+maxLength;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">str</span>[i] != <span class="string">&#x27;#&#x27;</span>)&#123;</span><br><span class="line">                answer += <span class="built_in">str</span>[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode解析</category>
        <category>中等</category>
      </categories>
      <tags>
        <tag>字符串检索</tag>
        <tag>manacher算法</tag>
      </tags>
  </entry>
  <entry>
    <title>盛水最多的容器</title>
    <url>/2021/11/24/%E7%9B%9B%E6%B0%B4%E6%9C%80%E5%A4%9A%E7%9A%84%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给你 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点(i,ai) 。<br>在坐标内画 n 条垂直线，垂直线 i的两个端点分别为(i,ai)和(i,0)。找出其中的两条线，使得它们与x轴共同构成的容器可以容纳最多的水。</p>
<span id="more"></span>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>首先将左右指针指向两端。然后寻找可能使面积更大的组合，无论左右指针哪个移动，底宽都是<br>原来-1。底宽减小，则只有min(left,right)变大才可能使面积变大，若向内移动长边，因为短边<br>没变，所以不可能使min(left,right)变大，只能移动短边，希望短边侧变长。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int maxArea(int[] height) &#123;</span><br><span class="line">        int left = 0;</span><br><span class="line">        int right = height.length-1;</span><br><span class="line">        int max = 0;</span><br><span class="line">        while (left != right)&#123;</span><br><span class="line">            int area = Math.min(height[left],height[right])*(right-left);</span><br><span class="line">            max = Math.max(area,max);</span><br><span class="line">            if (height[left] &lt; height[right])&#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        return max;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode解析</category>
        <category>中等</category>
      </categories>
      <tags>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>三数之和</title>
    <url>/2021/11/25/%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给你一个包含 n 个整数的数组nums，判断nums中是否存在三个元素 a，b，c ，使得a+b+c=0？<br>请你找出所有和为0 且不重复的三元组。<br>注意：答案中不可以包含重复的三元组。</p>
<span id="more"></span>
<h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>本题主要难度在于如何去重。首先将数组排序，从数组左方取出第一个数字，且每次取到的数字不能为重复。<br>接着从第一个数字右方取出第二个数字，从第二数字右方找到第三个数。<br>然后着手算法的优化，因为数组是排序好的，所以第三个数字可以使用二分查找。<br>因为三数和为0，且num1&lt; num2 &lt; num3，当num1大于0时不可能有解直接结束循环。<br>当num1+num2大于0时不可能有解。<br>当数组第一个数大于0或者末位小于0，或者数组长度小于3，为空解直接返回空。<br>因为for循环查询长度较长，考虑使用增强for循环。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123;</span><br><span class="line">        ArrayList&lt;List&lt;Integer&gt;&gt; lists = new ArrayList&lt;&gt;();</span><br><span class="line">        if (nums.length&lt;3)&#123;</span><br><span class="line">            return lists;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        //当数组第一个数大于0或者末位小于0，或者数组长度小于3，为空解直接返回空。</span><br><span class="line">        if (nums[0]&gt;0||nums[nums.length-1]&lt;0)&#123;</span><br><span class="line">            return lists;</span><br><span class="line">        &#125;</span><br><span class="line">        //首先将数组排序，从数组左方取出第一个数字，且每次取到的数字不能为重复。</span><br><span class="line">        int answer1 = 100001;</span><br><span class="line">        int answer2 = 100001;</span><br><span class="line">        int i = 0;</span><br><span class="line">        for (int num1:nums)&#123;</span><br><span class="line">            if (num1 == answer1)&#123;</span><br><span class="line">                i++;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            //因为三数和为0，且num1&lt; num2 &lt; num3，当num1大于0时不可能有解直接结束循环。</span><br><span class="line">            if (num1&gt;0)&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            answer1 = num1;</span><br><span class="line">            i++;</span><br><span class="line">            //接着从第一个数字右方取出第二个数字，从第二数字右方找到第三个数。</span><br><span class="line">            for (int j = i;j&lt; nums.length-1;j++)&#123;</span><br><span class="line">                if (j&gt;i&amp;&amp;nums[j] == answer2)&#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                //因为数组是排序好的，所以第三个数字可以使用二分查找。</span><br><span class="line">                answer2 = nums[j];</span><br><span class="line">                if (answer1+answer2&gt;0)&#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                int answer3 = 0-answer1-answer2;</span><br><span class="line">                int k = Arrays.binarySearch(nums,j+1,nums.length,answer3);</span><br><span class="line">                if (k&gt;0)&#123;</span><br><span class="line">                    lists.add(Arrays.asList(answer1,answer2,answer3));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return lists;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode解析</category>
        <category>中等</category>
      </categories>
      <tags>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>可怜的小猪</title>
    <url>/2021/11/25/%E5%8F%AF%E6%80%9C%E7%9A%84%E5%B0%8F%E7%8C%AA/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>有buckets桶液体，其中正好有一桶含有毒药，其余装的都是水。它们从外观看起来都一样。<br>为了弄清楚哪只水桶含有毒药，你可以喂一些猪喝，通过观察猪是否会死进行判断。不幸的是，<br>你只有minutesToTest分钟时间来确定哪桶液体是有毒的。<br>喂猪的规则如下：</p>
<span id="more"></span>
<p>选择若干活猪进行喂养,可以允许小猪同时饮用任意数量的桶中的水，并且该过程不需要时间。<br>小猪喝完水后，必须有minutesToDie分钟的冷却时间。在这段时间里，你只能观察，而不允许<br>继续喂猪。过了 minutesToDie 分钟后，所有喝到毒药的猪都会死去，其他所有猪都会活下来。<br>重复这一过程，直到时间用完。<br>给你桶的数目buckets，minutesToDie和minutesToTest，返回在规定时间内判断哪个桶有<br>毒所需的最小猪数。</p>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>这道题比较有意思，只要看到本质是很简单一道题。分析每只猪能带多少信息，如果有x轮，猪<br>可以在x中的一轮中死亡，或者不死亡。所以每只猪可以看作x+1进制的单位，只要能表示出10进<br>制的桶数即成功。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public <span class="built_in">int</span> poor<span class="constructor">Pigs(<span class="params">int</span> <span class="params">buckets</span>, <span class="params">int</span> <span class="params">minutesToDie</span>, <span class="params">int</span> <span class="params">minutesToTest</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">int</span> x = minutesToTest/minutesToDie+<span class="number">1</span>;</span><br><span class="line">        double temp = <span class="module-access"><span class="module"><span class="identifier">Math</span>.</span></span>log(buckets)/<span class="module-access"><span class="module"><span class="identifier">Math</span>.</span></span>log(x);</span><br><span class="line">        return (<span class="built_in">int</span>)<span class="module-access"><span class="module"><span class="identifier">Math</span>.</span></span>ceil(temp);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode解析</category>
        <category>困难</category>
      </categories>
      <tags>
        <tag>进制问题</tag>
      </tags>
  </entry>
  <entry>
    <title>删除倒数第n个节点</title>
    <url>/2021/11/25/%E5%88%A0%E9%99%A4%E5%80%92%E6%95%B0%E7%AC%ACn%E4%B8%AA%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点</p>
<span id="more"></span>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>使用回溯，返回时开始计数，返回到父节点。方便操作，再添加一个伪父节点</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> ListNode removeNthFromEnd(ListNode head, <span class="built_in">int</span> n) &#123;</span><br><span class="line">        ListNode fhead = <span class="keyword">new</span> ListNode(<span class="number">0</span>,head);</span><br><span class="line">        trackback(fhead,n);</span><br><span class="line">        <span class="keyword">return</span> fhead.<span class="keyword">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> trackback(ListNode head,<span class="built_in">int</span> n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(head.<span class="keyword">next</span> != <span class="literal">null</span>)&#123;</span><br><span class="line">            trackback(head.<span class="keyword">next</span>,n);</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(num == n)&#123;</span><br><span class="line">            head.<span class="keyword">next</span> = head.<span class="keyword">next</span>.<span class="keyword">next</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode解析</category>
        <category>中等</category>
      </categories>
      <tags>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>括号生成</title>
    <url>/2021/11/25/%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>数字n代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且有效的 括号组合。<br>有效括号组合需满足：左括号必须以正确的顺序闭合。</p>
<span id="more"></span>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>创建回溯，使str既可以添加(也可以添加)。但需要对添加的条件进行约束。<br>再对str是否完成进行判断。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt; answer;</span><br><span class="line">    public List&lt;String&gt; generateParenthesis(<span class="built_in">int</span> <span class="built_in">n</span>) &#123;</span><br><span class="line">        answer = new ArrayList&lt;String&gt;();</span><br><span class="line">        tarckback(<span class="built_in">n</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line">        return answer;</span><br><span class="line">    &#125;</span><br><span class="line">    public void tarckback(<span class="built_in">int</span> <span class="built_in">n</span>,<span class="built_in">int</span> <span class="built_in">left</span>,<span class="built_in">int</span> <span class="built_in">right</span>,String str)&#123;</span><br><span class="line">        <span class="built_in">if</span> (<span class="built_in">left</span>&lt;<span class="built_in">n</span>) &#123;</span><br><span class="line">            tarckback(<span class="built_in">n</span>,<span class="built_in">left</span>+<span class="number">1</span>,<span class="built_in">right</span>,str+<span class="string">&quot;(&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">if</span> (<span class="built_in">left</span>&gt;<span class="built_in">right</span>) &#123;</span><br><span class="line">            tarckback(<span class="built_in">n</span>,<span class="built_in">left</span>,<span class="built_in">right</span>+<span class="number">1</span>,str+<span class="string">&quot;)&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">if</span> (str.length() == <span class="number">2</span>*<span class="built_in">n</span>)&#123;</span><br><span class="line">            answer.add(str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode解析</category>
        <category>中等</category>
      </categories>
      <tags>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>搜索旋转排序数组</title>
    <url>/2021/11/26/%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>整数数组nums按升序排列，数组中的值互不相同。<br>在传递给函数之前，nums在预先未知的某个下标k(0 &lt;= k &lt; nums.length)上进行了旋转，<br>使数组变为[nums[k], nums[k+1], …, nums[n-1], nums[0], nums[1], …, nums[k-1]]<br>(下标 从 0 开始 计数)。例如，[0,1,2,4,5,6,7]在下标3处经旋转后可能变为[4,5,6,7,0,1,2] 。<br>给你旋转后的数组nums和一个整数target，如果nums中存在这个目标值target,则返回它的下标,<br>否则返回-1。</p>
<span id="more"></span>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>对数组进行二分，有一半可以进行二分查找，如果目标数组在一排序好的一半则可以直接使用二分查找，<br>否则继续进行二分。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int search(int[] nums, int target) &#123;</span><br><span class="line">        //二分查找，先查排序好的，再对另一部分二分</span><br><span class="line">        int answer =  biSearch(0, nums.length-1, nums,target);</span><br><span class="line">        if (answer&lt;0)&#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            return answer;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public int biSearch(int first,int last,int[] num,int target)&#123;</span><br><span class="line">        //判断是否找到数字或者二分结束</span><br><span class="line">        int mid = (first+last)/2;</span><br><span class="line">        if (num[mid] == target)&#123;</span><br><span class="line">            return mid;</span><br><span class="line">        &#125;else if (mid == last)&#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        //判断哪部分是排序好的</span><br><span class="line">        if (num[first]&lt;num[mid])&#123;</span><br><span class="line">            if (target&gt;=num[first]&amp;&amp;target&lt;=num[mid])&#123;</span><br><span class="line">                return Arrays.binarySearch(num,first,mid+1,target);</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                return biSearch(mid+1,last,num,target);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            if (target&gt;=num[mid+1]&amp;&amp;target&lt;=num[last])&#123;</span><br><span class="line">                return Arrays.binarySearch(num,mid+1,last+1,target);</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                return biSearch(first,mid,num,target);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode解析</category>
        <category>中等</category>
      </categories>
      <tags>
        <tag>查找，二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程高并发</title>
    <url>/2021/11/26/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%AB%98%E5%B9%B6%E5%8F%91/</url>
    <content><![CDATA[<h1 id="如何确定合适的线程数"><a href="#如何确定合适的线程数" class="headerlink" title="如何确定合适的线程数"></a>如何确定合适的线程数</h1><p>根据任务需要执行计算的时间占比分配线程数。如：4核，任务中计算占比25%的任务分配16线程。</p>
<span id="more"></span>
<h1 id="缓存行编程技巧"><a href="#缓存行编程技巧" class="headerlink" title="缓存行编程技巧"></a>缓存行编程技巧</h1><p>前提知识：缓存行每次从内存拉取64bytes的内容。同一缓存行在不同cpu中同时处理时需要不断对齐。<br>例：<br>创建一个类，类中存放一个long型数据，创建一个2容量这个类的数组，启动两个线程分别对这两个<br>类的long型数据处理。时间记作t1。<br>创建一个与上面相似的类，但在其中的long型数据前和后分别填充7个无用的long型数据，再执行与<br>上面相同的操作。时间记作t2。<br>结果是t2会比t1短很多。原因是，第一个类中，两个要处理的数据会处于同一缓存行，在处理时需要不断<br>的对齐。二第二个类中，因为无用long型数据的填充，使得两个被操作的数据无法处于同一缓存行，不用对齐。</p>
<h1 id="指令重排"><a href="#指令重排" class="headerlink" title="指令重排"></a>指令重排</h1><p>问题：<br>在cpu执行语句时，happens-before规则约束后，可能会在执行过程中发生指令重排，<br>宏观表现为语句的倒转。而这种问题会导致this引用逃逸。如下面的代码就可能会输出0。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ThisEscape&#123;</span><br><span class="line">	private int num = 0;</span><br><span class="line">	public ThisEscape()&#123;</span><br><span class="line">		new Thread(()-&gt;System.out.println(this.num)).start();</span><br><span class="line">	&#125; </span><br><span class="line">	public static void mian(String[] args)throw Exception&#123;</span><br><span class="line">		new ThisEscape();</span><br><span class="line">		System.in.read();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分析：num的初始在汇编中有三步，创建空间，赋值，再指向。但this一开始就指向了他本身，所以可能<br>在num没有初始化完成时就调用了this指针，将num发送出去。<br>如何避免：不要在构造方法中启动线程</p>
<h1 id="提高并发效率"><a href="#提高并发效率" class="headerlink" title="提高并发效率"></a>提高并发效率</h1><p>合理的上锁，不要锁太多没必要的内容导致并发效率降低。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//给整个函数上锁</span><br><span class="line">public synchronized ...()&#123;&#125;</span><br><span class="line">//给部分代码上锁，注意静态方法中锁只能是本身的类对象</span><br><span class="line">synchronized(类对象)&#123;要执行的代码&#125;</span><br></pre></td></tr></table></figure>
<p>double check lock<br>在给部分代码上锁的过程中一般会进行判断，但注意不可以只在上锁前进行判断，因为线程可能会在任意<br>阶段发生切换，多个线程同时挤进判断语句中也会发生，所以在锁内要再加判断，如果情况变了，要归还锁。<br>这种上锁方式，只对内层进行上锁仍然可以起到相同的效果，但加入外层锁后可以减少上锁解锁的过程，<br>提升代码效率。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//单例模式取得对象</span><br><span class="line">if(INSTANCE == null)&#123;</span><br><span class="line">	synchronized(当前类)&#123;</span><br><span class="line">		if(INSTANCE == null)&#123;</span><br><span class="line">			INSTANCE = new 类对象;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个双锁仍旧有问题，new对象时如果发生指令重排，当只指向地址但未赋值时，此时恰好又有另一个线程访问对象，就会访问到未初始的对象。(虽然被锁定，但是上锁的代码和未上锁的代码是可以访问到中间态的)(java高版本已经解决了这个问题)<br>cpu级防止指令交换：添加屏障指令<br>jvm中防止指令交换：四种内存屏障Load-Store<br>java中防止指令交换：在修饰的前面加volatile</p>
]]></content>
      <categories>
        <category>多线程高并发</category>
      </categories>
  </entry>
  <entry>
    <title>进程与线程</title>
    <url>/2021/11/26/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<p>1.进程要分配一大部分的内存，而线程只需要分配一部分栈就可以了.<br>2.一个程序至少有一个进程,一个进程至少有一个线程.<br>3.进程是资源分配的最小单位，线程是程序执行的最小单位。<br>4.一个线程可以创建和撤销另一个线程，同一个进程中的多个线程之间可以并发执行</p>
<span id="more"></span>
<p>线程栈：<br>1.方便函数调用，当调用子函数时，可以把当前函数的信息压入栈中，<br>再在栈的顶端压入返回地址，当子函数调用结束后再弹栈即可。<br>2.多任务支持，当有必要进行任务切换时，对当前信息存储，再读入<br>另一个任务的信息即可。</p>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>进程，线程</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程基础</title>
    <url>/2021/11/27/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h1><p>1.进程要分配一大部分的内存，而线程只需要分配一部分栈就可以了.<br>2.一个程序至少有一个进程,一个进程至少有一个线程.<br>3.进程是资源分配的最小单位，线程是程序执行的最小单位。<br>4.一个线程可以创建和撤销另一个线程，同一个进程中的多个线程之间可以并发执行</p>
<span id="more"></span>    
<p>线程栈：<br>1.方便函数调用，当调用子函数时，可以把当前函数的信息压入栈中，<br>再在栈的顶端压入返回地址，当子函数调用结束后再弹栈即可。<br>2.多任务支持，当有必要进行任务切换时，对当前信息存储，再读入<br>另一个任务的信息即可。</p>
<h1 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h1><p>并发：单一cpu交替执行多任务，宏观表现同时进行的情况称为并发。<br>并行：多个cpu同时执行多个任务，宏观表现与微观均为同时进行。</p>
<h1 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h1><p>1.继承Thread类，重写run方法<br>2.实现Runnabel接口，重写run方法<br>实现Runnabel接口的启动：重写完run方法后，在主方法中创建对象，再把这个对象<br>交给Thread进行静态代理，再启动对应的thread。</p>
<h1 id="停止线程"><a href="#停止线程" class="headerlink" title="停止线程"></a>停止线程</h1><p>1.线程执行完毕自动停止<br>2.在run方法中使用一个变量控制线程，想要停止时改变run方法中的这个变量。</p>
<h1 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h1><p>1.setName<br>2.getName<br>3.start<br>4.run<br>5.setPriority<br>6.getPriority<br>7.sleep<br>8.interrupt//一般用于中断休眠<br>9.yield//尝试性礼让<br>10.join//插队</p>
<h1 id="释放锁的情况"><a href="#释放锁的情况" class="headerlink" title="释放锁的情况"></a>释放锁的情况</h1><p>1.线程结束 2.线程异常 3.线程中断 4.wait()<br>sleep，yield，suspend不会释放锁。</p>
]]></content>
      <categories>
        <category>多线程基础</category>
      </categories>
  </entry>
  <entry>
    <title>组合总和</title>
    <url>/2021/11/28/%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定一个数组candidates和一个目标数target，找出candidates中所有可以使数字和为target的组合。<br>candidates中的每个数字在每个组合中只能使用一次。<br>注意：解集不能包含重复的组合</p>
<span id="more"></span>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>本题难点在于如何去重，解决办法是将数组排序，在循环内添加判断，如果与上一个相同，跳过即可。这样处理可以去掉同层所有重复数字，但不同层的数字仍然可以重复。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; answer;</span><br><span class="line"></span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) &#123;</span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        int[] ints = new int[candidates.length + 1];</span><br><span class="line">        for (int i =0;i&lt;candidates.length;i++)&#123;</span><br><span class="line">            ints[i] = candidates[i];</span><br><span class="line">        &#125;</span><br><span class="line">        answer = new ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        tarckBack(ints, target, 0, 0, new ArrayList&lt;Integer&gt;());</span><br><span class="line">        return answer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void tarckBack(int[] candidates, int target, int start, int sum, ArrayList&lt;Integer&gt; list) &#123;</span><br><span class="line">        if (sum == target) &#123;</span><br><span class="line">            ArrayList&lt;Integer&gt; list1 = new ArrayList&lt;&gt;(list);</span><br><span class="line">            answer.add(list1);</span><br><span class="line">        &#125; else if (sum &lt; target) &#123;</span><br><span class="line">            for (int i = start; i &lt; candidates.length-1; i++) &#123;</span><br><span class="line">                //同层去重</span><br><span class="line">                if (i&gt;start&amp;&amp;candidates[i]==candidates[i-1])&#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                list.add(candidates[i]);</span><br><span class="line">                tarckBack(candidates, target, i+1, sum + candidates[i], list);</span><br><span class="line">                list.remove(list.size() - 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode解析</category>
        <category>中等</category>
      </categories>
      <tags>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式</title>
    <url>/2021/11/29/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="正则表达式语法"><a href="#正则表达式语法" class="headerlink" title="正则表达式语法"></a>正则表达式语法</h1><p>注意：要正确使用转义字符。java：\\，其他\。</p>
<span id="more"></span>
<h2 id="限定符"><a href="#限定符" class="headerlink" title="限定符"></a>限定符</h2><table>
<thead>
<tr>
<th>符号</th>
<th>解释</th>
<th>示例</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>*</td>
<td>克林闭包</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>+</td>
<td>正闭包</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>?</td>
<td>可重复0次或1次</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>{n}</td>
<td>只能输入n个字符</td>
<td>[abcd]{3}</td>
<td>abcd四字母组成的3长度字符串</td>
</tr>
<tr>
<td>{n,}</td>
<td>至少n个字符</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>{n,m}</td>
<td>至少n个，至多m个字符</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>?</td>
<td>非贪婪匹配</td>
<td>\\d+?</td>
<td>输出尽可能短的数字串，默认是输出尽可能长的</td>
</tr>
</tbody></table>
<h2 id="选择匹配符"><a href="#选择匹配符" class="headerlink" title="选择匹配符"></a>选择匹配符</h2><table>
<thead>
<tr>
<th>符号</th>
<th>解释</th>
<th>示例</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>|</td>
<td>匹配”|”之前或之后的内容</td>
<td>ab|cd</td>
<td>ab或cd</td>
</tr>
</tbody></table>
<h2 id="分组组合和反向引用符"><a href="#分组组合和反向引用符" class="headerlink" title="分组组合和反向引用符"></a>分组组合和反向引用符</h2><table>
<thead>
<tr>
<th>符号</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>(pattern)</td>
<td>非命名捕获分组，使用index查询</td>
</tr>
<tr>
<td>(?&lt;name&gt;pattern)</td>
<td>命名捕获分组，可以使用组名或index查询</td>
</tr>
<tr>
<td>(?:pattern)</td>
<td>匹配但不捕获分组index，无法靠index查找。作用：apple(?:|s)=(apple|apples)</td>
</tr>
<tr>
<td>(?=pattern)</td>
<td>匹配但不捕获分组信息。作用：win(?=7|8|9),会找到win后面是7，8，9的win，但不会匹配win10的win</td>
</tr>
<tr>
<td>(?!pattern)</td>
<td>该表达式与上一个式子作用相反。</td>
</tr>
</tbody></table>
<h2 id="字符匹配符"><a href="#字符匹配符" class="headerlink" title="字符匹配符"></a>字符匹配符</h2><table>
<thead>
<tr>
<th>符号</th>
<th>解释</th>
<th>示例</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>[]</td>
<td>可接收的字符列表</td>
<td>[efgh]</td>
<td>efgh中的任意一个字符</td>
</tr>
<tr>
<td>[^]</td>
<td>不接收的字符列表</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>-</td>
<td>连字符</td>
<td>A-Z</td>
<td>A—Z间的的所有字符</td>
</tr>
<tr>
<td>.</td>
<td>匹配除\n以外的任何字符</td>
<td>a..b</td>
<td>a开头，b结尾，4长度字符</td>
</tr>
<tr>
<td>\\d</td>
<td>匹配单个数字，相当[0-9]</td>
<td>\\d{3}(\\d)?</td>
<td>包含三个或四个数字的字符串</td>
</tr>
<tr>
<td>\\D</td>
<td>匹配单个非数字</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>\\w</td>
<td>匹配单个数字，字母</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>\\W</td>
<td>匹配单个非数字且非字母的字符</td>
<td>-</td>
<td>-</td>
</tr>
</tbody></table>
<h2 id="定位符"><a href="#定位符" class="headerlink" title="定位符"></a>定位符</h2><table>
<thead>
<tr>
<th>符号</th>
<th>解释</th>
<th>示例</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>^</td>
<td>指定起始符</td>
<td>^[0-9]+[a-z]*</td>
<td>以至少一个数字开头，后面任意长度字母的字符串</td>
</tr>
<tr>
<td>$</td>
<td>指定结束符</td>
<td>^[0-9]\-[a-z]+$</td>
<td>以数字开头接-并且至少一个字母结尾的字符串</td>
</tr>
<tr>
<td>\\b</td>
<td>匹配目标字符串的边界</td>
<td>han\\b</td>
<td>空格前或结尾的都为han</td>
</tr>
<tr>
<td>\\B</td>
<td>匹配目标字符串的非边界</td>
<td>han\\B</td>
<td>han出现在非边界的位置</td>
</tr>
</tbody></table>
<h2 id="反向引用"><a href="#反向引用" class="headerlink" title="反向引用"></a>反向引用</h2><p>使用括号捕获的内容可以在这个括号后被重复使用，从而写出比较实用的匹配模式。<br>内部反向引用：\\分组号。外部反向引用：$分组号。(用于外部函数中的调用)<br>例：(\\d)(\\d)\\2\\1,这个表达式可以匹配一个四字符长度的回文字符串。</p>
<h1 id="java中的正则表达式"><a href="#java中的正则表达式" class="headerlink" title="java中的正则表达式"></a>java中的正则表达式</h1><h2 id="正则表达式的使用"><a href="#正则表达式的使用" class="headerlink" title="正则表达式的使用"></a>正则表达式的使用</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//创建一个pattern对象</span><br><span class="line">new Pattern.complie(&quot;正则表达式&quot;);</span><br><span class="line">//创建一个匹配对象</span><br><span class="line">new pattern.matcher(文本);</span><br><span class="line">//开始循环匹配,find返回找到的内容</span><br><span class="line">while(matcher.find())&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<!-- more -->
<h2 id="matcher-group"><a href="#matcher-group" class="headerlink" title="matcher.group()"></a>matcher.group()</h2><p>group(0)中存放找到的所有内容的index。<br>group(n)中存放第n个()中的内容的index。</p>
<h2 id="常用类"><a href="#常用类" class="headerlink" title="常用类"></a>常用类</h2><table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>Pattern.matches(正则表达式,匹配内容)</td>
<td>返回一个布尔值表示是否整体匹配</td>
</tr>
<tr>
<td>matcher.start()</td>
<td>返回匹配字符串的首字符index</td>
</tr>
<tr>
<td>matcher.end()</td>
<td>返回匹配字符串末尾字符index+1</td>
</tr>
<tr>
<td>matcher.matches</td>
<td>返回一个布尔值表示是否整体匹配</td>
</tr>
<tr>
<td>matcher.replaceAll(替换内容)</td>
<td>将匹配的字符串替换为输入的替换内容。注意：原本的文本内容不会发生变换，只是返回一个被替换的字符串</td>
</tr>
<tr>
<td>matcher.replaceAll(被替换内容,替换内容)</td>
<td>将匹配到的内容的被替换内容替换为替换内容</td>
</tr>
</tbody></table>
<h2 id="String类中的正则表达式"><a href="#String类中的正则表达式" class="headerlink" title="String类中的正则表达式"></a>String类中的正则表达式</h2><p>String类有部分方法是支持正则表达式的。<br>str.matches(正则表达式) 判断是否完全匹配<br>str.split(正则表达式)依据正则表达进行分割<br>str.replaceAll(正则表达式,替换内容)将与正则表达匹配的内容替换为替换内容</p>
]]></content>
      <categories>
        <category>正则表达式</category>
      </categories>
  </entry>
  <entry>
    <title>第k个最小的素数分数</title>
    <url>/2021/11/30/%E7%AC%ACk%E4%B8%AA%E6%9C%80%E5%B0%8F%E7%9A%84%E7%B4%A0%E6%95%B0%E5%88%86%E6%95%B0/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给你一个按递增顺序排序的数组arr和一个整数k。数组arr由1和若干素数组成，且其中所有整数互不相同。<br>对于每对满足0&lt; i &lt; j &lt; arr.length 的 i 和 j ，可以得到分数 arr[i] / arr[j] 。</p>
<span id="more"></span>
<h1 id="堆排序分析"><a href="#堆排序分析" class="headerlink" title="堆排序分析"></a>堆排序分析</h1><p>这道题是对java中堆排序的练习。为了提高运算速度，需要对堆的入堆进行筛选。因为只需要取得第k个小的分数，构建一个大根堆，存放最小的7个分数，当堆大于7时，加入的分数如果大于堆顶，则没必要加入，如果小于堆顶，则弹出堆顶再加入当前分数。全部入堆结束后堆顶就是答案。</p>
<h1 id="堆排序代码"><a href="#堆排序代码" class="headerlink" title="堆排序代码"></a>堆排序代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int[] kthSmallestPrimeFraction(int[] arr, int k) &#123;</span><br><span class="line">        //把所有分数串连起来</span><br><span class="line">        ArrayList list = new ArrayList();</span><br><span class="line">        for (int i = 0;i&lt; arr.length-1;i++)&#123;</span><br><span class="line">            for (int j = 0;j&lt;i+1;j++)&#123;</span><br><span class="line">                int[] ints = &#123;arr[j],arr[i+1]&#125;;</span><br><span class="line">                list.add(ints);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //创建堆</span><br><span class="line">        Queue heap= new PriorityQueue(new Comparator() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public int compare(Object o1, Object o2) &#123;</span><br><span class="line">                int[] int1 = (int[]) o1;</span><br><span class="line">                int[] int2 = (int[]) o2;</span><br><span class="line">                return int2[0]*int1[1]-int1[0]*int2[1];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        //把这些元素放入堆中</span><br><span class="line">        for (Object o:list)&#123;</span><br><span class="line">            int[] int1 = (int[]) heap.peek();</span><br><span class="line">            int[] int2 = (int[]) o;</span><br><span class="line">            if (heap.size()&gt;=k&amp;&amp;int1[0]*int2[1]&gt;int1[1]*int2[0])&#123;</span><br><span class="line">                heap.poll();</span><br><span class="line">                heap.offer(o);</span><br><span class="line">            &#125;else if (heap.size()&lt;k)&#123;</span><br><span class="line">                heap.offer(o);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return (int[]) heap.poll();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h1 id="归并排序分析"><a href="#归并排序分析" class="headerlink" title="归并排序分析"></a>归并排序分析</h1><p>因为1/n&lt;2/n&lt;…这道题其实可以看作length-1条有序数组的排序。所以可以使用归并来处理，使用一个小根堆管理所有数组的第一个数字，此时这个堆中包含所有数组的最小数，所以当弹出时必定为整体的最小数。我们要做的就是弹出k个堆顶，每次弹出时加入数组的后一个数字。</p>
<h1 id="归并排序代码"><a href="#归并排序代码" class="headerlink" title="归并排序代码"></a>归并排序代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int[] kthSmallestPrimeFraction(int[] arr, int k) &#123;</span><br><span class="line">        int n = arr.length;</span><br><span class="line">        //制定小根堆的规则</span><br><span class="line">        PriorityQueue&lt;int[]&gt; q = new PriorityQueue&lt;&gt;((a,b)-&gt;&#123;</span><br><span class="line">            double i1 = arr[a[0]] * 1.0 / arr[a[1]], i2 = arr[b[0]] * 1.0 / arr[b[1]];</span><br><span class="line">            return Double.compare(i1, i2);</span><br><span class="line">        &#125;);</span><br><span class="line">        //加入所有数组的第一个数</span><br><span class="line">        for (int i = 1; i &lt; n; i++) q.add(new int[]&#123;0, i&#125;);</span><br><span class="line">        while (k-- &gt; 1) &#123;</span><br><span class="line">            //弹出堆顶，加入这个数的下一个数</span><br><span class="line">            int[] poll = q.poll();</span><br><span class="line">            int i = poll[0], j = poll[1];</span><br><span class="line">            if (i + 1 &lt; j) q.add(new int[]&#123;i + 1, j&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        int[] poll = q.poll();</span><br><span class="line">        return new int[]&#123;arr[poll[0]], arr[poll[1]]&#125;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode解析</category>
        <category>困难</category>
      </categories>
      <tags>
        <tag>堆</tag>
        <tag>归并</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title>javaweb</title>
    <url>/2021/11/28/javaweb/</url>
    <content><![CDATA[<h1 id="html和css"><a href="#html和css" class="headerlink" title="html和css"></a>html和css</h1><span id="more"></span>
<h2 id="html常用标签"><a href="#html常用标签" class="headerlink" title="html常用标签"></a>html常用标签</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;br/&gt;换行</span><br><span class="line">&lt;hr/&gt;水平线</span><br><span class="line">&lt;front&gt;&lt;/front&gt;修改文本大小，颜色，样式(color,face,size)</span><br><span class="line">&lt;h1-6&gt;1-6标题(align=对齐方式)</span><br><span class="line">&lt;a&gt;&lt;/a&gt;超链接(herf=域名,target=选择发生跳转的页面)</span><br><span class="line">&lt;ul&gt;&lt;/ul&gt;无序列表</span><br><span class="line">&lt;li&gt;&lt;/li&gt;列表项</span><br><span class="line">&lt;img/&gt;图片(src=路径,width=宽,height=高,border=边框宽度,alt=图片消失时提示)</span><br><span class="line">&lt;ifanme&gt;&lt;/ifanme&gt;子页面(src=子页面文件路径,width,height,name用于超链接选择target)</span><br><span class="line">文本</span><br><span class="line">&lt;div&gt;&lt;/div&gt;默认独占一行</span><br><span class="line">&lt;span&gt;&lt;/span&gt;长度为封装数据的长度</span><br><span class="line">&lt;p&gt;&lt;/p&gt;上下各占一行</span><br><span class="line">表格</span><br><span class="line">&lt;table&gt;&lt;/table&gt;表格(align,border,width,height,cellspacing=单元格间距)</span><br><span class="line">&lt;tr&gt;&lt;/tr&gt;表格行</span><br><span class="line">&lt;th&gt;&lt;/th&gt;居中加粗的单元格</span><br><span class="line">&lt;td&gt;&lt;/td&gt;单元格(align,colspan=行占用单元格数量,rowspan=列占用单元格数量)</span><br><span class="line">&lt;b&gt;&lt;/b&gt;加粗</span><br><span class="line">表单</span><br><span class="line">&lt;from&gt;&lt;/form&gt;表单(action=提交的服务器地址,method=get/post提交方式)</span><br><span class="line">&lt;input/&gt;输入栏(type=输入类型,value=默认值)</span><br><span class="line">&lt;input/&gt;单选框(type=&quot;radio&quot;,name=分组)</span><br><span class="line">&lt;select&gt;&lt;/select&gt;下拉列框</span><br><span class="line">&lt;option&gt;&lt;/option&gt;选项</span><br><span class="line">&lt;textarea&gt;&lt;/textarea&gt;多行文本输入框(row,cols= 每行字数)</span><br><span class="line">&lt;input type=&quot;reset&quot; value=&quot;重置&quot;/&gt;</span><br><span class="line">&lt;input type=&quot;sbmit&quot; value=&quot;提交&quot;/&gt;</span><br><span class="line">表单提交时，数据没发给服务器的三种情况：</span><br><span class="line">1.没有使用name命名</span><br><span class="line">2.单选、复选、下拉列表的选项都需要添加value属性</span><br><span class="line">3.表单项不在form中</span><br></pre></td></tr></table></figure>
<h2 id="常用字符实体"><a href="#常用字符实体" class="headerlink" title="常用字符实体"></a>常用字符实体</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">空格：&amp;nbsp;</span><br><span class="line">小于号：&amp;lt;</span><br><span class="line">大于号：&amp;gt;</span><br><span class="line">双引号：&amp;quot;</span><br><span class="line">单引号：&amp;apos;</span><br></pre></td></tr></table></figure>
<h2 id="css和html的结合"><a href="#css和html的结合" class="headerlink" title="css和html的结合"></a>css和html的结合</h2><p>1.在标签的style属性上设置”key:value value”,修改标签样式<br>2.在head标签中使用style标签定义，style标签中使用css语法。<br>3.把css样式写为一个文件，通过link标签引入。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;link rel = &quot;stylesheet&quot;type=&quot;text/css&quot;href&quot;文件路径&quot;/&gt;</span><br></pre></td></tr></table></figure>
<h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><p>1.标签选择器: 标签名{}<br>2.id选择器： #id{}<br>3.class选择器： .class{}<br>4.组合选择器<br>class选择器与id选择器的区别：id选择器的值是唯一的，class选择器可以多标签公用。</p>
<h1 id="js"><a href="#js" class="headerlink" title="js"></a>js</h1><h2 id="js和html代码的结合"><a href="#js和html代码的结合" class="headerlink" title="js和html代码的结合"></a>js和html代码的结合</h2><p>1.在head或者body标签中使用script标签写js代码<br>2.使用script标签引入js文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;path&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="与java语法不同部分"><a href="#与java语法不同部分" class="headerlink" title="与java语法不同部分"></a>与java语法不同部分</h2><p>赋值使用var对任意类型赋值。<br>==与===，前者只比较字面值，后者比较数值与类型。<br>逻辑运算与c相同，所有数值可做布尔类型变量。0，null，undefined，””为false。<br>&amp;&amp;运算，当表达式全为真时返回最后一个表达式的值，有假式返回第一个为假的表达式值。<br>||运算，当表达式全为假时返回最后一个表达式的值，有真时返回第一个为真的表达式值。<br>数组中可以放类型不同的数据，且长度可变。 var arr = [];<br>函数定义：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function 函数名(形参)&#123;&#125;</span><br><span class="line">var 函数名 = function(形参)&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>函数不允许重载，只会覆盖。<br>所有js函数都有隐藏参数arguments，等于java的Object…，所有参数都在他的数组中。<br>对象的定义方法与c语言结构体类似，不同的是可以在其中定义函数。</p>
<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p>事件分为静态注册与动态注册。<br>onload 加载完成事件(body)<br>onclick 单机事件(button)<br>onblur 失去焦点事件(input)<br>onchange 内容改变事件(select,input)<br>onsubmit 提交事件(form)(通过返回false阻止提交事件)</p>
<h2 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h2><p>document文件通过树结构管理所有html中的对象(所有标签对象化)<br>document结构及方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var document&#123;</span><br><span class="line">	var id = ;</span><br><span class="line">	var tagName= ;</span><br><span class="line">	var parentNode= ;</span><br><span class="line">	var children= ;</span><br><span class="line">	var value= ;</span><br><span class="line">	var tpye= ;</span><br><span class="line">	var innerHTML= ;(起始标签到终止标签的中间内容)</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line">document.getElementById()</span><br><span class="line">//下面的两种返回的是集合，操作与数组相同</span><br><span class="line">document.getElementsByName()</span><br><span class="line">document.getElementsByTagName(标签名)</span><br><span class="line">document.createElement(标签名)</span><br></pre></td></tr></table></figure>
<p>因为语句是从上往下执行，非函数内取得dom对象时可能对象还未创建，要想在外部取得，一般置于window.onload = function(){}中。</p>
<h2 id="正则表达式对文本的验证"><a href="#正则表达式对文本的验证" class="headerlink" title="正则表达式对文本的验证"></a>正则表达式对文本的验证</h2><p><a href="https://390991450.github.io/2021/11/29/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/#more">正则表达的规则</a><br>正则表达式判断用户名是否合法案例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;html lang=&quot;zh_CN&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;标题&lt;/title&gt;</span><br><span class="line">    &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">        function onclickFun()&#123;</span><br><span class="line">            var usernameObj = document.getElementById(&quot;username&quot;);</span><br><span class="line">            var userText = usernameObj.value;</span><br><span class="line">            var patt = /^\w&#123;5,12&#125;$/;</span><br><span class="line">            var spanObj = document.getElementById(&quot;tips&quot;);</span><br><span class="line">            if (patt.test(userText))&#123;</span><br><span class="line">                spanObj.innerHTML = &quot;输入正确&quot;</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                spanObj.innerHTML = &quot;请输入正确的用户名&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    用户名：&lt;input type=&quot;text&quot; id=&quot;username&quot;/&gt;</span><br><span class="line">&lt;!--这个属于静态注册--&gt;</span><br><span class="line">    &lt;span id=&quot;tips&quot; style=&quot;color: red;&quot;&gt;&lt;/span&gt;</span><br><span class="line">&lt;!--    这个属于动态注册--&gt;</span><br><span class="line">    &lt;button onclick=&quot;onclickFun()&quot;&gt;校验&lt;/button&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<h2 id="节点的常用方法或属性"><a href="#节点的常用方法或属性" class="headerlink" title="节点的常用方法或属性"></a>节点的常用方法或属性</h2><table>
<thead>
<tr>
<th>方法或属性</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>getElementsByTagName()</td>
<td>获取当前节点指定标签类型的子节点</td>
</tr>
<tr>
<td>appendChild(字节点)</td>
<td>添加一个字节点</td>
</tr>
<tr>
<td>childNodes</td>
<td>获取当前节点的所有子节点</td>
</tr>
<tr>
<td>firstChild</td>
<td>取得第一个字节点</td>
</tr>
<tr>
<td>lastChile</td>
<td>取得最后一个子节点</td>
</tr>
<tr>
<td>parentNode</td>
<td>取得当前父节点</td>
</tr>
<tr>
<td>nextSibling</td>
<td>取得下一个节点</td>
</tr>
<tr>
<td>previousSibling</td>
<td>取得上一个节点</td>
</tr>
<tr>
<td>className</td>
<td>获取或设置标签的class属性</td>
</tr>
<tr>
<td>innerHTML</td>
<td>获取或设置起始标签到结束标签的内容(可以有其他标签)</td>
</tr>
<tr>
<td>innerText</td>
<td>获取或设置起始标签到结束标签的文本</td>
</tr>
</tbody></table>
<h1 id="“jQuery”"><a href="#“jQuery”" class="headerlink" title="“jQuery”"></a>“jQuery”</h1><h2 id="核心函数"><a href="#核心函数" class="headerlink" title="核心函数"></a>核心函数</h2><p>1.传入参数为函数时：表示页面加载完成之后。相当于window.onload = function(){}<br>2.传入参数为HTML字符串时：会帮我们创建这些HTML标签插入到指定位置。$().appendto(标签);<br>3.传入参数为选择器字符串时：根据选择器样式用对应方法查询dom对象。(也可以填入组合选择器”,”表示或”.”表示且。结果顺序为页面中的顺序)<br>4.传入参数为dom时：会把这个对象转化为”jQuery”对象</p>
<h2 id="“jQuery”对象及方法"><a href="#“jQuery”对象及方法" class="headerlink" title="“jQuery”对象及方法"></a>“jQuery”对象及方法</h2><p>“jQuery”对象本质是dom对象的数组，同时封装了一系列函数。所有dom对象经由”jQuery”获得时都会被封装为”jQuery”对象，取得时使用index取得。<br>使用”jQuery”对象注册事件时不再需要使用动态或静态注册，而是通过调用”jQuery”所带的事件方法实现对象注册。</p>
<h3 id="属性获取"><a href="#属性获取" class="headerlink" title="属性获取"></a>属性获取</h3><table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>$(function(){})</td>
<td>页面加载完成事件</td>
</tr>
<tr>
<td>.val()</td>
<td>获取，修改“表单项”的value</td>
</tr>
<tr>
<td>.val([“value”])</td>
<td>指定表单项被选中的项(单复选框，下拉列表)</td>
</tr>
<tr>
<td>.html()</td>
<td>设置和获取所有dom的innerHTML</td>
</tr>
<tr>
<td>.text()</td>
<td>设置和获取所有dom的text</td>
</tr>
<tr>
<td>.attr()</td>
<td>设置和获取指定属性值(一个参数为获取，两个参数为设置，可以设置未定义属性)</td>
</tr>
<tr>
<td>.prop()</td>
<td>设置和获取指定属性值(可处理checked等会出现undefined情况的属性)</td>
</tr>
<tr>
<td>.each()</td>
<td>遍历dom对象,用this取得</td>
</tr>
</tbody></table>
<h3 id="增删改"><a href="#增删改" class="headerlink" title="增删改"></a>增删改</h3><table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>a.appendTo(b)</td>
<td>把a插入到b的子元素，成为最后一个子元素</td>
</tr>
<tr>
<td>a.prependTo(b)</td>
<td>把a插入到b的子元素，成为第一个子元素</td>
</tr>
<tr>
<td>a.insertAfter(b)</td>
<td>-</td>
</tr>
<tr>
<td>a.insertBefore</td>
<td>-</td>
</tr>
<tr>
<td>a.replaceWith(b)</td>
<td>用b替换a</td>
</tr>
<tr>
<td>a.replaceAll(b)</td>
<td>用a替换b</td>
</tr>
<tr>
<td>a.remove()</td>
<td>删除a</td>
</tr>
<tr>
<td>a.empty()</td>
<td>清空a内容</td>
</tr>
</tbody></table>
<h3 id="css样式"><a href="#css样式" class="headerlink" title="css样式"></a>css样式</h3><table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>.css(“key”,”value”…)</td>
<td>为当前”jQuery”中对象设置样式</td>
</tr>
<tr>
<td>.addClass()</td>
<td>添加样式</td>
</tr>
<tr>
<td>.removeClass()</td>
<td>移除样式</td>
</tr>
<tr>
<td>.toggleClass()</td>
<td>有就删除，没有就添加样式</td>
</tr>
<tr>
<td>.offset()</td>
<td>返回坐标(左上角作为坐标)</td>
</tr>
</tbody></table>
<h3 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h3><p>第一个参数为时间，第二个为回调函数(动画结束后调用的函数)。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>.show()</td>
<td>将隐藏显示</td>
</tr>
<tr>
<td>.hide()</td>
<td>-</td>
</tr>
<tr>
<td>.toggle()</td>
<td>-</td>
</tr>
<tr>
<td>.fadeIn()</td>
<td>淡入</td>
</tr>
<tr>
<td>.fadeOut()</td>
<td>-</td>
</tr>
<tr>
<td>.fadeTo()</td>
<td>指定时间内到指定透明度</td>
</tr>
</tbody></table>
<h3 id="事件-1"><a href="#事件-1" class="headerlink" title="事件"></a>事件</h3><table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>.click(function(){})</td>
<td>有函数为绑定单击事件，无函数为触发事件</td>
</tr>
<tr>
<td>.blur(function(){})</td>
<td>失去焦点事件</td>
</tr>
<tr>
<td>.load(function(){})</td>
<td>加载事件</td>
</tr>
<tr>
<td>.change(function(){})</td>
<td>内容改变事件</td>
</tr>
<tr>
<td>.submit(function(){})</td>
<td>提交事件</td>
</tr>
<tr>
<td>.mouseover(function(){})</td>
<td>鼠标移入事件</td>
</tr>
<tr>
<td>.mouseout(function(){})</td>
<td>鼠标移出事件</td>
</tr>
<tr>
<td>.bind(‘一个或多个事件’,function(){})</td>
<td>绑定事件，多个时用空格隔开</td>
</tr>
<tr>
<td>.one()</td>
<td>与bind使用方法相同，但每个事件只能响应一次</td>
</tr>
<tr>
<td>.unbind()</td>
<td>与bind相反，解除事件绑定</td>
</tr>
<tr>
<td>.live()</td>
<td>用于绑定事件，特点是即使这个元素是后面发生修改或才动态创建出来的也能绑定</td>
</tr>
</tbody></table>
<h3 id="选择器-1"><a href="#选择器-1" class="headerlink" title="选择器"></a>选择器</h3><table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>层级选择器</td>
<td></td>
</tr>
<tr>
<td>$(“基本选择器1 基本选择器2”)</td>
<td>获取所有在标签1中的所有标签2</td>
</tr>
<tr>
<td>$(“基本选择器1 基本选择器2”)</td>
<td>获取父标签是标签1的所有标签2</td>
</tr>
<tr>
<td>$(“基本选择器1 + 基本选择器2”)</td>
<td>获取上一个兄弟标签是标签1的所有标签2</td>
</tr>
<tr>
<td>$(“基本选择器1 ~ 基本选择器2”)</td>
<td>获取标签1后的所有同级的标签2</td>
</tr>
<tr>
<td>基本过滤选择器</td>
<td></td>
</tr>
<tr>
<td>$(“基本选择器1:first”)</td>
<td>获取第一个标签1</td>
</tr>
<tr>
<td>$(“基本选择器1:last”)</td>
<td>获取最后一个标签1</td>
</tr>
<tr>
<td>$(“基本选择器1:even”)</td>
<td>获取所有index为偶数的标签1</td>
</tr>
<tr>
<td>$(“基本选择器1:odd”)</td>
<td>-</td>
</tr>
<tr>
<td>$(“基本选择器1:eq(index)”)</td>
<td>-</td>
</tr>
<tr>
<td>$(“基本选择器1:gt(index)”)</td>
<td>获取所有index大于这个index的标签1</td>
</tr>
<tr>
<td>$(“基本选择器1:lt(index)”)</td>
<td>获取所有index小于这个index的标签1</td>
</tr>
<tr>
<td>$(“:header”)</td>
<td>获取所有标题元素</td>
</tr>
<tr>
<td>$(“:animated”)</td>
<td>获取所有在执行动画的标签</td>
</tr>
<tr>
<td>$(“基本选择器1:not(…)”)</td>
<td>相当于上面操作的取反</td>
</tr>
<tr>
<td>内容过滤选择器</td>
<td></td>
</tr>
<tr>
<td>$(“基本选择器:contains(‘str’)”)</td>
<td>获取文本内容包含str的标签</td>
</tr>
<tr>
<td>$(“基本选择器:empty”)</td>
<td>获取文本内容为空的标签</td>
</tr>
<tr>
<td>$(“基本选择器:parent”)</td>
<td>获取文本内容不为空或者有子元素的标签</td>
</tr>
<tr>
<td>$(“基本选择器1:has(选择器2)”)</td>
<td>获取子元素有标签2的所有标签1</td>
</tr>
<tr>
<td>属性过滤选择器</td>
<td></td>
</tr>
<tr>
<td>$(“基本选择器[属性名]”)</td>
<td>获取包含这个属性的标签</td>
</tr>
<tr>
<td>$(“基本选择器[属性名=’value’]”)</td>
<td>-</td>
</tr>
<tr>
<td>$(“基本选择器[属性名!=’value’]”)</td>
<td>获取不含有这属性和有这个属性但值不匹配的标签</td>
</tr>
<tr>
<td>$(“基本选择器[属性名^=’value’]”)</td>
<td>获取有这个属性，且属性值以此开始的标签</td>
</tr>
<tr>
<td>$(“基本选择器[属性名*=’value’]”)</td>
<td>获取有这个属性，且包含属性值的标签</td>
</tr>
<tr>
<td>$(“基本选择器[][]…”)</td>
<td>多重选择</td>
</tr>
<tr>
<td>表单过滤选择器</td>
<td></td>
</tr>
<tr>
<td>$(“:type类型”)</td>
<td>选择type类型符合的标签</td>
</tr>
<tr>
<td>$(“:enabled”)</td>
<td>选择可用的标签</td>
</tr>
<tr>
<td>$(“:disabled”)</td>
<td>选择不可用的标签</td>
</tr>
<tr>
<td>$(“:checked”)</td>
<td>选择所有选择的标签(单选复选框)</td>
</tr>
<tr>
<td>$(“:selected”)</td>
<td>匹配所有选择的option元素</td>
</tr>
<tr>
<td>元素筛选</td>
<td></td>
</tr>
<tr>
<td>.eq()</td>
<td>-</td>
</tr>
<tr>
<td>.first()</td>
<td>-</td>
</tr>
<tr>
<td>.last()</td>
<td>-</td>
</tr>
<tr>
<td>.filter(exp)</td>
<td>再次过滤</td>
</tr>
<tr>
<td>.is(exp)</td>
<td>判断是否满足这个选择器,一个为真即为真</td>
</tr>
<tr>
<td>.has(exp)</td>
<td>返回子元素满足选择器的元素</td>
</tr>
<tr>
<td>.not(exp)</td>
<td>删除满足选择器的元素</td>
</tr>
<tr>
<td>.children(exp)</td>
<td>返回此元素中满足此选择器的子元素</td>
</tr>
<tr>
<td>.find(exp)</td>
<td>返回此元素中满足此选择器的后代元素</td>
</tr>
<tr>
<td>.next()</td>
<td>-</td>
</tr>
<tr>
<td>.nextAll()</td>
<td>-</td>
</tr>
<tr>
<td>.nextUntil()</td>
<td>-</td>
</tr>
<tr>
<td>.parent()</td>
<td>-</td>
</tr>
<tr>
<td>.prev(exp)</td>
<td>-</td>
</tr>
<tr>
<td>.prevAll()</td>
<td>-</td>
</tr>
<tr>
<td>.prevUntil()</td>
<td>-</td>
</tr>
<tr>
<td>.siblings(exp)</td>
<td>-</td>
</tr>
<tr>
<td>.add(exp)</td>
<td>向当前”jQuery”加入满足选择器的元素</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>java web</category>
      </categories>
  </entry>
  <entry>
    <title>第n位数字</title>
    <url>/2021/11/30/%E7%AC%ACn%E4%BD%8D%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给你一个整数n，请你在无限的整数序列[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, …]中找出并返回第n位上的数字。</p>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>本题有时间限制，所以要找到一些规律：n位数字中有n<em>9</em>10^(n-1)位数字，根据这个规律判断数字的位数。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int findNthDigit(int n) &#123;</span><br><span class="line">        if (n&lt;10)&#123;</span><br><span class="line">            return n;</span><br><span class="line">        &#125;</span><br><span class="line">        //答案的长度</span><br><span class="line">        int numLength = 0;</span><br><span class="line">        //可能范围,使用long防止溢出</span><br><span class="line">        long count = 0;</span><br><span class="line">        while (count&lt;n)&#123;</span><br><span class="line">            numLength++;</span><br><span class="line">            count+=numLength*9*Math.pow(10,numLength-1);</span><br><span class="line">        &#125;</span><br><span class="line">        count-=numLength*9*Math.pow(10,numLength-1);</span><br><span class="line">        //判断第几位数字</span><br><span class="line">        int k = (int) (n-count)%numLength;</span><br><span class="line">        if (k==0)&#123;</span><br><span class="line">            k=numLength;</span><br><span class="line">        &#125;</span><br><span class="line">        //判断第几个数字</span><br><span class="line">        int index = (int) (n-count+1)/numLength;</span><br><span class="line">        //找到这个数字</span><br><span class="line">        int answerNum = (int) Math.pow(10,numLength-1)+index-1;</span><br><span class="line">        return Integer.valueOf(String.valueOf(answerNum).substring(k-1,k));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode解析</category>
        <category>中等</category>
      </categories>
      <tags>
        <tag>数学分析</tag>
      </tags>
  </entry>
</search>
