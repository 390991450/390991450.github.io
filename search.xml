<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>sqrt</title>
    <url>/2021/12/02/leetcode%E9%A2%98%E8%A7%A3/sqrt/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给你一个非负整数x，计算并返回x的算术平方根 。<br>由于返回类型是整数，结果只保留整数部分，小数部分将被舍去。</p>
<span id="more"></span>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>因为答案一定在0-x之间，所以可以使用二分查找。再对right上限设定为46340，针对溢出。<br>关于mid的设置应该是(right+left)/2还是(right+left+1)/2，因为两个数字的情况下要保留前面的数字，所以要让指针指向后面的数字以便舍弃。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int mySqrt(int x) &#123;</span><br><span class="line">        int left = 0;</span><br><span class="line">        int right = x;</span><br><span class="line">        if (right&gt;46340)&#123;</span><br><span class="line">            right = 46340;</span><br><span class="line">        &#125;</span><br><span class="line">        while (left!=right)&#123;</span><br><span class="line">            int mid = (left+right+1)/2;</span><br><span class="line">            if (mid*mid==x)&#123;</span><br><span class="line">                return mid;</span><br><span class="line">            &#125;else if (mid*mid&gt;x)&#123;</span><br><span class="line">                right = mid-1;</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                left = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return left;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode解析</category>
        <category>简单</category>
      </categories>
      <tags>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>z字形变换</title>
    <url>/2021/11/22/leetcode%E9%A2%98%E8%A7%A3/z%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><pre><code>    将一个给定字符串s根据给定的行数numRows，以从上往下、从左到右进行Z字形排列。
    比如输入字符串为 &quot;PAYPALISHIRING&quot;行数为3时，排列如下：
    P   A   H   N
    A P L S I I G
    Y   I   R
    之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：&quot;PAHNAPLSIIGYIR&quot;。
</code></pre>
<span id="more"></span>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>寻找这种排布的规律。会发现每排字符的index与其所在行，以及总行数形成函数关系。<br>首先分析第一排：第一排的index差为2*(总行数-1)。<br>分析最后一排：与第一排规律相同。<br>其他排：每隔一个字符看与第一排的规律也相同，而相邻的字符存在关系，如第二个字符与第三个<br>字符间刚好差2*(当前行数-1)。则第一个字符与第二的字符的差就是：2*(总行数-1)-2*(当前行数-1)。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public String convert(String s, int numRows) &#123;</span><br><span class="line">        //如果长度为1，则直接返回</span><br><span class="line">        if (numRows == 1)&#123;</span><br><span class="line">            return s;</span><br><span class="line">        &#125;</span><br><span class="line">        char[] chars = s.toCharArray();</span><br><span class="line">        char[] answer = new char[chars.length];</span><br><span class="line">        int count = 0;</span><br><span class="line">        for (int i = 0;i&lt;numRows;i++)&#123;</span><br><span class="line">            int j= i;</span><br><span class="line">            while (j&lt;chars.length)&#123;</span><br><span class="line">                answer[count] = chars[j];</span><br><span class="line">                count++;</span><br><span class="line">                //统一处理n的两边数字，特别处理腰部的数字</span><br><span class="line">                if(!(i == 0||i == numRows-1))&#123;</span><br><span class="line">                    if ((2*numRows-2-2*i+j) &lt; chars.length) &#123;</span><br><span class="line">                        answer[count] = chars[2*numRows-2-2*i+j];</span><br><span class="line">                        count++;</span><br><span class="line">                        &#125;  </span><br><span class="line">                    &#125;</span><br><span class="line">                    j += (2*numRows-2);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return new String(answer);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode解析</category>
        <category>中等</category>
      </categories>
      <tags>
        <tag>数学分析</tag>
      </tags>
  </entry>
  <entry>
    <title>三数之和</title>
    <url>/2021/11/25/leetcode%E9%A2%98%E8%A7%A3/%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给你一个包含 n 个整数的数组nums，判断nums中是否存在三个元素 a，b，c ，使得a+b+c=0？<br>请你找出所有和为0 且不重复的三元组。<br>注意：答案中不可以包含重复的三元组。</p>
<span id="more"></span>
<h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>本题主要难度在于如何去重。首先将数组排序，从数组左方取出第一个数字，且每次取到的数字不能为重复。<br>接着从第一个数字右方取出第二个数字，从第二数字右方找到第三个数。<br>然后着手算法的优化，因为数组是排序好的，所以第三个数字可以使用二分查找。<br>因为三数和为0，且num1&lt; num2 &lt; num3，当num1大于0时不可能有解直接结束循环。<br>当num1+num2大于0时不可能有解。<br>当数组第一个数大于0或者末位小于0，或者数组长度小于3，为空解直接返回空。<br>因为for循环查询长度较长，考虑使用增强for循环。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123;</span><br><span class="line">        ArrayList&lt;List&lt;Integer&gt;&gt; lists = new ArrayList&lt;&gt;();</span><br><span class="line">        if (nums.length&lt;3)&#123;</span><br><span class="line">            return lists;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        //当数组第一个数大于0或者末位小于0，或者数组长度小于3，为空解直接返回空。</span><br><span class="line">        if (nums[0]&gt;0||nums[nums.length-1]&lt;0)&#123;</span><br><span class="line">            return lists;</span><br><span class="line">        &#125;</span><br><span class="line">        //首先将数组排序，从数组左方取出第一个数字，且每次取到的数字不能为重复。</span><br><span class="line">        int answer1 = 100001;</span><br><span class="line">        int answer2 = 100001;</span><br><span class="line">        int i = 0;</span><br><span class="line">        for (int num1:nums)&#123;</span><br><span class="line">            if (num1 == answer1)&#123;</span><br><span class="line">                i++;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            //因为三数和为0，且num1&lt; num2 &lt; num3，当num1大于0时不可能有解直接结束循环。</span><br><span class="line">            if (num1&gt;0)&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            answer1 = num1;</span><br><span class="line">            i++;</span><br><span class="line">            //接着从第一个数字右方取出第二个数字，从第二数字右方找到第三个数。</span><br><span class="line">            for (int j = i;j&lt; nums.length-1;j++)&#123;</span><br><span class="line">                if (j&gt;i&amp;&amp;nums[j] == answer2)&#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                //因为数组是排序好的，所以第三个数字可以使用二分查找。</span><br><span class="line">                answer2 = nums[j];</span><br><span class="line">                if (answer1+answer2&gt;0)&#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                int answer3 = 0-answer1-answer2;</span><br><span class="line">                int k = Arrays.binarySearch(nums,j+1,nums.length,answer3);</span><br><span class="line">                if (k&gt;0)&#123;</span><br><span class="line">                    lists.add(Arrays.asList(answer1,answer2,answer3));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return lists;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode解析</category>
        <category>中等</category>
      </categories>
      <tags>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>两数之和</title>
    <url>/2021/11/22/leetcode%E9%A2%98%E8%A7%A3/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><pre><code>    给定一个整数数组 nums和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那两个整数，并返回它们的数组下标。
    你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。
    你可以按任意顺序返回答案
</code></pre>
<h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>本题主要提供一种使用hashmap的key的思路。使map接收到一个数的差又不会接收它本身。</p>
<span id="more"></span>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">int</span>[] twoSum(<span class="built_in">int</span>[] nums, <span class="built_in">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">HashMap</span>&lt;Integer,<span class="keyword">Object</span>&gt; <span class="built_in">map</span> = <span class="keyword">new</span> <span class="keyword">HashMap</span>();</span><br><span class="line">        <span class="comment">//key种存放一个数字，value存放合适的数组</span></span><br><span class="line">        <span class="built_in">int</span>[] answer = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">        	<span class="comment">//这里为核心思路</span></span><br><span class="line">             <span class="keyword">if</span> (<span class="built_in">map</span>.containsKey(target-nums[i]))&#123;</span><br><span class="line">                <span class="built_in">int</span>[] ints = (<span class="built_in">int</span>[]) <span class="built_in">map</span>.<span class="built_in">get</span>(target-nums[i]);</span><br><span class="line">                ints[<span class="number">1</span>] = i;</span><br><span class="line">                answer = ints.clone();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">int</span>[] ints = &#123;i,<span class="number">0</span>&#125;;</span><br><span class="line">                <span class="built_in">map</span>.put(nums[i],ints );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode解析</category>
        <category>简单</category>
      </categories>
      <tags>
        <tag>hashmap</tag>
      </tags>
  </entry>
  <entry>
    <title>不同路径(m个a和n个b的组合问题)</title>
    <url>/2021/12/01/leetcode%E9%A2%98%E8%A7%A3/%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>一个机器人位于一个 m x n网格的左上角（起始点在下图中标记为“Start”）。<br>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。<br>问总共有多少条不同的路径？</p>
<span id="more"></span>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>通过分析可知，每个点位的路径是由上方点位和左方点位的路径和。所以可以制表求解。<br>有趣的是这道题也相当于求m-1个a和n-1个b的组合问题，这为这个问题的求解提供了一种方法，比递归求解要效率很多。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int uniquePaths(int m, int n) &#123;</span><br><span class="line">        int[][] ints = new int[m][n];</span><br><span class="line">        for (int i = 0;i&lt;m;i++)&#123;</span><br><span class="line">            ints[i][0]=1;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0;i&lt;n;i++)&#123;</span><br><span class="line">            ints[0][i]=1;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i=1;i&lt;m;i++)&#123;</span><br><span class="line">            for (int j=1;j&lt;n;j++)&#123;</span><br><span class="line">                ints[i][j] = ints[i-1][j]+ints[i][j-1];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ints[m-1][n-1];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode解析</category>
        <category>中等</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>之字型打印二叉树</title>
    <url>/2021/12/16/leetcode%E9%A2%98%E8%A7%A3/%E4%B9%8B%E5%AD%97%E5%9E%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。</p>
<span id="more"></span>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>首先使用队列实现层序遍历,然后我们使用size保证每次能把当前队列清空,这样就相当于进行了分层,最后使用一个对层数的计数器,在双数层反转list即可.</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">        //使用队列层序遍历</span><br><span class="line">        ArrayDeque&lt;TreeNode&gt; que = new ArrayDeque&lt;&gt;();</span><br><span class="line">        //一个节点出时要把它的左右子节点也放进去</span><br><span class="line">        if (root == null) &#123;</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line">        que.offer(root);</span><br><span class="line">        int layer = 0;</span><br><span class="line">        while (!que.isEmpty()) &#123;</span><br><span class="line">            List list = new ArrayList();</span><br><span class="line">            //每次把队列中的数取完即为取完了当前层</span><br><span class="line">            layer++;</span><br><span class="line">            int size = que.size();</span><br><span class="line">            for (int i = 0;i&lt;size;i++)&#123;</span><br><span class="line">            TreeNode node = que.pollFirst();</span><br><span class="line">            list.add(node.val);</span><br><span class="line">            if (node.left != null) &#123;</span><br><span class="line">                que.add(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            if (node.right != null) &#123;</span><br><span class="line">                que.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //如果layer是偶数,则反转链表</span><br><span class="line">            if (layer%2==0)&#123;</span><br><span class="line">                Collections.reverse(list);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(list);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode解析</category>
        <category>中等</category>
      </categories>
      <tags>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title>删除倒数第n个节点</title>
    <url>/2021/11/25/leetcode%E9%A2%98%E8%A7%A3/%E5%88%A0%E9%99%A4%E5%80%92%E6%95%B0%E7%AC%ACn%E4%B8%AA%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点</p>
<span id="more"></span>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>使用回溯，返回时开始计数，返回到父节点。方便操作，再添加一个伪父节点</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> ListNode removeNthFromEnd(ListNode head, <span class="built_in">int</span> n) &#123;</span><br><span class="line">        ListNode fhead = <span class="keyword">new</span> ListNode(<span class="number">0</span>,head);</span><br><span class="line">        trackback(fhead,n);</span><br><span class="line">        <span class="keyword">return</span> fhead.<span class="keyword">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> trackback(ListNode head,<span class="built_in">int</span> n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(head.<span class="keyword">next</span> != <span class="literal">null</span>)&#123;</span><br><span class="line">            trackback(head.<span class="keyword">next</span>,n);</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(num == n)&#123;</span><br><span class="line">            head.<span class="keyword">next</span> = head.<span class="keyword">next</span>.<span class="keyword">next</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode解析</category>
        <category>中等</category>
      </categories>
      <tags>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>从二叉树一个节点到另一个节点每一步的方向</title>
    <url>/2021/12/05/leetcode%E9%A2%98%E8%A7%A3/%E4%BB%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9%E5%88%B0%E5%8F%A6%E4%B8%80%E4%B8%AA/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给你一棵 二叉树的根节点root，这棵二叉树总共有n个节点。每个节点的值为1到n中的一个整数，且互不相同。给你一个整数startValue，表示起点节点 s的值，和另一个不同的整数destValue，表示终点节点t的值。<br>请找到从节点s到节点 t的 最短路径，并以字符串的形式返回每一步的方向。每一步用 大写字母’L’，’R’和’U’分别表示一种方向：<br>‘L’表示从一个节点前往它的 左孩子节点。<br>‘R’表示从一个节点前往它的 右孩子节点。<br>‘U’表示从一个节点前往它的 父节点。<br>请你返回从 s到 t最短路径每一步的方向。</p>
<span id="more"></span>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>这道题可以使用dfs对两个目标节点检索，检索的同时记录好路径。检索完毕后处理两个路径，首先把他们相同的首部分去除，这样就找到了他们相同的根节点，接着对第一条路径处理，把所有字符替换为U，两个字符串加和就是答案。但对java而言，因为这道题会给超大型树且有时间要求，必须对算法进行优化，因为String是final类型数据，每次加和字符串时就会在常量池重新创建新的字符串，所以要使用StringBuffer来对整个算法进行优化，使得不再超时。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">StringBuffer path;</span><br><span class="line">   StringBuffer path1;</span><br><span class="line">   public String get<span class="constructor">Directions(TreeNode <span class="params">root</span>, <span class="params">int</span> <span class="params">startValue</span>, <span class="params">int</span> <span class="params">destValue</span>)</span> &#123;</span><br><span class="line">       String anwer1;</span><br><span class="line">       String anwer2;</span><br><span class="line">       path = <span class="keyword">new</span> <span class="constructor">StringBuffer()</span>;</span><br><span class="line">       tree<span class="constructor">Search(<span class="params">root</span>,<span class="params">startValue</span>)</span>;</span><br><span class="line">       anwer1 = path1.<span class="keyword">to</span><span class="constructor">String()</span>;</span><br><span class="line">       tree<span class="constructor">Search(<span class="params">root</span>,<span class="params">destValue</span>)</span>;</span><br><span class="line">       anwer2 = path1.<span class="keyword">to</span><span class="constructor">String()</span>;</span><br><span class="line">       <span class="built_in">char</span><span class="literal">[]</span> chars1 = anwer1.<span class="keyword">to</span><span class="constructor">CharArray()</span>;</span><br><span class="line">       <span class="built_in">char</span><span class="literal">[]</span> chars2 = anwer2.<span class="keyword">to</span><span class="constructor">CharArray()</span>;</span><br><span class="line">       <span class="built_in">int</span> i =<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">while</span> (i&lt;chars1.length&amp;&amp;i&lt;chars2.length&amp;&amp;chars1<span class="literal">[<span class="identifier">i</span>]</span>==chars2<span class="literal">[<span class="identifier">i</span>]</span>)&#123;</span><br><span class="line">           i++;</span><br><span class="line">       &#125;</span><br><span class="line">       StringBuffer str1 = <span class="keyword">new</span> <span class="constructor">StringBuffer()</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="built_in">int</span> j = chars1.length-i;j&gt;<span class="number">0</span>;j--)&#123;</span><br><span class="line">           str1.append(<span class="character">&#x27;U&#x27;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       String str2 = anwer2.substring(i,anwer2.length<span class="literal">()</span>);</span><br><span class="line">       return str1+str2;</span><br><span class="line">   &#125;</span><br><span class="line">   public void tree<span class="constructor">Search(TreeNode <span class="params">root</span>,<span class="params">int</span> <span class="params">value</span>)</span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (root!=null)&#123;</span><br><span class="line">           <span class="keyword">if</span> (root.<span class="keyword">val</span>!=value)&#123;</span><br><span class="line">               path.append(<span class="character">&#x27;L&#x27;</span>);</span><br><span class="line">             tree<span class="constructor">Search(<span class="params">root</span>.<span class="params">left</span>,<span class="params">value</span>)</span>;</span><br><span class="line">             path.delete<span class="constructor">CharAt(<span class="params">path</span>.<span class="params">length</span>()</span>-<span class="number">1</span>);</span><br><span class="line">             path.append(<span class="character">&#x27;R&#x27;</span>);</span><br><span class="line">             tree<span class="constructor">Search(<span class="params">root</span>.<span class="params">right</span>,<span class="params">value</span>)</span>;</span><br><span class="line">             path.delete<span class="constructor">CharAt(<span class="params">path</span>.<span class="params">length</span>()</span>-<span class="number">1</span>);</span><br><span class="line">           &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">               path1 = <span class="keyword">new</span> <span class="constructor">StringBuffer(<span class="params">path</span>)</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode解析</category>
        <category>中等</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
        <tag>dfs</tag>
        <tag>StringBuffer</tag>
      </tags>
  </entry>
  <entry>
    <title>删除有序数组中的重复项</title>
    <url>/2021/12/06/leetcode%E9%A2%98%E8%A7%A3/%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给你一个有序数组nums ，请你原地删除重复出现的元素，使每个元素最多出现两次，返回删除后数组的新长度。<br>不要使用额外的数组空间，你必须在原地修改输入数组并在使用O(1)额外空间的条件下完成。</p>
<span id="more"></span>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>可以设计两个指针，慢指针指向填入的位置，快指针一直遍历，如果快指针的数字不是第三个数字，则放入，接着移动慢指针。<br>nums[slow-2]！=nums[fast]则说明这个数可以填入。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int removeDuplicates(int[] nums) &#123;</span><br><span class="line">        int slow = 2;</span><br><span class="line">        int fast = 2;</span><br><span class="line">        for (;fast&lt;nums.length&amp;&amp;slow&lt;nums.length;fast++)&#123;</span><br><span class="line">        	if(nums[slow-2]!= nums[fast])&#123;</span><br><span class="line">        		nums[slow] = nums [fast];</span><br><span class="line">        		slow++;</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;    </span><br><span class="line">        return slow;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode解析</category>
        <category>中等</category>
      </categories>
      <tags>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>包含min函数的栈</title>
    <url>/2021/12/10/leetcode%E9%A2%98%E8%A7%A3/%E5%8C%85%E5%90%AB/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)</p>
<span id="more"></span>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>维护一个小根堆,每次弹出时在小根堆检索删除.</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class MinStack &#123;</span><br><span class="line"></span><br><span class="line">    /** initialize your data structure here. */</span><br><span class="line">    Stack&lt;Integer&gt; stack;</span><br><span class="line">    PriorityQueue&lt;Integer&gt;  integers;</span><br><span class="line">    public MinStack() &#123;</span><br><span class="line">         stack = new Stack&lt;&gt;();</span><br><span class="line">        integers = new PriorityQueue&lt;&gt;((o1, o2) -&gt; o1.compareTo(o2));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void push(int x) &#123;</span><br><span class="line">        stack.push(x);</span><br><span class="line">        integers.offer(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void pop() &#123;</span><br><span class="line">        integers.remove(stack.pop());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int top() &#123;</span><br><span class="line">        return stack.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int min() &#123;</span><br><span class="line">        return integers.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode解析</category>
        <category>简单</category>
      </categories>
      <tags>
        <tag>优先级队列</tag>
        <tag>堆排序</tag>
      </tags>
  </entry>
  <entry>
    <title>区间内查询数字频率</title>
    <url>/2021/11/21/leetcode%E9%A2%98%E8%A7%A3/%E5%8C%BA%E9%97%B4%E5%86%85%E6%9F%A5%E8%AF%A2%E6%95%B0%E5%AD%97%E9%A2%91%E7%8E%87/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><pre><code>    请你设计一个数据结构，它能求出给定子数组内一个给定值的频率。
    子数组中一个值的频率指的是这个子数组中这个值的出现次数。
    请你实现RangeFreqQuery类：
    RangeFreqQuery(int[] arr)用下标从 0开始的整数数组arr构造一个类的实例。
    int query(int left, int right, int value)返回子数组arr[left...right]中value的频率。
    一个子数组指的是数组中一段连续的元素。arr[left...right]指的是 nums中包含下标left和
    right在内的中间一段连续元素。
</code></pre>
<span id="more"></span>
<pre><code>    输入：
    [&quot;RangeFreqQuery&quot;, &quot;query&quot;, &quot;query&quot;]
    [[[12, 33, 4, 56, 22, 2, 34, 33, 22, 12, 34, 56]], [1, 2, 4], [0, 11, 33]]
    输出：
    [null, 1, 2]
</code></pre>
<h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>这道题使用暴力算法很简单，但示例有时间和内存限制，必须对算法进行优化。<br>创建一个hashmap，key存储要查询的数字，value中存储一个list，list存储出现的位置。<br>即使这样优化也会超时，所以在遍历list的时候还要使用二分查找，在这里要深度理解二分查找。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RangeFreqQuery</span> </span>&#123;</span><br><span class="line">    int[] array;</span><br><span class="line">    <span class="comment">//ArrayList list;//存放数字出现频率</span></span><br><span class="line">    HashMap map;<span class="comment">//存放list的钥匙库</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> RangeFreqQuery(int[] arr) &#123;</span><br><span class="line">        array = <span class="keyword">new</span> <span class="type">int</span>[arr.length];</span><br><span class="line">        <span class="comment">//list = new ArrayList();</span></span><br><span class="line">        map = <span class="keyword">new</span> <span class="type">HashMap</span>();</span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!map.containsKey(arr[i]))&#123;</span><br><span class="line">                ArrayList list = <span class="keyword">new</span> <span class="type">ArrayList</span>();</span><br><span class="line">                list.add(i);</span><br><span class="line">                map.put(arr[i],list);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                ArrayList list = (ArrayList) map.<span class="keyword">get</span>(arr[i]);</span><br><span class="line">                list.add(i);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> int query(int left, int right, int value) &#123;</span><br><span class="line">        ArrayList list = (ArrayList) map.<span class="keyword">get</span>(value);</span><br><span class="line">        <span class="keyword">if</span> (list == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            int <span class="keyword">new</span><span class="type">right</span> = list.size()<span class="number">-1</span>;</span><br><span class="line">            int <span class="keyword">new</span><span class="type">left</span> = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//考虑两种找不到的情况。list的第一位比right大，list的末位比left小</span></span><br><span class="line">            <span class="keyword">if</span> ((int)list.<span class="keyword">get</span>(<span class="number">0</span>)&gt;right||(int)list.<span class="keyword">get</span>(<span class="keyword">new</span><span class="type">right</span>)&lt;left)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//使用二分查找左，右指针位置</span></span><br><span class="line">            <span class="comment">//找到的左指针要求其指向的数字&gt;=left，即指向left或者第一个大于它的数字</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">new</span><span class="type">left</span> != <span class="keyword">new</span><span class="type">right</span>)&#123;</span><br><span class="line">                int mid = (<span class="keyword">new</span><span class="type">left</span>+<span class="keyword">new</span><span class="type">right</span>)/<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span> ((int)list.<span class="keyword">get</span>(mid) &gt;= left)&#123;</span><br><span class="line">                    <span class="keyword">new</span><span class="type">right</span> = mid;<span class="comment">//因为目标数字最后总在截取范围的后段，需要不断舍去前半部分的数字</span></span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;			   <span class="comment">//所以mid尽量取小(left+right)/2。</span></span><br><span class="line">                    <span class="keyword">new</span><span class="type">left</span> = mid+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            int leftnum = <span class="keyword">new</span><span class="type">left</span>;</span><br><span class="line">            <span class="keyword">new</span><span class="type">right</span> = list.size()<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">new</span><span class="type">left</span> = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//找到的右指针要求其指向的数字&lt;=right，即指向right或者第一个小于它的数字</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">new</span><span class="type">left</span> != <span class="keyword">new</span><span class="type">right</span>)&#123;</span><br><span class="line">                int mid = (<span class="keyword">new</span><span class="type">left</span>+<span class="keyword">new</span><span class="type">right</span>+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span> ((int)list.<span class="keyword">get</span>(mid) &lt;= right)&#123;</span><br><span class="line">                    <span class="keyword">new</span><span class="type">left</span> = mid;<span class="comment">//因为目标数字最后总在截取范围的前段，需要不断舍去前后部分的数字</span></span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;			  <span class="comment">//所以mid尽量取大(left+right+1)/2。</span></span><br><span class="line">                    <span class="keyword">new</span><span class="type">right</span> = mid<span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            int rightnum = <span class="keyword">new</span><span class="type">right</span>;</span><br><span class="line">            <span class="keyword">return</span> rightnum-leftnum+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode解析</category>
        <category>困难</category>
      </categories>
      <tags>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>单词搜索</title>
    <url>/2021/12/06/leetcode%E9%A2%98%E8%A7%A3/%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定一个mxn二维字符网格board和一个字符串单词word。如果word存在于网格中，返回true；否则，返回 false 。<br>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p>
<span id="more"></span>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>这道题看后就知道应该是一个回溯和dfs，但重点在于如何剪枝以及不再走重复的格子。这里在dfs的开始进行剪枝，使用回溯对棋盘染色，确保不走重复路径。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int m;</span><br><span class="line">   int n;</span><br><span class="line">   char[][] board;</span><br><span class="line">   String word;</span><br><span class="line">   int length;</span><br><span class="line">   public boolean exist(char[][] board, String word) &#123;</span><br><span class="line">       this.m = board.length;</span><br><span class="line">       this.n = board[0].length;</span><br><span class="line">       this.board = board;</span><br><span class="line">       this.word = word;</span><br><span class="line">       length = word.length();</span><br><span class="line">       //找到字符串的开始</span><br><span class="line">       for (int i = 0;i&lt;m;i++)&#123;</span><br><span class="line">           for (int j = 0; j&lt; n;j++)&#123;</span><br><span class="line">               if (board[i][j]==word.charAt(0))&#123;</span><br><span class="line">                   if (dfs(i,j,0))&#123;</span><br><span class="line">                       return true;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return false;</span><br><span class="line">   &#125;</span><br><span class="line">   public boolean dfs(int i,int j,int length)&#123;</span><br><span class="line">       //判断是否检索完毕</span><br><span class="line">       if (length == this.length)&#123;</span><br><span class="line">           return true;</span><br><span class="line">       //判断数组是否越界</span><br><span class="line">       &#125;else if (i&lt;0||i&gt;=m||j&lt;0||j&gt;=n)&#123;</span><br><span class="line">           return false;</span><br><span class="line">       //判断字符是否合格</span><br><span class="line">       &#125;else if (board[i][j]==word.charAt(length))&#123;</span><br><span class="line">           //这里采用回溯思想，对走过的路进行染色，如果失败，则还原</span><br><span class="line">           char count = board[i][j];</span><br><span class="line">           board[i][j] = &#x27;*&#x27;;</span><br><span class="line">           length++;</span><br><span class="line">           boolean res = dfs(i-1,j,length)||dfs(i+1,j,length)||dfs(i,j-1,length)||dfs(i,j+1,length);</span><br><span class="line">           board[i][j] = count;</span><br><span class="line">           return res;</span><br><span class="line">       &#125;else &#123;</span><br><span class="line">           return false;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode解析</category>
        <category>中等</category>
      </categories>
      <tags>
        <tag>回溯</tag>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title>反转链表</title>
    <url>/2021/12/11/leetcode%E9%A2%98%E8%A7%A3/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。</p>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>使用两个指针,每次向后指针添加数据,后指针指向前指针,前指针再创建新指针指向后指针,如此重复.</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public ListNode reverseList(ListNode head) &#123;</span><br><span class="line">        ListNode pre = new ListNode();</span><br><span class="line">        while (head!=null)&#123;</span><br><span class="line">            ListNode point = pre;</span><br><span class="line">            point.val = head.val;</span><br><span class="line">            head = head.next;</span><br><span class="line">            pre = new ListNode();</span><br><span class="line">            pre.next = point;</span><br><span class="line">        &#125;</span><br><span class="line">        return pre.next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode解析</category>
        <category>简单</category>
      </categories>
      <tags>
        <tag>双指针</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>可怜的小猪</title>
    <url>/2021/11/25/leetcode%E9%A2%98%E8%A7%A3/%E5%8F%AF%E6%80%9C%E7%9A%84%E5%B0%8F%E7%8C%AA/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>有buckets桶液体，其中正好有一桶含有毒药，其余装的都是水。它们从外观看起来都一样。<br>为了弄清楚哪只水桶含有毒药，你可以喂一些猪喝，通过观察猪是否会死进行判断。不幸的是，<br>你只有minutesToTest分钟时间来确定哪桶液体是有毒的。<br>喂猪的规则如下：</p>
<span id="more"></span>
<p>选择若干活猪进行喂养,可以允许小猪同时饮用任意数量的桶中的水，并且该过程不需要时间。<br>小猪喝完水后，必须有minutesToDie分钟的冷却时间。在这段时间里，你只能观察，而不允许<br>继续喂猪。过了 minutesToDie 分钟后，所有喝到毒药的猪都会死去，其他所有猪都会活下来。<br>重复这一过程，直到时间用完。<br>给你桶的数目buckets，minutesToDie和minutesToTest，返回在规定时间内判断哪个桶有<br>毒所需的最小猪数。</p>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>这道题比较有意思，只要看到本质是很简单一道题。分析每只猪能带多少信息，如果有x轮，猪<br>可以在x中的一轮中死亡，或者不死亡。所以每只猪可以看作x+1进制的单位，只要能表示出10进<br>制的桶数即成功。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public <span class="built_in">int</span> poor<span class="constructor">Pigs(<span class="params">int</span> <span class="params">buckets</span>, <span class="params">int</span> <span class="params">minutesToDie</span>, <span class="params">int</span> <span class="params">minutesToTest</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">int</span> x = minutesToTest/minutesToDie+<span class="number">1</span>;</span><br><span class="line">        double temp = <span class="module-access"><span class="module"><span class="identifier">Math</span>.</span></span>log(buckets)/<span class="module-access"><span class="module"><span class="identifier">Math</span>.</span></span>log(x);</span><br><span class="line">        return (<span class="built_in">int</span>)<span class="module-access"><span class="module"><span class="identifier">Math</span>.</span></span>ceil(temp);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode解析</category>
        <category>困难</category>
      </categories>
      <tags>
        <tag>进制问题</tag>
      </tags>
  </entry>
  <entry>
    <title>合并两个有序数组</title>
    <url>/2021/12/12/leetcode%E9%A2%98%E8%A7%A3/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给你两个按非递减顺序排列的整数数组nums1和nums2，另有两个整数m和n，分别表示nums1和nums2中的元素数目。<br>请你合并nums2到nums1中，使合并后的数组同样按非递减顺序排列。<br>注意：最终，合并后数组不应由函数返回，而是存储在数组nums1中。为了应对这种情况，nums1的初始长度为m+n，其中前m 个元素表示应合并的元素，后n个元素为0，应忽略。nums2的长度为n。</p>
<span id="more"></span>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>这种情况最好的办法就是倒序放入.</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void merge(int[] nums1, int m, int[] nums2, int n) &#123;</span><br><span class="line">        //从后方放入数组</span><br><span class="line">        m--;</span><br><span class="line">        n--;</span><br><span class="line">        for (int i = nums1.length-1;i&gt;=0;i--)&#123;</span><br><span class="line">            if (n&lt;0)&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;else if (m&lt;0)&#123;</span><br><span class="line">                nums1[i] = nums2[n];</span><br><span class="line">                n--;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (nums1[m]&gt;nums2[n])&#123;</span><br><span class="line">                nums1[i] = nums1[m];</span><br><span class="line">                m--;</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                nums1[i] = nums2[n];</span><br><span class="line">                n--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode解析</category>
        <category>简单</category>
      </categories>
  </entry>
  <entry>
    <title>复杂链表的复制</title>
    <url>/2021/12/11/leetcode%E9%A2%98%E8%A7%A3/%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null。<br>注意:不可以使原链表发生变化</p>
<span id="more"></span>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>本题难点在于,有的random会指向还未创建的点,那么我们要做的就是先把整个链表搭建出来,再更新random属性.按暴力算法的话,需要每添加一个random值时遍历一次链表,时间复杂度太高.我们可以把新链表与旧链表连接起来,第一次遍历时创建,第二次遍历时修改random,第三次遍历时利用双指针再拆分为两个链表.</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public Node copyRandomList(Node head) &#123;</span><br><span class="line">        if (head==null)&#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        //创建一个新的链表,把新的复制链表插入到旧的链表中</span><br><span class="line">        //这样,它的random.next就是需要的random,这样全部处理完后再把新的链表取出</span><br><span class="line">        Node point = head;</span><br><span class="line">        while (point!=null)&#123;</span><br><span class="line">            Node node = new Node(point.val);</span><br><span class="line">            node.next = point.next;</span><br><span class="line">            node.random = point.random;</span><br><span class="line">            point.next = node;</span><br><span class="line">            point = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        Node req = head.next;</span><br><span class="line">        point = req;</span><br><span class="line">        //更新random</span><br><span class="line">        while (true)&#123;</span><br><span class="line">            if (point.random==null)&#123;</span><br><span class="line">                point.random = null;</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                point.random = point.random.next;</span><br><span class="line">            &#125;</span><br><span class="line">            if (point.next == null)&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            point = point.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        point = head;</span><br><span class="line">        Node point2 = req;</span><br><span class="line">        //设计count用于判断当前是哪个链,使用双指针移动方便成链</span><br><span class="line">        int count = 0;</span><br><span class="line">        while (true)&#123;</span><br><span class="line">            point.next = point.next.next;</span><br><span class="line">            point = point2.next;</span><br><span class="line">            if (point==null)&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            point2.next = point2.next.next;</span><br><span class="line">            point2 = point.next;</span><br><span class="line">        &#125;</span><br><span class="line">        return req;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode解析</category>
        <category>中等</category>
      </categories>
      <tags>
        <tag>双指针</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>子集</title>
    <url>/2021/12/04/leetcode%E9%A2%98%E8%A7%A3/%E5%AD%90%E9%9B%86/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给你一个整数数组nums，数组中的元素互不相同。返回该数组所有可能的子集（幂集）。<br>解集不能包含重复的子集。你可以按任意顺序返回解集。</p>
<span id="more"></span>
<h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>这道题如果长度固定就是最普通的回溯问题，所以只要把从0-数组长度的所有数字交给回溯即可。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">List&lt;List&lt;<span class="type">Integer</span>&gt;&gt; lists;</span><br><span class="line">ArrayList&lt;<span class="type">Integer</span>&gt; list;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">public</span> List&lt;List&lt;<span class="type">Integer</span>&gt;&gt; subsets(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="type">int</span> length = nums.length;</span><br><span class="line">        lists = <span class="built_in">new</span> ArrayList&lt;List&lt;<span class="type">Integer</span>&gt;&gt;();</span><br><span class="line">        list = <span class="built_in">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i&lt;=length;i++)&#123;</span><br><span class="line">            trackBack(nums,<span class="number">0</span>,i);</span><br><span class="line">            list.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lists;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">public</span> <span class="type">void</span> trackBack(<span class="type">int</span>[] nums,<span class="type">int</span> <span class="keyword">start</span>,<span class="type">int</span> length)&#123;</span><br><span class="line">        <span class="keyword">if</span> (list.size()&lt;length)&#123;</span><br><span class="line">            <span class="keyword">for</span> (;<span class="keyword">start</span>&lt;nums.length;<span class="keyword">start</span>++)&#123;</span><br><span class="line">                list.<span class="keyword">add</span>(nums[<span class="keyword">start</span>]);</span><br><span class="line">                trackBack(nums,<span class="keyword">start</span>+<span class="number">1</span>,length);</span><br><span class="line">                list.remove(list.size()<span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            List&lt;<span class="type">Integer</span>&gt; answer = <span class="built_in">new</span> ArrayList&lt;<span class="type">Integer</span>&gt;(this.list);</span><br><span class="line">            lists.<span class="keyword">add</span>(answer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode解析</category>
        <category>中等</category>
      </categories>
      <tags>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>打乱数组</title>
    <url>/2021/11/22/leetcode%E9%A2%98%E8%A7%A3/%E6%89%93%E4%B9%B1%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><pre><code>    给你一个整数数组 nums ，设计算法来打乱一个没有重复元素的数组。
    实现 Solution class:
    Solution(int[] nums) 使用整数数组 nums 初始化对象
    int[] reset() 重设数组到它的初始状态并返回
    int[] shuffle() 返回数组随机打乱后的结果
</code></pre>
<span id="more"></span>
<h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>本题没有难度，用于洗牌算法的学习</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int[] arr;</span><br><span class="line">  Random random = new Random();</span><br><span class="line">   public Solution(int[] nums) &#123;</span><br><span class="line">       arr = nums;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   public int[] reset() &#123;</span><br><span class="line">       return arr;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   public int[] shuffle() &#123;</span><br><span class="line">       int[] newArr = arr.clone();</span><br><span class="line">       //每次移动视为对当前位置随机成功</span><br><span class="line">       for(int i = 0;i&lt;arr.length;i++)&#123;</span><br><span class="line">       	//nextInt方法取到的数字为左闭右开区间</span><br><span class="line">           int num = i+random.nextInt(arr.length-i);</span><br><span class="line">           int cache = newArr[i];</span><br><span class="line">           newArr[i] = newArr[num];</span><br><span class="line">           newArr[num] = cache;</span><br><span class="line">       &#125;</span><br><span class="line">       return newArr;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode解析</category>
        <category>中等</category>
      </categories>
      <tags>
        <tag>洗牌算法</tag>
      </tags>
  </entry>
  <entry>
    <title>子集2</title>
    <url>/2021/12/13/leetcode%E9%A2%98%E8%A7%A3/%E5%AD%90%E9%9B%862/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给你一个整数数组nums，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。<br>解集不能包含重复的子集。返回的解集中，子集可以按任意顺序排列。</p>
<span id="more"></span>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>首先得知道如何取得固定长度的所有子集,写一个回溯算法.接着使用一个for循环调用这个回溯算法产生所有长度的所有子集.<br>然后再进行一次过滤去除重复,如何去除重复?我们可以把每次递归看作一层,只要保证当前层数字不是之前用过的数字,就不会出现重复.</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; lists;</span><br><span class="line">ArrayList&lt;Integer&gt; list;</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(int[] nums) &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        int length = nums.length;</span><br><span class="line">        lists = new ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        list = new ArrayList&lt;&gt;();</span><br><span class="line">        for (int i = 0;i&lt;=length;i++)&#123;</span><br><span class="line">            trackBack(nums,0,i);</span><br><span class="line">            list.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        return lists;</span><br><span class="line">    &#125;</span><br><span class="line">    public void trackBack(int[] nums,int start,int length)&#123;</span><br><span class="line">        if (list.size()&lt;length)&#123;</span><br><span class="line">            for (int i = start;i&lt;nums.length;i++)&#123;</span><br><span class="line">                //这里要保证同一层不取到相同的数字</span><br><span class="line">                if(i&gt;start&amp;&amp;nums[i]==nums[i-1])&#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                list.add(nums[i]);</span><br><span class="line">                //每次取数从后一位开始取</span><br><span class="line">                trackBack(nums,i+1,length);</span><br><span class="line">                list.remove(list.size()-1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            List&lt;Integer&gt; answer = new ArrayList&lt;Integer&gt;(this.list);</span><br><span class="line">            lists.add(answer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode解析</category>
        <category>中等</category>
      </categories>
      <tags>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>括号生成</title>
    <url>/2021/11/25/leetcode%E9%A2%98%E8%A7%A3/%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>数字n代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且有效的 括号组合。<br>有效括号组合需满足：左括号必须以正确的顺序闭合。</p>
<span id="more"></span>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>创建回溯，使str既可以添加(也可以添加)。但需要对添加的条件进行约束。<br>再对str是否完成进行判断。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt; answer;</span><br><span class="line">    public List&lt;String&gt; generateParenthesis(<span class="built_in">int</span> <span class="built_in">n</span>) &#123;</span><br><span class="line">        answer = new ArrayList&lt;String&gt;();</span><br><span class="line">        tarckback(<span class="built_in">n</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line">        return answer;</span><br><span class="line">    &#125;</span><br><span class="line">    public void tarckback(<span class="built_in">int</span> <span class="built_in">n</span>,<span class="built_in">int</span> <span class="built_in">left</span>,<span class="built_in">int</span> <span class="built_in">right</span>,String str)&#123;</span><br><span class="line">        <span class="built_in">if</span> (<span class="built_in">left</span>&lt;<span class="built_in">n</span>) &#123;</span><br><span class="line">            tarckback(<span class="built_in">n</span>,<span class="built_in">left</span>+<span class="number">1</span>,<span class="built_in">right</span>,str+<span class="string">&quot;(&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">if</span> (<span class="built_in">left</span>&gt;<span class="built_in">right</span>) &#123;</span><br><span class="line">            tarckback(<span class="built_in">n</span>,<span class="built_in">left</span>,<span class="built_in">right</span>+<span class="number">1</span>,str+<span class="string">&quot;)&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">if</span> (str.length() == <span class="number">2</span>*<span class="built_in">n</span>)&#123;</span><br><span class="line">            answer.add(str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode解析</category>
        <category>中等</category>
      </categories>
      <tags>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>把数字翻译成字符串</title>
    <url>/2021/12/19/leetcode%E9%A2%98%E8%A7%A3/%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。<br>注:06这种不可以视作6</p>
<span id="more"></span>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>分析后可知,当前数字可以与前一个数构成组合,同时可能与前二个数可以构成组合.这样就形成了动态转移方程,为了节约空间,因为我们实际只需要最后一个数字,而这个数字只取决于前两个数字,所以可以采用滚动数组.</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int translateNum(int num) &#123;</span><br><span class="line">    int[] res = new int[3];</span><br><span class="line">    int point = 1;</span><br><span class="line">    res[0] = 1;</span><br><span class="line">    String number = String.valueOf(num);</span><br><span class="line">    if (num&lt;10)&#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    String pre = number.substring(0,2);</span><br><span class="line">    if (pre.compareTo(&quot;26&quot;)&lt;0&amp;&amp;pre.compareTo(&quot;10&quot;)&gt;=0)&#123;</span><br><span class="line">        res[1] = 2;</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        res[1] = 1;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 3;i&lt;=number.length();i++)&#123;</span><br><span class="line">        point = (point+1)%3;</span><br><span class="line">        pre = number.substring(i-2,i);</span><br><span class="line">        if (pre.compareTo(&quot;26&quot;)&lt;0&amp;&amp;pre.compareTo(&quot;10&quot;)&gt;=0)&#123;</span><br><span class="line">            res[point] = res[(point+1)%3]+res[(point+2)%3];</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            res[point] = res[(point+2)%3];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res[point];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode解析</category>
        <category>中等</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>滚动数组</tag>
      </tags>
  </entry>
  <entry>
    <title>排列序列</title>
    <url>/2021/11/20/leetcode%E9%A2%98%E8%A7%A3/%E6%8E%92%E5%88%97%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><pre><code>    给出集合[1,2,3,...,n]，其所有元素共有n! 种排列。
    按大小顺序列出所有排列情况，并一一标记，当n = 3 时, 所有排列如下：
    &quot;123&quot;
    &quot;132&quot;
    &quot;213&quot;
    &quot;231&quot;
    &quot;312&quot;
    &quot;321&quot;
    给定n 和k，返回第k个排列。
</code></pre>
<span id="more"></span>
<h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>因为数字从小到大排列，所以可以直接由每位的数字来确定该数字所处位置。<br>如例中所示首位确定时，后两位能产生2！种变化，当第二位确定时，最后一位便确定。k的范围是1~6，12，34，56各一组。<br>需要对k处理方便计算，令k–，则k–除以2！可以正好被拆分开，再取得余数，用于确定下一位。<br>若k为5，则第一位的数字为第(5+1/2!)+1个数字,第二位的数字为(0/1!)+1个数字，第三位为剩下的最后一个数字。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public String getPermutation(int n, int k) &#123;</span><br><span class="line">        if (n ==1)&#123;</span><br><span class="line">            return &quot;1&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        //创建一个阶乘的数组，进行统计</span><br><span class="line">        k--;</span><br><span class="line">        int[][] count = new int[n - 1][2];</span><br><span class="line">        count[0][0] = 1;</span><br><span class="line">        for (int i = 1;i&lt;count.length;i++)&#123;</span><br><span class="line">            count[i][0] = count[i-1][0]*(i+1);</span><br><span class="line">        &#125;</span><br><span class="line">        int[] ints = new int[n];</span><br><span class="line">        for (int i = 0;i&lt;n;i++)&#123;</span><br><span class="line">            ints[i] = i+1;</span><br><span class="line">        &#125;</span><br><span class="line">        //开始逐个从数组中取出数组</span><br><span class="line">        String str = new String();</span><br><span class="line">        for (int i = count.length-1;i&gt;=0;i--)&#123;</span><br><span class="line">            count[i][1] = k/count[i][0];</span><br><span class="line">            int counter = -1;</span><br><span class="line">            for (int j = 0;j&lt;ints.length;j++)&#123;</span><br><span class="line">                if (ints[j] != 0)&#123;</span><br><span class="line">                    counter++;</span><br><span class="line">                    if (counter==count[i][1])&#123;</span><br><span class="line">                        str+=ints[j];</span><br><span class="line">                        ints[j] =0;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            k %= count[i][0];</span><br><span class="line">        &#125;</span><br><span class="line">        for (int o:ints)&#123;</span><br><span class="line">            if (o != 0)&#123;</span><br><span class="line">                str+=o;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return str;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>leetcode解析</category>
        <category>困难</category>
      </categories>
      <tags>
        <tag>数学分析</tag>
      </tags>
  </entry>
  <entry>
    <title>搜索旋转排序数组</title>
    <url>/2021/11/26/leetcode%E9%A2%98%E8%A7%A3/%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>整数数组nums按升序排列，数组中的值互不相同。<br>在传递给函数之前，nums在预先未知的某个下标k(0 &lt;= k &lt; nums.length)上进行了旋转，<br>使数组变为[nums[k], nums[k+1], …, nums[n-1], nums[0], nums[1], …, nums[k-1]]<br>(下标 从 0 开始 计数)。例如，[0,1,2,4,5,6,7]在下标3处经旋转后可能变为[4,5,6,7,0,1,2] 。<br>给你旋转后的数组nums和一个整数target，如果nums中存在这个目标值target,则返回它的下标,<br>否则返回-1。</p>
<span id="more"></span>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>对数组进行二分，有一半可以进行二分查找，如果目标数组在一排序好的一半则可以直接使用二分查找，<br>否则继续进行二分。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int search(int[] nums, int target) &#123;</span><br><span class="line">        //二分查找，先查排序好的，再对另一部分二分</span><br><span class="line">        int answer =  biSearch(0, nums.length-1, nums,target);</span><br><span class="line">        if (answer&lt;0)&#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            return answer;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public int biSearch(int first,int last,int[] num,int target)&#123;</span><br><span class="line">        //判断是否找到数字或者二分结束</span><br><span class="line">        int mid = (first+last)/2;</span><br><span class="line">        if (num[mid] == target)&#123;</span><br><span class="line">            return mid;</span><br><span class="line">        &#125;else if (mid == last)&#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        //判断哪部分是排序好的</span><br><span class="line">        if (num[first]&lt;num[mid])&#123;</span><br><span class="line">            if (target&gt;=num[first]&amp;&amp;target&lt;=num[mid])&#123;</span><br><span class="line">                return Arrays.binarySearch(num,first,mid+1,target);</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                return biSearch(mid+1,last,num,target);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            if (target&gt;=num[mid+1]&amp;&amp;target&lt;=num[last])&#123;</span><br><span class="line">                return Arrays.binarySearch(num,mid+1,last+1,target);</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                return biSearch(first,mid,num,target);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode解析</category>
        <category>中等</category>
      </categories>
      <tags>
        <tag>查找，二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>无重复最长数组</title>
    <url>/2021/11/22/leetcode%E9%A2%98%E8%A7%A3/%E6%97%A0%E9%87%8D%E5%A4%8D%E6%9C%80%E9%95%BF%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><pre><code>    给定一个字符串s，请你找出其中不含有重复字符的最长子串的长度。
</code></pre>
<h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>合理使用滑动窗口对字符串进行更新,每次遇到重复字符时收缩滑动窗口左端。</p>
<span id="more"></span>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="keyword">String</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">length</span>() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = <span class="number">1</span>;<span class="comment">//end一直指向无重复的下一位</span></span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span>[] chars = s.<span class="built_in">toCharArray</span>();</span><br><span class="line">        <span class="keyword">for</span> (;end&lt;chars.length;end++)&#123;</span><br><span class="line">            <span class="keyword">int</span> point = start;</span><br><span class="line">            <span class="comment">//判断前面的数组是否重复</span></span><br><span class="line">            <span class="keyword">for</span> (;point&lt;end;point++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (chars[point] == chars[end])&#123;</span><br><span class="line">                    <span class="comment">//说明当前无重复数组到达最大，比较记录</span></span><br><span class="line">                    max = Math.<span class="built_in">max</span>(max,end-start);</span><br><span class="line">                    <span class="comment">//更新start点位</span></span><br><span class="line">                    start = point+<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//还需要计算一次max</span></span><br><span class="line">        max = Math.<span class="built_in">max</span>(max,end-start);</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode解析</category>
        <category>中等</category>
      </categories>
      <tags>
        <tag>字符串检索</tag>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title>最大矩形</title>
    <url>/2021/12/09/leetcode%E9%A2%98%E8%A7%A3/%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定一个仅包含0和1、大小为rows x cols的二维二进制矩阵，找出只包含1的最大矩形，并返回其面积</p>
<p><img src="/images/%7DL%5DEJQ98UFV6O%259%5BXGIAH8Q.png" alt="图片"></p>
<span id="more"></span>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>我们可以对这个数组进行一个处理,把它转化成i个柱状图中最大矩形的问题.如图:<br><img src="/images/C39A31043170653A36EB2B610DEAA37C.png" alt="图片"></p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int maximalRectangle(char[][] matrix) &#123;</span><br><span class="line">        //可以每行都看作一个柱状图最大矩形的问题</span><br><span class="line">        int[][] grap = new int[matrix.length][matrix[0].length];</span><br><span class="line">        for (int i=matrix.length-1;i&gt;=0;i--)&#123;</span><br><span class="line">            for (int j = 0;j&lt;matrix[0].length;j++)&#123;</span><br><span class="line">                if (matrix[i][j]==&#x27;1&#x27;)&#123;</span><br><span class="line">                    grap[i][j]++;</span><br><span class="line">                    int k = 1;</span><br><span class="line">                    while (i-k&gt;=0&amp;&amp;matrix[i-k][j]==&#x27;1&#x27;)&#123;</span><br><span class="line">                        k++;</span><br><span class="line">                        grap[i][j]++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int max = 0;</span><br><span class="line">        for (int[] o:grap)&#123;</span><br><span class="line">            max=Math.max(max,largestRectangleArea(o));</span><br><span class="line">        &#125;</span><br><span class="line">        return max;</span><br><span class="line">    &#125;</span><br><span class="line">    //柱状图最大矩形问题</span><br><span class="line">    public int largestRectangleArea(int[] heights) &#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();</span><br><span class="line">        int[] ints = new int[heights.length + 2];</span><br><span class="line">        for (int i = 0;i&lt;heights.length;i++)&#123;</span><br><span class="line">            ints[i+1] = heights[i];</span><br><span class="line">        &#125;</span><br><span class="line">        int max = 0;</span><br><span class="line">        int area = 0;</span><br><span class="line">        stack.add(0);</span><br><span class="line">        for (int i =1;i&lt;ints.length;i++)&#123;</span><br><span class="line">            int top = stack.peek();</span><br><span class="line">                //弹出所有比入栈数大的数</span><br><span class="line">                while (ints[i]&lt;ints[top])&#123;</span><br><span class="line">                    stack.pop();</span><br><span class="line">                    area = ints[top]*(i-stack.peek()-1);</span><br><span class="line">                    max = Math.max(area,max);</span><br><span class="line">                    top = stack.peek();</span><br><span class="line">                &#125;</span><br><span class="line">                //正常入栈</span><br><span class="line">                stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        return max;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode解析</category>
        <category>困难</category>
      </categories>
      <tags>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title>最长和谐子序列</title>
    <url>/2021/11/20/leetcode%E9%A2%98%E8%A7%A3/%E6%9C%80%E9%95%BF%E5%92%8C%E8%B0%90%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><pre><code>    和谐数组是指一个数组里元素的最大值和最小值之间的差别 正好是 1 。
    现在，给你一个整数数组 nums ，请你在所有可能的子序列中找到最长的和谐子序列的长度。
    数组的子序列是一个由数组派生出来的序列，它可以通过删除一些元素或不删除元素、且不改变其余元素的顺序而得到。
示例：
    输入：nums = [1,3,2,2,5,2,3,7]
    输出：5
    解释：最长的和谐子序列是 [3,2,2,2,3]
</code></pre>
<span id="more"></span>
<h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>创建一个hashmap，再通过条件判断，直接检索答案。    </p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int findLHS(int[] nums) &#123;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        //记录每个数字的个数</span><br><span class="line">        for (int o :nums)&#123;</span><br><span class="line">            if (!map.containsKey(o))&#123;</span><br><span class="line">                map.put(o,0);</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(o, map.get(o)+1);</span><br><span class="line">        &#125;</span><br><span class="line">        if (map.size() &lt; 2)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int max = 0;</span><br><span class="line">        //从map中查询相邻数字，并且判断max</span><br><span class="line">        for (int key:map.keySet())&#123;</span><br><span class="line">            if (map.get(key+1) != null)&#123;</span><br><span class="line">                max = Math.max(max,map.get(key)+map.get(key+1));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return max;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode解析</category>
        <category>简单</category>
      </categories>
      <tags>
        <tag>hashmap</tag>
      </tags>
  </entry>
  <entry>
    <title>最长回文子串</title>
    <url>/2021/11/22/leetcode%E9%A2%98%E8%A7%A3/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><pre><code>    给你一个字符串s，找到s中最长的回文子串。
</code></pre>
<h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>首先对整个字符串加#，将单数字符串与双数字符串转换为单数字符串，减少代码量。<br>接着使用manacher算法：当一个短的字符串被包含在长字符串中时，具有一定的对称性。<br>情况一：短的字符串的镜像被包含在长字符串中，如caabaac，查a的长度，这时二者的长度相等。<br>情况二：短的字符串的镜像超出了长字符串的范围，此时这个字符串的长度正好到到长字符串的顶端。<br>情况三：短的字符串的镜像刚好落在了长字符串的一端，此时这个字符串长度最短到长字符串的顶端。</p>
<span id="more"></span>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">String</span> longestPalindrome(<span class="keyword">String</span> s) &#123;</span><br><span class="line">        <span class="built_in">char</span>[] chars = s.toCharArray();</span><br><span class="line">        <span class="built_in">char</span>[] <span class="built_in">str</span> = <span class="keyword">new</span> <span class="built_in">char</span>[chars.length * <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>;i&lt;chars.length;i++)&#123;</span><br><span class="line">            <span class="built_in">str</span>[<span class="number">2</span>*i] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">            <span class="built_in">str</span>[<span class="number">2</span>*i+<span class="number">1</span>] = chars[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">str</span>[<span class="built_in">str</span>.length<span class="number">-1</span>] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">        <span class="comment">//对字符串进行处理，把奇偶两种情况都转换为奇数情况</span></span><br><span class="line">        <span class="built_in">int</span>[] length = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="built_in">str</span>.length];</span><br><span class="line">        <span class="comment">//用于记录回文半径</span></span><br><span class="line">        <span class="built_in">int</span> shadow = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//创建一个数，用来记录最大阴影。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>;i&lt;<span class="built_in">str</span>.length;i++)&#123;</span><br><span class="line">            <span class="comment">//使用manacher算法</span></span><br><span class="line">            <span class="comment">//判断数字是否在阴影中</span></span><br><span class="line">            <span class="built_in">int</span> shadowLength = shadow+length[shadow];</span><br><span class="line">            <span class="keyword">if</span> (i!=<span class="number">0</span>&amp;&amp;i&lt;shadowLength)&#123;</span><br><span class="line">                <span class="comment">//取得镜像点</span></span><br><span class="line">                <span class="built_in">int</span> mirro = shadow-(i-shadow);</span><br><span class="line">                <span class="comment">//进入manacher算法后要分三种情况</span></span><br><span class="line">                <span class="comment">//镜像长度在阴影内</span></span><br><span class="line">                <span class="keyword">if</span> (i+length[mirro]&lt;shadowLength)&#123;</span><br><span class="line">                    length[i] = length[mirro];</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (i+length[mirro] &gt;shadowLength)&#123;</span><br><span class="line">                    length[i] = shadowLength-i;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    length[i] = shadowLength-i;</span><br><span class="line">                    <span class="built_in">int</span> left = i-(shadowLength-i);</span><br><span class="line">                    <span class="built_in">int</span> right = shadowLength;</span><br><span class="line">                    <span class="keyword">while</span> (left<span class="number">-1</span>&gt;=<span class="number">0</span>&amp;&amp;right+<span class="number">1</span>&lt;<span class="built_in">str</span>.length&amp;&amp;<span class="built_in">str</span>[left<span class="number">-1</span>]==<span class="built_in">str</span>[right+<span class="number">1</span>])&#123;</span><br><span class="line">                        left--;</span><br><span class="line">                        right++;</span><br><span class="line">                        length[i]++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//不在阴影中使用传统暴力算法</span></span><br><span class="line">            <span class="built_in">int</span> left = i;</span><br><span class="line">            <span class="built_in">int</span> right = i;</span><br><span class="line">            <span class="keyword">while</span> (left<span class="number">-1</span>&gt;=<span class="number">0</span>&amp;&amp;right+<span class="number">1</span>&lt;<span class="built_in">str</span>.length&amp;&amp;<span class="built_in">str</span>[left<span class="number">-1</span>]==<span class="built_in">str</span>[right+<span class="number">1</span>])&#123;</span><br><span class="line">                left--;</span><br><span class="line">                right++;</span><br><span class="line">                length[i]++;</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//更新阴影</span></span><br><span class="line">            <span class="keyword">if</span> (shadow+length[shadow]&lt;i+length[i])&#123;</span><br><span class="line">                shadow = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">int</span> maxPoint=<span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">int</span> maxLength = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i =<span class="number">0</span>;i&lt;length.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (length[i]&gt;maxLength)&#123;</span><br><span class="line">                maxLength = length[i];</span><br><span class="line">                maxPoint = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">String</span> answer = <span class="keyword">new</span> <span class="keyword">String</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = maxPoint-maxLength;i&lt;=maxPoint+maxLength;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">str</span>[i] != <span class="string">&#x27;#&#x27;</span>)&#123;</span><br><span class="line">                answer += <span class="built_in">str</span>[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode解析</category>
        <category>中等</category>
      </categories>
      <tags>
        <tag>字符串检索</tag>
        <tag>manacher算法</tag>
      </tags>
  </entry>
  <entry>
    <title>柱状图中最大的矩形</title>
    <url>/2021/12/08/leetcode%E9%A2%98%E8%A7%A3/%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定n个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为1 。<br>求在该柱状图中，能够勾勒出来的矩形的最大面积。<br><img src="/images/histogram.jpg" alt="histogram"></p>
<span id="more"></span>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>首先考虑如何获得所有可能的最大面积，我们要做的就是在限制的高度下尽可能的向两边延伸直到遇到边界或者比限制高度还低。有了这个思路首先对数组两边各加一个0使得遇到边界问题也转化为比限制高度低的问题。求取可能的最大面积需要知道的是限制高度以及左右两边比它低的数字，当找到这些时，这个高度的最大面积也就知道了。<br>所以我们要在遍历数组时，当出现比目标数小的数字时要取得这个数，且取得目标数，再取得前面第一个比这个数小的数。此时我们就能使用单调栈来存储这些数据。当数据递增时说明还未找到最大情况，通过查看栈顶数来看最大值，一旦出现比这个数小的数，说明栈顶的最大数到这个数为止的数都找到了最大情况，进行弹栈，弹出的为目标数，准备入栈的数和新栈顶为两边。所以在入栈时要存储这个数的大小以及它的位置。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int largestRectangleArea(int[] heights) &#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();</span><br><span class="line">        int[] ints = new int[heights.length + 2];</span><br><span class="line">        for (int i = 0;i&lt;heights.length;i++)&#123;</span><br><span class="line">            ints[i+1] = heights[i];</span><br><span class="line">        &#125;</span><br><span class="line">        int max = 0;</span><br><span class="line">        int area = 0;</span><br><span class="line">        stack.add(0);</span><br><span class="line">        for (int i =1;i&lt;ints.length;i++)&#123;</span><br><span class="line">            int top = stack.peek();</span><br><span class="line">                //弹出所有比入栈数大的数</span><br><span class="line">                while (ints[i]&lt;ints[top])&#123;</span><br><span class="line">                    stack.pop();</span><br><span class="line">                    area = ints[top]*(i-stack.peek()-1);</span><br><span class="line">                    max = Math.max(area,max);</span><br><span class="line">                    top = stack.peek();</span><br><span class="line">                &#125;</span><br><span class="line">                //正常入栈</span><br><span class="line">                stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        return max;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode解析</category>
        <category>困难</category>
      </categories>
      <tags>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title>树的子结构</title>
    <url>/2021/12/16/leetcode%E9%A2%98%E8%A7%A3/%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)<br>B是A的子结构， 即A中有出现和B相同的结构和节点值。</p>
<span id="more"></span>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>此题想到解法很简单,但在递归的返回处理时要仔细处理.<br>对树进行遍历,首先要考虑可以继续递归的情况:A != null&amp;&amp;B != null,如果满足则进行递归,这里写一个比较函数,如果为真,可以结束递归,否则要继续递归遍历.所以要用||进行连接.<br>如果不能递归说明此路不通,返回false.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(A != null&amp;&amp;B != null)&#123;</span><br><span class="line">	return compareNode(A,B)||searchNode(A.left,B)||searchNode(A.right,B);</span><br><span class="line">&#125;else&#123;</span><br><span class="line">	return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那上面的代码就能优化为这样:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">return (A != null&amp;&amp;B != null)&amp;&amp;(compareNode(A,B)||searchNode(A.left,B)||searchNode(A.right,B));</span><br></pre></td></tr></table></figure>
<p>接着思考比较函数,如何才能是子树呢,要求B的所有节点都都在A中,且A可以有B没有的节点.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">return compareNode(A.left, B.left) &amp;&amp; compareNode(A.right, B.right);</span><br></pre></td></tr></table></figure>
<p>然后思考需要对递归的拦截以及返回,如果值不相等返回false,如果A没有值,B有值返回false,如果B没有值返回true</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(B == null) return true;</span><br><span class="line">if(A == null || A.val != B.val) return false;</span><br><span class="line">return compareNode(A.left, B.left) &amp;&amp; compareNode(A.right, B.right);</span><br></pre></td></tr></table></figure>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public boolean isSubStructure(TreeNode A, TreeNode B) &#123;</span><br><span class="line">return (A != null&amp;&amp;B != null)&amp;&amp;(compareNode(A,B)||isSubStructure(A.left,B)||isSubStructure(A.right,B));    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    public boolean compareNode(TreeNode A,TreeNode B)&#123;</span><br><span class="line">    if(B == null) return true;</span><br><span class="line">    if(A == null || A.val != B.val) return false;</span><br><span class="line">    return compareNode(A.left, B.left) &amp;&amp; compareNode(A.right, B.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode解析</category>
        <category>中等</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式匹配</title>
    <url>/2021/11/23/leetcode%E9%A2%98%E8%A7%A3/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给你一个字符串s和一个字符规律p，请你来实现一个支持 ‘.’和’星号’的正则表达式匹配。<br>‘.’ 匹配任意单个字符<br>‘星号’ 匹配零个或多个前面的那一个元素<br>所谓匹配，是要涵盖整个字符串s的，而不是部分字符串。</p>
<span id="more"></span>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>设dp[i,j]表示第i长的s与j长的p的匹配情况。<br>下面开始分情况讨论：<br>//普通字符<br>当dp[i-1，j-1]为真的时候，如果s[i] == p[j]，则dp[i,j]为真，否则必定为假。<br>当dp[i-1，j-1]为假的时候，只要是普通字符则必定为假。<br>//星字符<br>当不使用星字符修饰的字符就能匹配时，则dp[i,j-2]必定为真。<br>当星的字符开始循环后能匹配时，查询dp[i-1,j]是否为真，若为真，且s[i] = p[j-1]，则为真，其他情况为假。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public boolean isMatch(String s, String p) &#123;</span><br><span class="line">        boolean[][] dp = new boolean[s.length() + 1][p.length() + 1];</span><br><span class="line">        //因为dp的判断点依靠左上，左侧以及上方点位，所以逐行对dp进行填充</span><br><span class="line">        //初始化第一列</span><br><span class="line">        dp[0][0] = true;</span><br><span class="line">        for (int i = 1;i&lt;dp.length;i++)&#123;</span><br><span class="line">            dp[i][0] = false;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0;i&lt;dp.length;i++)&#123;</span><br><span class="line">            for (int j = 1;j&lt;dp[0].length;j++)&#123;</span><br><span class="line">                if (p.substring(j-1,j).equals(&quot;*&quot;))&#123;</span><br><span class="line">                    if (dp[i][j-2]||</span><br><span class="line">                    	//判断*作0的情况</span><br><span class="line">                    	(i&gt;0&amp;&amp;dp[i-1][j]&amp;&amp;(s.substring(i-1,i).equals(p.substring(j-2,j-1))</span><br><span class="line">                    	||p.substring(j-2,j-1).equals(&quot;.&quot;))))&#123;</span><br><span class="line">                    	//判断*大于1的情况</span><br><span class="line">                        dp[i][j] = true;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;else &#123;</span><br><span class="line">                    if (i&gt;0&amp;&amp;dp[i-1][j-1]&amp;&amp;(p.substring(j-1,j).equals(&quot;.&quot;)||s.substring(i-1,i).equals(p.substring(j-1,j))))&#123;</span><br><span class="line">                        dp[i][j] = true;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (dp[s.length()][p.length()])&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode解析</category>
        <category>困难</category>
      </categories>
      <tags>
        <tag>字符串检索</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>格雷编码</title>
    <url>/2021/12/12/leetcode%E9%A2%98%E8%A7%A3/%E6%A0%BC%E9%9B%B7%E7%BC%96%E7%A0%81/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>n位格雷码序列是一个由2n个整数组成的序列，其中：<br>1.每个整数都在范围[0, 2n - 1]内（含0和2n-1）<br>2.第一个整数是0<br>3.一个整数在序列中出现不超过一次<br>4.每对相邻整数的二进制表示恰好一位不同，且第一个和最后一个整数的二进制表示恰好一位不同<br>5.给你一个整数n ，返回任一有效的n位格雷码序列。</p>
<span id="more"></span>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>这里要知道格雷编码的生成原理.</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public List&lt;Integer&gt; grayCode(int n) &#123;</span><br><span class="line">        List&lt;Integer&gt; ret = new ArrayList&lt;&gt;();</span><br><span class="line">        for(int i = 0; i &lt; 1&lt;&lt;n; ++i)</span><br><span class="line">            ret.add(i ^ i&gt;&gt;1);</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode解析</category>
        <category>中等</category>
      </categories>
      <tags>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>用两个栈实现队列</title>
    <url>/2021/12/10/leetcode%E9%A2%98%E8%A7%A3/%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead操作返回 -1 )</p>
<span id="more"></span>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>可以在每次入栈前把数据放入另一个栈,数据放入后再弹回.</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class CQueue &#123;</span><br><span class="line">Stack&lt;Integer&gt; stack1;</span><br><span class="line">    Stack&lt;Integer&gt; stack2;</span><br><span class="line">    public CQueue() &#123;</span><br><span class="line">        stack1 = new Stack&lt;&gt;();</span><br><span class="line">        stack2 = new Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void appendTail(int value) &#123;</span><br><span class="line">        while (!stack1.isEmpty())&#123;</span><br><span class="line">            stack2.push(stack1.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        stack1.push(value);</span><br><span class="line">        while (!stack2.isEmpty())&#123;</span><br><span class="line">            stack1.push(stack2.pop());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int deleteHead() &#123;</span><br><span class="line">       if (stack1.isEmpty())&#123;</span><br><span class="line">           return -1;</span><br><span class="line">       &#125;</span><br><span class="line">       return stack1.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode解析</category>
        <category>简单</category>
      </categories>
      <tags>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>盛水最多的容器</title>
    <url>/2021/11/24/leetcode%E9%A2%98%E8%A7%A3/%E7%9B%9B%E6%B0%B4%E6%9C%80%E5%A4%9A%E7%9A%84%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给你 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点(i,ai) 。<br>在坐标内画 n 条垂直线，垂直线 i的两个端点分别为(i,ai)和(i,0)。找出其中的两条线，使得它们与x轴共同构成的容器可以容纳最多的水。</p>
<span id="more"></span>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>首先将左右指针指向两端。然后寻找可能使面积更大的组合，无论左右指针哪个移动，底宽都是<br>原来-1。底宽减小，则只有min(left,right)变大才可能使面积变大，若向内移动长边，因为短边<br>没变，所以不可能使min(left,right)变大，只能移动短边，希望短边侧变长。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int maxArea(int[] height) &#123;</span><br><span class="line">        int left = 0;</span><br><span class="line">        int right = height.length-1;</span><br><span class="line">        int max = 0;</span><br><span class="line">        while (left != right)&#123;</span><br><span class="line">            int area = Math.min(height[left],height[right])*(right-left);</span><br><span class="line">            max = Math.max(area,max);</span><br><span class="line">            if (height[left] &lt; height[right])&#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        return max;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode解析</category>
        <category>中等</category>
      </categories>
      <tags>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>第n位数字</title>
    <url>/2021/11/30/leetcode%E9%A2%98%E8%A7%A3/%E7%AC%ACn%E4%BD%8D%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给你一个整数n，请你在无限的整数序列[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, …]中找出并返回第n位上的数字。</p>
<span id="more"></span>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>本题有时间限制，所以要找到一些规律：n位数字中有n<em>9</em>10^(n-1)位数字，根据这个规律判断数字的位数。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int findNthDigit(int n) &#123;</span><br><span class="line">        if (n&lt;10)&#123;</span><br><span class="line">            return n;</span><br><span class="line">        &#125;</span><br><span class="line">        //答案的长度</span><br><span class="line">        int numLength = 0;</span><br><span class="line">        //可能范围,使用long防止溢出</span><br><span class="line">        long count = 0;</span><br><span class="line">        while (count&lt;n)&#123;</span><br><span class="line">            numLength++;</span><br><span class="line">            count+=numLength*9*Math.pow(10,numLength-1);</span><br><span class="line">        &#125;</span><br><span class="line">        count-=numLength*9*Math.pow(10,numLength-1);</span><br><span class="line">        //判断第几位数字</span><br><span class="line">        int k = (int) (n-count)%numLength;</span><br><span class="line">        if (k==0)&#123;</span><br><span class="line">            k=numLength;</span><br><span class="line">        &#125;</span><br><span class="line">        //判断第几个数字</span><br><span class="line">        int index = (int) (n-count+1)/numLength;</span><br><span class="line">        //找到这个数字</span><br><span class="line">        int answerNum = (int) Math.pow(10,numLength-1)+index-1;</span><br><span class="line">        return Integer.valueOf(String.valueOf(answerNum).substring(k-1,k));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode解析</category>
        <category>中等</category>
      </categories>
      <tags>
        <tag>数学分析</tag>
      </tags>
  </entry>
  <entry>
    <title>第k个最小的素数分数</title>
    <url>/2021/11/30/leetcode%E9%A2%98%E8%A7%A3/%E7%AC%ACk%E4%B8%AA%E6%9C%80%E5%B0%8F%E7%9A%84%E7%B4%A0%E6%95%B0%E5%88%86%E6%95%B0/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给你一个按递增顺序排序的数组arr和一个整数k。数组arr由1和若干素数组成，且其中所有整数互不相同。<br>对于每对满足0&lt; i &lt; j &lt; arr.length 的 i 和 j ，可以得到分数 arr[i] / arr[j] 。</p>
<span id="more"></span>
<h1 id="堆排序分析"><a href="#堆排序分析" class="headerlink" title="堆排序分析"></a>堆排序分析</h1><p>这道题是对java中堆排序的练习。为了提高运算速度，需要对堆的入堆进行筛选。因为只需要取得第k个小的分数，构建一个大根堆，存放最小的7个分数，当堆大于7时，加入的分数如果大于堆顶，则没必要加入，如果小于堆顶，则弹出堆顶再加入当前分数。全部入堆结束后堆顶就是答案。</p>
<h1 id="堆排序代码"><a href="#堆排序代码" class="headerlink" title="堆排序代码"></a>堆排序代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int[] kthSmallestPrimeFraction(int[] arr, int k) &#123;</span><br><span class="line">        //把所有分数串连起来</span><br><span class="line">        ArrayList list = new ArrayList();</span><br><span class="line">        for (int i = 0;i&lt; arr.length-1;i++)&#123;</span><br><span class="line">            for (int j = 0;j&lt;i+1;j++)&#123;</span><br><span class="line">                int[] ints = &#123;arr[j],arr[i+1]&#125;;</span><br><span class="line">                list.add(ints);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //创建堆</span><br><span class="line">        Queue heap= new PriorityQueue(new Comparator() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public int compare(Object o1, Object o2) &#123;</span><br><span class="line">                int[] int1 = (int[]) o1;</span><br><span class="line">                int[] int2 = (int[]) o2;</span><br><span class="line">                return int2[0]*int1[1]-int1[0]*int2[1];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        //把这些元素放入堆中</span><br><span class="line">        for (Object o:list)&#123;</span><br><span class="line">            int[] int1 = (int[]) heap.peek();</span><br><span class="line">            int[] int2 = (int[]) o;</span><br><span class="line">            if (heap.size()&gt;=k&amp;&amp;int1[0]*int2[1]&gt;int1[1]*int2[0])&#123;</span><br><span class="line">                heap.poll();</span><br><span class="line">                heap.offer(o);</span><br><span class="line">            &#125;else if (heap.size()&lt;k)&#123;</span><br><span class="line">                heap.offer(o);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return (int[]) heap.poll();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h1 id="归并排序分析"><a href="#归并排序分析" class="headerlink" title="归并排序分析"></a>归并排序分析</h1><p>因为1/n&lt;2/n&lt;…这道题其实可以看作length-1条有序数组的排序。所以可以使用归并来处理，使用一个小根堆管理所有数组的第一个数字，此时这个堆中包含所有数组的最小数，所以当弹出时必定为整体的最小数。我们要做的就是弹出k个堆顶，每次弹出时加入数组的后一个数字。</p>
<h1 id="归并排序代码"><a href="#归并排序代码" class="headerlink" title="归并排序代码"></a>归并排序代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int[] kthSmallestPrimeFraction(int[] arr, int k) &#123;</span><br><span class="line">        int n = arr.length;</span><br><span class="line">        //制定小根堆的规则</span><br><span class="line">        PriorityQueue&lt;int[]&gt; q = new PriorityQueue&lt;&gt;((a,b)-&gt;&#123;</span><br><span class="line">            double i1 = arr[a[0]] * 1.0 / arr[a[1]], i2 = arr[b[0]] * 1.0 / arr[b[1]];</span><br><span class="line">            return Double.compare(i1, i2);</span><br><span class="line">        &#125;);</span><br><span class="line">        //加入所有数组的第一个数</span><br><span class="line">        for (int i = 1; i &lt; n; i++) q.add(new int[]&#123;0, i&#125;);</span><br><span class="line">        while (k-- &gt; 1) &#123;</span><br><span class="line">            //弹出堆顶，加入这个数的下一个数</span><br><span class="line">            int[] poll = q.poll();</span><br><span class="line">            int i = poll[0], j = poll[1];</span><br><span class="line">            if (i + 1 &lt; j) q.add(new int[]&#123;i + 1, j&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        int[] poll = q.poll();</span><br><span class="line">        return new int[]&#123;arr[poll[0]], arr[poll[1]]&#125;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode解析</category>
        <category>困难</category>
      </categories>
      <tags>
        <tag>归并</tag>
        <tag>优先级队列</tag>
        <tag>堆排序</tag>
      </tags>
  </entry>
  <entry>
    <title>简化路径</title>
    <url>/2021/12/03/leetcode%E9%A2%98%E8%A7%A3/%E7%AE%80%E5%8C%96%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给你一个路径，这个路径可以被解析，请你简化路径。</p>
<span id="more"></span>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>这道题要处理三种情况，多余的”/“，”.”和”..”的处理。首先使用split方法将字符串拆分，可以消除全部的”/“，且多余的会转化为空字符串。”.”可以直接去除，”..”要返回上一级。在这里可以利用一个双端队列，先把它作为一个栈使用，遇到”.”和””不入栈，遇到”..”弹栈，遇到其他字符串入栈，这样全部处理结束后就是简化后的路径，再从头部依次取出。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public String simplifyPath(String path) &#123;</span><br><span class="line">        String[] split = path.split(&quot;/&quot;);</span><br><span class="line">        ArrayDeque&lt;String&gt; stack = new ArrayDeque&lt;&gt;();</span><br><span class="line">        for (String s:split)&#123;</span><br><span class="line">            if (s.equals(&quot;..&quot;))&#123;</span><br><span class="line">                stack.pollLast();</span><br><span class="line">            &#125;else if (s.equals(&quot;.&quot;)||s.equals(&quot;&quot;))&#123;</span><br><span class="line"></span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                stack.offerLast(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        String answer = new String();</span><br><span class="line">        while (!stack.isEmpty())&#123;</span><br><span class="line">            answer+=&quot;/&quot;;</span><br><span class="line">            answer+=stack.pollFirst();</span><br><span class="line">        &#125;</span><br><span class="line">        if (answer.length()==0)&#123;</span><br><span class="line">            return &quot;/&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        return answer;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode解析</category>
        <category>中等</category>
      </categories>
      <tags>
        <tag>双端队列</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>组合总和</title>
    <url>/2021/11/28/leetcode%E9%A2%98%E8%A7%A3/%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定一个数组candidates和一个目标数target，找出candidates中所有可以使数字和为target的组合。<br>candidates中的每个数字在每个组合中只能使用一次。<br>注意：解集不能包含重复的组合</p>
<span id="more"></span>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>本题难点在于如何去重，解决办法是将数组排序，在循环内添加判断，如果与上一个相同，跳过即可。这样处理可以去掉同层所有重复数字，但不同层的数字仍然可以重复。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; answer;</span><br><span class="line"></span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) &#123;</span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        int[] ints = new int[candidates.length + 1];</span><br><span class="line">        for (int i =0;i&lt;candidates.length;i++)&#123;</span><br><span class="line">            ints[i] = candidates[i];</span><br><span class="line">        &#125;</span><br><span class="line">        answer = new ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        tarckBack(ints, target, 0, 0, new ArrayList&lt;Integer&gt;());</span><br><span class="line">        return answer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void tarckBack(int[] candidates, int target, int start, int sum, ArrayList&lt;Integer&gt; list) &#123;</span><br><span class="line">        if (sum == target) &#123;</span><br><span class="line">            ArrayList&lt;Integer&gt; list1 = new ArrayList&lt;&gt;(list);</span><br><span class="line">            answer.add(list1);</span><br><span class="line">        &#125; else if (sum &lt; target) &#123;</span><br><span class="line">            for (int i = start; i &lt; candidates.length-1; i++) &#123;</span><br><span class="line">                //同层去重</span><br><span class="line">                if (i&gt;start&amp;&amp;candidates[i]==candidates[i-1])&#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                list.add(candidates[i]);</span><br><span class="line">                tarckBack(candidates, target, i+1, sum + candidates[i], list);</span><br><span class="line">                list.remove(list.size() - 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode解析</category>
        <category>中等</category>
      </categories>
      <tags>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>编辑距离</title>
    <url>/2021/12/03/leetcode%E9%A2%98%E8%A7%A3/%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/</url>
    <content><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>给你两个单词word1和word2，请你计算出将word1转换成word2所使用的最少操作数。<br>你可以对一个单词进行如下三种操作：<br>插入一个字符<br>删除一个字符<br>替换一个字符</p>
<span id="more"></span>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>使用动态规划，首先假设a，b两个字符串已经匹配结束。那么当a长度增加时，使用删除，操作+1。当b长度增加时，使用插入，操作+1。当a，b都增加时如果这两个字符相同，不需要操作，如果这两个字符不同时只需要替换其中一个，操作+1。<br>就有dp[i][j] = min(dp[i-1][j]+1,dp[i][j-1]+1,dp[i-1][j-1]+(1))。<br>在a，b字符串加空字符，方便对第一行与第一列进行初始化。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int minDistance(String word1, String word2) &#123;</span><br><span class="line">        int[][] dp = new int[word1.length() + 1][word2.length() + 1];</span><br><span class="line">        char[] chars1 = word1.toCharArray();</span><br><span class="line">        char[] chars2 = word2.toCharArray();</span><br><span class="line">        for (int i = 0;i&lt;word1.length()+1;i++)&#123;</span><br><span class="line">            dp[i][0]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 1;i&lt;word2.length()+1;i++)&#123;</span><br><span class="line">            dp[0][i]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 1;i&lt;word1.length()+1;i++)&#123;</span><br><span class="line">            for (int j = 1;j&lt;word2.length()+1;j++)&#123;</span><br><span class="line">                dp[i][j] = Math.min(dp[i-1][j]+1,dp[i][j-1]+1);</span><br><span class="line">                if (chars1[i-1]==chars2[j-1])&#123;</span><br><span class="line">                    dp[i][j] = Math.min(dp[i][j],dp[i-1][j-1]);</span><br><span class="line">                &#125;else &#123;</span><br><span class="line">                    dp[i][j] = Math.min(dp[i][j],dp[i-1][j-1]+1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[word1.length()][word2.length()];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode解析</category>
        <category>困难</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>股票的最大利润</title>
    <url>/2021/12/19/leetcode%E9%A2%98%E8%A7%A3/%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%A9%E6%B6%A6/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？</p>
<span id="more"></span>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>先考虑成品结果有什么特点, 买入点与卖出点必定是最它这个范围内的最低点与最高点. 那么就可以使用双指针, 并对这个双指针进行维护. 使用一个指针进行遍历, 如果这个指针指向的内容小于最低点, 说明这段指针已经维护结束,要开始维护新的指针. 这个指针要不断右移搜寻更大的最高点.</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int maxProfit(int[] prices) &#123;</span><br><span class="line">    int max = 0;</span><br><span class="line">    int min = 0;</span><br><span class="line">    int res = 0;</span><br><span class="line">    while (min&lt;prices.length)&#123;</span><br><span class="line">        max = min;</span><br><span class="line">        int point = max;</span><br><span class="line">        while (point&lt;prices.length-1)&#123;</span><br><span class="line">            point++;</span><br><span class="line">            if (prices[point]&lt;=prices[min])&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            if (prices[point]&gt;prices[max])&#123;</span><br><span class="line">                max = point;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res = Math.max(res,prices[max]-prices[min]);</span><br><span class="line">        min = max+1;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode解析</category>
        <category>中等</category>
      </categories>
      <tags>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>超级次方</title>
    <url>/2021/12/05/leetcode%E9%A2%98%E8%A7%A3/%E8%B6%85%E7%BA%A7%E6%AC%A1%E6%96%B9/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>你的任务是计算a^b对1337取模，a是一个正整数，b是一个非常大的正整数且会以数组形式给出。</p>
<span id="more"></span>
<h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>首先要知道在计算过程中取模再计算并不影响最后的取模结果。<br>接着需要设计一种快速计算次幂的方法，我们可以让a一直与自身相乘减少计算次数，且每次这样处理会使需要的次幂折半，而因为奇数折半会损失一次，所以要在处理前将这个数字先乘入答案。<br>然后要处理超长的b数组，转换为数字必然不可能，但可以设计一个指针指向这个数组的第一个数，将这个过程拆分。比如a的32次幂可以变成(a^3)^10*a^2。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int val = 1337;</span><br><span class="line">    public int superPow(int a, int[] b) &#123;</span><br><span class="line">        int anwer = 1;</span><br><span class="line">        a %= val;</span><br><span class="line">        for (int i = 0;i&lt; b.length;i++)&#123;</span><br><span class="line">            anwer = pow(anwer,10)%val;</span><br><span class="line">            anwer = anwer*pow(a,b[i])%val;</span><br><span class="line">        &#125;</span><br><span class="line">        return anwer;</span><br><span class="line">    &#125;</span><br><span class="line">    public int pow(int a,int n)&#123;</span><br><span class="line">        int answer = 1;</span><br><span class="line">        //a每乘自己一次，所要的次幂就除以2，如果是奇数，因为5/2=2，所以要先把这个数乘进answer</span><br><span class="line">        for (int i = n;i&gt;0;i /=2)&#123;</span><br><span class="line">          if (i &gt;&gt; 1 &lt;&lt; 1 != i)&#123;</span><br><span class="line">              answer = a*answer%val;</span><br><span class="line">          &#125;</span><br><span class="line">          a = a*a%val;</span><br><span class="line">        &#125;</span><br><span class="line">        return answer;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode解析</category>
        <category>中等</category>
      </categories>
  </entry>
  <entry>
    <title>并发编程</title>
    <url>/2021/11/26/%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%AB%98%E5%B9%B6%E5%8F%91/</url>
    <content><![CDATA[<h1 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h1><p>1.进程要分配一大部分的内存，而线程只需要分配一部分栈就可以了.<br>2.一个程序至少有一个进程,一个进程至少有一个线程.<br>3.进程是资源分配的最小单位，线程是程序执行的最小单位。<br>4.一个线程可以创建和撤销另一个线程，同一个进程中的多个线程之间可以并发执行</p>
<span id="more"></span>    
<p>线程栈：<br>1.方便函数调用，当调用子函数时，可以把当前函数的信息压入栈中，<br>再在栈的顶端压入返回地址，当子函数调用结束后再弹栈即可。<br>2.多任务支持，当有必要进行任务切换时，对当前信息存储，再读入<br>另一个任务的信息即可。</p>
<h1 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h1><p>并发：单一cpu交替执行多任务，宏观表现同时进行的情况称为并发。<br>并行：多个cpu同时执行多个任务，宏观表现与微观均为同时进行。</p>
<h1 id="如何确定合适的线程数"><a href="#如何确定合适的线程数" class="headerlink" title="如何确定合适的线程数"></a>如何确定合适的线程数</h1><p>根据任务需要执行计算的时间占比分配线程数。如：4核，任务中计算占比25%的任务分配16线程。</p>
<!-- more -->
<h1 id="缓存行编程技巧"><a href="#缓存行编程技巧" class="headerlink" title="缓存行编程技巧"></a>缓存行编程技巧</h1><p>前提知识：缓存行每次从内存拉取64bytes的内容。同一缓存行在不同cpu中同时处理时需要不断对齐。<br>例：<br>创建一个类，类中存放一个long型数据，创建一个2容量这个类的数组，启动两个线程分别对这两个<br>类的long型数据处理。时间记作t1。<br>创建一个与上面相似的类，但在其中的long型数据前和后分别填充7个无用的long型数据，再执行与<br>上面相同的操作。时间记作t2。<br>结果是t2会比t1短很多。原因是，第一个类中，两个要处理的数据会处于同一缓存行，在处理时需要不断<br>的对齐。二第二个类中，因为无用long型数据的填充，使得两个被操作的数据无法处于同一缓存行，不用对齐。</p>
<h1 id="指令重排"><a href="#指令重排" class="headerlink" title="指令重排"></a>指令重排</h1><p>问题：<br>在cpu执行语句时，happens-before规则约束后，可能会在执行过程中发生指令重排，<br>宏观表现为语句的倒转。而这种问题会导致this引用逃逸。如下面的代码就可能会输出0。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ThisEscape&#123;</span><br><span class="line">	private int num = 0;</span><br><span class="line">	public ThisEscape()&#123;</span><br><span class="line">		new Thread(()-&gt;System.out.println(this.num)).start();</span><br><span class="line">	&#125; </span><br><span class="line">	public static void mian(String[] args)throw Exception&#123;</span><br><span class="line">		new ThisEscape();</span><br><span class="line">		System.in.read();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分析：num的初始在汇编中有三步，创建空间，赋值，再指向。但this一开始就指向了他本身，所以可能<br>在num没有初始化完成时就调用了this指针，将num发送出去。<br>如何避免：不要在构造方法中启动线程</p>
<h1 id="提高并发效率"><a href="#提高并发效率" class="headerlink" title="提高并发效率"></a>提高并发效率</h1><p>合理的上锁，不要锁太多没必要的内容导致并发效率降低。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//给整个函数上锁</span><br><span class="line">public synchronized ...()&#123;&#125;</span><br><span class="line">//给部分代码上锁，注意静态方法中锁只能是本身的类对象</span><br><span class="line">synchronized(类对象)&#123;要执行的代码&#125;</span><br></pre></td></tr></table></figure>
<p>double check lock<br>在给部分代码上锁的过程中一般会进行判断，但注意不可以只在上锁前进行判断，因为线程可能会在任意<br>阶段发生切换，多个线程同时挤进判断语句中也会发生，所以在锁内要再加判断，如果情况变了，要归还锁。<br>这种上锁方式，只对内层进行上锁仍然可以起到相同的效果，但加入外层锁后可以减少上锁解锁的过程，<br>提升代码效率。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//单例模式取得对象</span><br><span class="line">if(INSTANCE == null)&#123;</span><br><span class="line">	synchronized(当前类)&#123;</span><br><span class="line">		if(INSTANCE == null)&#123;</span><br><span class="line">			INSTANCE = new 类对象;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个双锁仍旧有问题，new对象时如果发生指令重排，当只指向地址但未赋值时，此时恰好又有另一个线程访问对象，就会访问到未初始的对象。(虽然被锁定，但是上锁的代码和未上锁的代码是可以访问到中间态的)(java高版本已经解决了这个问题)<br>cpu级防止指令交换：添加屏障指令<br>jvm中防止指令交换：四种内存屏障Load-Store<br>java中防止指令交换：在修饰的前面加volatile</p>
<h1 id="如何减少多线程上下文切换开销"><a href="#如何减少多线程上下文切换开销" class="headerlink" title="如何减少多线程上下文切换开销"></a>如何减少多线程上下文切换开销</h1><p>无锁并发编程:当任何特定的运算被阻塞的时候，所有CPU可以继续处理其他的运算。换种方式说，在无锁系统中，当给定线程被其他线程阻塞的时候，所有CPU可以不停的继续处理其他工作。无锁算法大大增加系统整体的吞吐量，因为它只偶尔会增加一定的交易延迟。大部分高端数据库系统是基于无锁算法而构造的，以满足不同级别。</p>
<p>CAS算法:Java提供了一套原子性操作的数据类型（java.util.concurrent.atomic包下），使用CAS算法来更新数据，不需要加锁。如:AtomicInteger、AtomicLong等。</p>
<p>避免创建过多的线程:如任务量少时，尽可能减少创建线程。对于某个时间段任务量很大的这种情况，我们可以通过线程池来管理线程的数量，避免创建过多线程。</p>
<p>协程：即协作式程序，其思想是，一系列互相依赖的协程间依次使用CPU，每次只有一个协程工作，而其他协程处于休眠状态。如：JAVA中使用wait和notify来达到线程之间的协同工作。</p>
]]></content>
      <categories>
        <category>知识点解析</category>
      </categories>
  </entry>
  <entry>
    <title>javaweb</title>
    <url>/2021/12/10/%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90/javaweb%E9%A2%98%E7%9B%AE/</url>
    <content><![CDATA[<h1 id="转发和重定向"><a href="#转发和重定向" class="headerlink" title="转发和重定向"></a>转发和重定向</h1><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><p>转发:<br>1.客户端发送请求,Servlet做出业务逻辑处理.<br>2.Servlet调用forward方法,服务器Servlet把目标资源返回给客户端浏览器.</p>
<span id="more"></span>
<p>重定向:<br>1.客户端发送请求,Servlet做出业务逻辑处理.<br>2.Servlet调用sendRedirect()方法,把要访问的资源路径告诉客户端浏览器.<br>3.客户端浏览器重新访问新的服务器资源,服务器再次对客户端浏览器做出反应.</p>
<h2 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h2><p>1.使用相对路径没有区别<br>2.使用绝对路径时,转发的/代表的是当前web应用根路径,重定向的/代表web服务器根路径,一般要在前面加request.getContextPath()即工程路径.</p>
<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>转发整个过程实际是一个请求,而重定向是完全跳转到新页面,是两个请求.这个区别在刷新页面时会产生很大的不同.且重定向可以跨域.</p>
<h1 id="cookie与session"><a href="#cookie与session" class="headerlink" title="cookie与session"></a>cookie与session</h1><p>session是一直在服务器端的, cookie是客户端保存信息的一种手段. 当有浏览器访问服务器时, 服务器会为这个浏览器开辟一个session, 并把这个session的钥匙sessionid放入cookie中让浏览器使用. 浏览器如果想进入同一个会话, 就需要每次发送请求时在cookie中附带上打开目标session的钥匙, sessionid.<br>具体作用就体现在浏览器在一个session会话中只需要向服务器发送一次用户名和密码, 此后用户名和密码的调用都是服务器从session中取得.</p>
<h1 id="token"><a href="#token" class="headerlink" title="token"></a>token</h1><p>token是为了应对当大量用户集体对服务器进行访问时生成大量session的问题.<br>使用token后服务器不会存储原本session的内容, 而是加密后让浏览器自己保存, 服务器只负责解析.</p>
]]></content>
      <categories>
        <category>知识点解析</category>
      </categories>
  </entry>
  <entry>
    <title>javase</title>
    <url>/2021/12/03/%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90/javase%E9%A2%98%E7%9B%AE/</url>
    <content><![CDATA[<h1 id="hashmap的扩容与-amp-运算问题"><a href="#hashmap的扩容与-amp-运算问题" class="headerlink" title="hashmap的扩容与&amp;运算问题"></a>hashmap的扩容与&amp;运算问题</h1><p>基本知识<br>1、初始容量为1&lt;&lt;4<br>2、负载因子为0.75，到达负载因子时2次幂扩展<br>3、通过hashcode计算存放位置</p>
<span id="more"></span>
<p>hashcode的计算<br>1、获取hash值h，将h&gt;&gt;&gt;16后再与自身异或。<br>这是因为在计算hashmap存放位置时只取低位，正常运算会丢失高位的信息。这样处理后也可以将高位<br>的信息保留，减少冲突的可能性。<br>2、取模运算:(length-1)&amp;hash。<br>在这里可以解释为什么扩容是是2次幂，一般情况下，计算位置是需要%计算，但当length的长度为2的<br>次幂的时候，取余运算可以转化成上面的位与运算，大大节省了计算时间。</p>
<p><a href="https://www.cnblogs.com/ysocean/p/9054804.html">来源</a></p>
<h1 id="为什么重写-equals-还要重写-hashcode？"><a href="#为什么重写-equals-还要重写-hashcode？" class="headerlink" title="为什么重写 equals 还要重写 hashcode？"></a>为什么重写 equals 还要重写 hashcode？</h1><p>因为不重写hashcode在插入到哈希表时不能保证插入到同一位置，不插入到同一位置就无法触发equals判断。</p>
<h1 id="和-equals-比较的区别"><a href="#和-equals-比较的区别" class="headerlink" title="== 和 equals 比较的区别"></a>== 和 equals 比较的区别</h1><p>对于对象而言，==是在判断地址是否相同，equals是判断内容。</p>
<h1 id="为什么浮点数运算会不精准"><a href="#为什么浮点数运算会不精准" class="headerlink" title="为什么浮点数运算会不精准"></a>为什么浮点数运算会不精准</h1><p>因为计算机的浮点数是用二进制的科学计数保存的，它可以保存1/2，1/4等，但却因为进制问题不能表示0.1这种数字，只能近似，所以在保存这些数字的时候会丢失精度。</p>
<h1 id="为什么定义long类型与float类型时要加l和f"><a href="#为什么定义long类型与float类型时要加l和f" class="headerlink" title="为什么定义long类型与float类型时要加l和f"></a>为什么定义long类型与float类型时要加l和f</h1><p>这是因为定义变量的过程本质是使用指针将两个内存块连接的过程。long类型常量不加l修饰会这个常量只会被当作int型，分配的空间也只有int型的大小。而浮点型默认是double，如果不加f，相当于把double直接赋予float，编译器会不通过。</p>
<h1 id="创建子类对象"><a href="#创建子类对象" class="headerlink" title="创建子类对象"></a>创建子类对象</h1><p>创建子类对象时会默认调用父类的无参构造器方法来初始化属性，如果没有无参构造器，则需要使用super方法声明构造器的使用。<br>调用父类构造器是考虑到父类的一些私有属性可能要使用自己的构造器进行初始化。</p>
<h1 id="什么是多态"><a href="#什么是多态" class="headerlink" title="什么是多态"></a>什么是多态</h1><p>多态是指不同的子类在继承父类后分别重写父类的方法，使得可以统一编译父类，通过不同子类的运行，实现不同的方法。</p>
<h1 id="为什么子类重写父类的方法不能低于其在父类中的访问权限"><a href="#为什么子类重写父类的方法不能低于其在父类中的访问权限" class="headerlink" title="为什么子类重写父类的方法不能低于其在父类中的访问权限"></a>为什么子类重写父类的方法不能低于其在父类中的访问权限</h1><p>因为这样操作会影响多态，当父类方法是公开，而子类重写方法是私有时，父类在实现多态时会无法调用子类的方法。</p>
<h1 id="动态绑定"><a href="#动态绑定" class="headerlink" title="动态绑定"></a>动态绑定</h1><p>当调用对象方法时，该方法会和该对象的运行类型相绑定。而调用对象属性时不会有动态绑定，而是从该对象开始向上搜寻。</p>
<h1 id="哪些情况会导致类被加载"><a href="#哪些情况会导致类被加载" class="headerlink" title="哪些情况会导致类被加载"></a>哪些情况会导致类被加载</h1><p>1.创建对象时<br>2.子类创建对象时<br>3.使用静态成员时</p>
<h1 id="final的作用"><a href="#final的作用" class="headerlink" title="final的作用"></a>final的作用</h1><p>1.防止类被继承<br>2.防止方法被重写<br>3.防止属性或变量被更改<br>4.与static搭配使用可以提高效率，被final static修饰的属性(方法不可以)被调用时不会导致类加载，也就是说这么修饰的属性不需要类加载也能获得。</p>
<h1 id="哪些情况Integer不会创建新对象"><a href="#哪些情况Integer不会创建新对象" class="headerlink" title="哪些情况Integer不会创建新对象"></a>哪些情况Integer不会创建新对象</h1><p>在Integr值在-128到127之间时。这是因为Integer有一个公用的闪存数组，数字在这个区间时会直接返回闪存数组中的对象。</p>
<h1 id="String的两种创建方式的区别"><a href="#String的两种创建方式的区别" class="headerlink" title="String的两种创建方式的区别"></a>String的两种创建方式的区别</h1><p>不调用构造器直接赋值：<br>先从常量池查看是否有这个字符串，如果有就直接指向，没有则创建再指向，一级指针指向常量池。<br>调用构造器赋值：<br>先在堆中创建空间，里面维护value属性，指向常量池，如果常量池没有，则重新创建再指向，有就直接指向，一级指针指向堆。<br>使用intern方法后会进行规范化，如果常量池有目标字符串指向常量池。使用字符串加和创建的字符串一级指针也是指向堆。</p>
<h1 id="StringBuffer的优点"><a href="#StringBuffer的优点" class="headerlink" title="StringBuffer的优点"></a>StringBuffer的优点</h1><p>StringBuffer创建的组合字符串不进入常量池，而是在堆中存放，但单个的字符串依旧会进入常量池.使用append方法添加字符串时也不会像String一样在常量池中重新创建新的字符串，而是在原有的字符串基础上进行扩容，当循环使用时比String要快很多。</p>
<h1 id="intern方法"><a href="#intern方法" class="headerlink" title="intern方法"></a>intern方法</h1><p>当在常量池有目标字符串时,会直接指向常量池,当常量池没有目标字符串时,会在常量池创建一个引用,这个引用指向堆.<br>那么哪种情况才会在创建字符串时不在常量池创建字符串呢,答案是使用StringBuilder或StringBuffer的时候.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//这段代码如果intern在b后面则会输出false,在b前面输出true</span><br><span class="line">String a = new String(&quot;abc&quot;)+new String(&quot;def&quot;);</span><br><span class="line">String b = new String(&quot;abcdef&quot;);</span><br><span class="line">System.out.println(a==a.intern());</span><br></pre></td></tr></table></figure>
<h1 id="java的集合类"><a href="#java的集合类" class="headerlink" title="java的集合类"></a>java的集合类</h1><p><img src="/images/2.png" alt="2.png"></p>
<h1 id="java8新特性"><a href="#java8新特性" class="headerlink" title="java8新特性"></a>java8新特性</h1><p>1.lambda表达式<br>2.函数式接口<br>3.Stream API</p>
<h1 id="JDK1-7与1-8中hashmap的差异"><a href="#JDK1-7与1-8中hashmap的差异" class="headerlink" title="JDK1.7与1.8中hashmap的差异"></a>JDK1.7与1.8中hashmap的差异</h1><p>1、1.7计算hashcode经过了4此移位和异或运算，1.8只有一次移位和异或运算。<br>2、1.8的hashmap当哈希表大小到64时会树化。<br>3、1.8的hashmap的链表插入方法为尾插，1.7是头插。<br>4、扩容方式不同。<br>5、1.7是先判断扩容再插入，1.8是先插入再判断扩容。<br>好处：降低事件复杂度，改用尾插法就去除了并发条件下成环的问题。</p>
]]></content>
      <categories>
        <category>知识点解析</category>
      </categories>
  </entry>
  <entry>
    <title>数值的整数次方</title>
    <url>/2021/12/30/leetcode%E9%A2%98%E8%A7%A3/%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>实现 pow(x, n) ，即计算 x 的 n 次幂函数（即，xn）。不得使用库函数，同时不需要考虑大数问题。<br>输入：x = 2.10000, n = 3<br>输出：9.26100</p>
<span id="more"></span>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>可以把n次幂拆分为多个次幂相乘,比如把10拆分为5<em>2-&gt;(2</em>2+1)*2.<br>为1时返回x,为-1时返回倒数即可.</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public double myPow(double x, int n) &#123;</span><br><span class="line">    //正数处理,把10拆分为5*2-&gt;(2*2+1)*2</span><br><span class="line">    //大于2说明可以拆分</span><br><span class="line">    if (n==0)&#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;else if (n==1)&#123;</span><br><span class="line">        return x;</span><br><span class="line">    &#125;else if (n==-1)&#123;</span><br><span class="line">        return 1/x;</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        double num = myPow(x,n&gt;&gt;1);</span><br><span class="line">        //说明不是偶数</span><br><span class="line">        if (n&gt;&gt;1&lt;&lt;1 !=n)&#123;</span><br><span class="line">            return num*num*x;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            return num*num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode解析</category>
        <category>中等</category>
      </categories>
  </entry>
  <entry>
    <title>供暖器</title>
    <url>/2021/12/21/leetcode%E9%A2%98%E8%A7%A3/%E4%BE%9B%E6%9A%96%E5%99%A8/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>冬季已经来临。 你的任务是设计一个有固定加热半径的供暖器向所有房屋供暖。<br>在加热器的加热半径范围内的每个房屋都可以获得供暖。<br>现在，给出位于一条水平线上的房屋 houses 和供暖器 heaters 的位置，请你找出并返回可以覆盖所有房屋的最小加热半径。<br>说明：所有供暖器都遵循你的半径标准，加热的半径也一样。</p>
<span id="more"></span>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>因为房屋只能选择离他最近的前面或者后面的供暖器, 所以可以使用贪心算法对每个房屋求解, 取max.<br>具体步骤为先对房屋以及供暖器进行排序,然后维护一个双指针,保证房屋在双指针之间,对最近供暖器进行求解即可.<br>因为两端处理比较麻烦,所以直接为两端情况的point1与point2设置一个特殊值.</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int findRadius(int[] houses, int[] heaters) &#123;</span><br><span class="line">    Arrays.sort(houses);</span><br><span class="line">    Arrays.sort(heaters);</span><br><span class="line">    //对于每个房子要么使用前面的加热器要么使用后面的加热器</span><br><span class="line">    //使用两个指针维护两个加热器,逐步遍历房屋,让房屋选择加热器</span><br><span class="line">    int res = 0;</span><br><span class="line">    int i = 0;</span><br><span class="line">    //对point1进行特殊处理</span><br><span class="line">    int point1 = -1000000000;</span><br><span class="line">    int point2 = heaters[i];</span><br><span class="line">    //判断房屋是否在两点之间,如果不在,则右移指针</span><br><span class="line">    for (int o:houses)&#123;</span><br><span class="line">        while (!(o&gt;=point1&amp;&amp;o&lt;=point2))&#123;</span><br><span class="line">            if (i==heaters.length)&#123;</span><br><span class="line">                point1 = point2;</span><br><span class="line">                point2 = 2147483647;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            point1 = point2;</span><br><span class="line">            point2 = heaters[i++];</span><br><span class="line">            //如果point2越界就特殊处理</span><br><span class="line">        &#125;</span><br><span class="line">        int num1 = o-point1;</span><br><span class="line">        int num2 = point2-o;</span><br><span class="line">        res = Math.max(res,Math.min(num1,num2));</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode解析</category>
        <category>中等</category>
      </categories>
      <tags>
        <tag>双指针</tag>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title>重建二叉树</title>
    <url>/2021/12/29/leetcode%E9%A2%98%E8%A7%A3/%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>输入某二叉树的前序遍历和中序遍历的结果，请构建该二叉树并返回其根节点。<br>假设输入的前序遍历和中序遍历的结果中都不含重复的数字</p>
<span id="more"></span>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>使用前序遍历是根节点,左子树,右子树.<br>使用中序遍历是左子树,根节点,右子树.<br>可以使用一个递归函数,这个函数主要负责取得根节点,并且将剩下的左右子树传递下去.<br>当只有一个节点或者空节点时进行返回.</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span><span class="literal">[]</span> preorder;</span><br><span class="line"><span class="built_in">int</span><span class="literal">[]</span> inorder;</span><br><span class="line">public TreeNode build<span class="constructor">Tree(<span class="params">int</span>[] <span class="params">preorder</span>, <span class="params">int</span>[] <span class="params">inorder</span>)</span> &#123;</span><br><span class="line">    this.preorder = preorder;</span><br><span class="line">    this.inorder = inorder;</span><br><span class="line">    <span class="built_in">int</span> start1 = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">int</span> end1 = preorder.length;</span><br><span class="line">    <span class="built_in">int</span> start2 = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">int</span> end2 = end1;</span><br><span class="line">    <span class="comment">//调用递归方法</span></span><br><span class="line">    return build<span class="constructor">TreeImpl(<span class="params">start1</span>,<span class="params">end1</span>,<span class="params">start2</span>,<span class="params">end2</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line">public TreeNode build<span class="constructor">TreeImpl(<span class="params">int</span> <span class="params">start1</span>,<span class="params">int</span> <span class="params">end1</span>,<span class="params">int</span> <span class="params">start2</span>,<span class="params">int</span> <span class="params">end2</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//空节点</span></span><br><span class="line">    <span class="keyword">if</span> (start1==end1)&#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//在这里通过分析两个数字,取得根节点以及左右子树,总共要八个指针</span></span><br><span class="line">    <span class="comment">//让它们两两为一组传入递归函数,左闭右开</span></span><br><span class="line">    TreeNode root = <span class="keyword">new</span> <span class="constructor">TreeNode(<span class="params">preorder</span>[<span class="params">start1</span>])</span>;</span><br><span class="line">    <span class="comment">//节点大于1</span></span><br><span class="line">    <span class="keyword">if</span> (end1-start1&gt;<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">int</span> point1 = start1+<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">int</span> point4 = end1;</span><br><span class="line">        <span class="built_in">int</span> point5 = start2;</span><br><span class="line">        <span class="built_in">int</span> point8 = end2;</span><br><span class="line">        <span class="built_in">int</span> point6 = start2;</span><br><span class="line">        <span class="keyword">for</span> (;inorder<span class="literal">[<span class="identifier">point6</span>]</span>!=preorder<span class="literal">[<span class="identifier">start1</span>]</span>;point6++)&#123;&#125;</span><br><span class="line">        <span class="built_in">int</span> point7 = point6+<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">int</span> point2 = point1+(point6-point5);</span><br><span class="line">        <span class="built_in">int</span> point3 = point2;</span><br><span class="line">        <span class="comment">//开始对树进行构建</span></span><br><span class="line">        root.left = build<span class="constructor">TreeImpl(<span class="params">point1</span>,<span class="params">point2</span>,<span class="params">point5</span>,<span class="params">point6</span>)</span>;</span><br><span class="line">        root.right = build<span class="constructor">TreeImpl(<span class="params">point3</span>,<span class="params">point4</span>,<span class="params">point7</span>,<span class="params">point8</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    return root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode解析</category>
        <category>中等</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>不用乘除及判断实现累加</title>
    <url>/2021/12/28/leetcode%E9%A2%98%E8%A7%A3/%E4%B8%8D%E7%94%A8%E4%B9%98%E9%99%A4%E5%8F%8A%E5%88%A4%E6%96%AD%E5%AE%9E%E7%8E%B0%E7%B4%AF%E5%8A%A0/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>求 1+2+…+n ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p>
<span id="more"></span>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>使用异常代替结束判断</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int sumNums(int n) &#123;</span><br><span class="line">    int[] ints = new int[n];</span><br><span class="line">    int res = 0;</span><br><span class="line">    res=plus(ints,1);</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line">public int plus(int[] ints,int i)&#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        ints[i] = 1;</span><br><span class="line">        return plus(ints,i+1)+i;</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        return i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode解析</category>
        <category>中等</category>
      </categories>
      <tags>
        <tag>异常</tag>
      </tags>
  </entry>
  <entry>
    <title>平衡二叉树判断</title>
    <url>/2021/12/27/leetcode%E9%A2%98%E8%A7%A3/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%A4%E6%96%AD/</url>
    <content><![CDATA[<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树</p>
<span id="more"></span>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>这道题可以使用回溯获取分支深度, 但因为是递归所以只能返回数字, 那么就需要设定一个特殊的数字来代替Boolean值, 有这个数字的存在, 就可以进行是否平衡的判断以及剪枝.</p>
<h1 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public boolean isBalanced(TreeNode root) &#123;</span><br><span class="line">    if (balanceCounter(root)==-1)&#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public int balanceCounter(TreeNode root)&#123;</span><br><span class="line">    //这里需要使用一个特殊的数字来作为剪枝的标准</span><br><span class="line">    if (root==null)&#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        //如果已经不平衡则不再计算</span><br><span class="line">        int leftDeep = balanceCounter(root.left);</span><br><span class="line">        if (leftDeep==-1)&#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        int rightDeep = balanceCounter(root.right);</span><br><span class="line">        if (rightDeep==-1)&#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        if (Math.abs(leftDeep-rightDeep)&gt;1)&#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        return Math.max(leftDeep,rightDeep)+1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode解析</category>
        <category>最优</category>
      </categories>
      <tags>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>相同元素的间隔之和</title>
    <url>/2021/12/26/leetcode%E9%A2%98%E8%A7%A3/%E7%9B%B8%E5%90%8C%E5%85%83%E7%B4%A0%E7%9A%84%E9%97%B4%E9%9A%94%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给你一个下标从0开始、由n个整数组成的数组arr。<br>arr中两个元素的间隔定义为它们下标之间的绝对差。更正式地arr[i]和arr[j]之间的间隔是|i - j|。<br>返回一个长度为n的数组intervals，其中intervals[i]是arr[i]和arr中每个相同元素(与arr[i]的值相同)的间隔之和。<br>输入：arr = [2,1,3,1,2,3,3]<br>输出：[4,2,7,2,4,4,5]<br>解释：</p>
<ul>
<li>下标 0 ：另一个 2 在下标 4 ，|0 - 4| = 4</li>
<li>下标 1 ：另一个 1 在下标 3 ，|1 - 3| = 2</li>
<li>下标 2 ：另两个 3 在下标 5 和 6 ，|2 - 5| + |2 - 6| = 7</li>
<li>下标 3 ：另一个 1 在下标 1 ，|3 - 1| = 2</li>
<li>下标 4 ：另一个 2 在下标 0 ，|4 - 0| = 4</li>
<li>下标 5 ：另两个 3 在下标 2 和 6 ，|5 - 2| + |5 - 6| = 4</li>
<li>下标 6 ：另两个 3 在下标 2 和 5 ，|6 - 2| + |6 - 5| = 5<span id="more"></span>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1>通过题目可知, 本题要计算的是相同数字的下标差的绝对值的和. 所以可以使用一个map, key为他们存储的数字, value为key一致的数字的下标的一个list. 这样要做的就是遍历每个list, 计算list中的每个数字与其他list数字的差之和, 这个和就是res[当前数字]的答案.<br>但因为时间与内存限制, 必须对求当前list的差和的算法进行优化, 常规方法都会超时或超内存.<br>因为遍历方式, 我们的list其实是一个有序list, 依靠这个特点可以找到同list的res之间其实是存在一个函数关系的, 使用这个函数关系就可以把暴力计算的时间复杂度降下来.<br>想象list的数字是在水平上的一根根柱子, 它们的水平位置就是它们的下标, 就有了以下分析.<br><img src="/images/CC9E9B1F565C445B3663EE59080A5271.png" alt="分析图"><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    public long[] getDistances(int[] arr) &#123;</span><br><span class="line">        HashMap&lt;Integer, List&lt;Integer&gt;&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        for (int i = 0;i&lt;arr.length;i++)&#123;</span><br><span class="line">            if (map.containsKey(arr[i]))&#123;</span><br><span class="line">                map.get(arr[i]).add(i);</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">                list.add(i);</span><br><span class="line">                map.put(arr[i],list);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        long[] longs = new long[arr.length];</span><br><span class="line">        int [][] grap;</span><br><span class="line">        for (List&lt;Integer&gt; list:map.values())&#123;</span><br><span class="line">            for (int i = 1;i&lt;list.size();i++)&#123;</span><br><span class="line">                longs[list.get(0)] += list.get(i)-list.get(0);</span><br><span class="line">            &#125;</span><br><span class="line">            for (int i = 1;i&lt;list.size();i++)&#123;</span><br><span class="line">longs[list.get(i)] = longs[list.get(i-1)]-(list.get(i)-list.get(i-1))*(list.size()-2*i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return longs;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>leetcode解析</category>
        <category>最优</category>
      </categories>
      <tags>
        <tag>数学分析</tag>
        <tag>hashmap</tag>
      </tags>
  </entry>
  <entry>
    <title>判断一个括号字符串是否有效</title>
    <url>/2021/12/26/leetcode%E9%A2%98%E8%A7%A3/%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E6%8B%AC%E5%8F%B7%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%98%AF%E5%90%A6%E6%9C%89%E6%95%88/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>数据流的中位数</title>
    <url>/2021/12/27/leetcode%E9%A2%98%E8%A7%A3/%E6%95%B0%E6%8D%AE%E6%B5%81%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。<br>例如，<br>[2,3,4]的中位数是 3<br>[2,3] 的中位数是 (2 + 3) / 2 = 2.5<br>设计一个支持以下两种操作的数据结构：<br>void addNum(int num) - 从数据流中添加一个整数到数据结构中。<br>double findMedian() - 返回目前所有元素的中位数。</p>
<span id="more"></span>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>为了方便取到中间的数字, 可以使用两个优先级队列各存放一半, 前半使用大根堆存放, 后半使用小根堆存放.<br>接下来需要对入堆情况进行详细分析, 规定两堆差最高只能为1, 且不允许后半部分多于前半部分:<br>当大根堆多于小根堆时:<br>数字要入小根堆就直接入堆, 数字要入大根堆就弹出大根堆堆顶给小根堆, 再进行入堆.<br>当大根堆与小根堆相等时:<br>数字要入大根堆就直接入堆, 数字要入小根堆就弹出小根堆堆顶给大根堆, 再进行入堆.</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MedianFinder</span> &#123;</span></span><br><span class="line">    PriorityQueue&lt;Integer&gt; bigQueue;</span><br><span class="line">    PriorityQueue&lt;Integer&gt; smallQueue;</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    public MedianFinder() &#123;</span><br><span class="line">        <span class="regexp">//创建一个大根堆一个小根堆保存数据</span></span><br><span class="line"><span class="regexp">        //</span>大根堆保存前半数字,小根堆保存后半数字</span><br><span class="line">        bigQueue = <span class="keyword">new</span> PriorityQueue&lt;Integer&gt;<span class="function"><span class="params">((o1, o2) -&gt; o2.compareTo(o1))</span>;</span></span><br><span class="line"><span class="function">        <span class="title">smallQueue</span> = <span class="title">new</span> <span class="title">PriorityQueue</span>&lt;<span class="title">Integer</span>&gt;<span class="params">()</span>;</span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="title">public</span> <span class="title">void</span> <span class="title">addNum</span><span class="params">(int num)</span> &#123;</span></span><br><span class="line"><span class="function">        //如果大根堆为空,则直接入堆</span></span><br><span class="line"><span class="function">        <span class="title">if</span> <span class="params">(bigQueue.isEmpty())</span>&#123;</span></span><br><span class="line"><span class="function">            <span class="title">bigQueue</span>.<span class="title">add</span><span class="params">(num)</span>;</span></span><br><span class="line"><span class="function">            //大根堆比小根堆多1, 数字要入小根堆,直接入堆</span></span><br><span class="line"><span class="function">            //大根堆比小根堆多1,数字要入大根堆</span></span><br><span class="line"><span class="function">            //把大根堆顶的数字弹给小根堆,数字入大根堆</span></span><br><span class="line"><span class="function">        &#125;<span class="title">else</span> <span class="title">if</span> <span class="params">(bigQueue.size()&gt;smallQueue.size())</span>&#123;</span></span><br><span class="line"><span class="function">            <span class="title">if</span> <span class="params">(num&lt;bigQueue.peek())</span>&#123;</span></span><br><span class="line"><span class="function">                <span class="title">smallQueue</span>.<span class="title">add</span><span class="params">(bigQueue.poll())</span>;</span></span><br><span class="line"><span class="function">                <span class="title">bigQueue</span>.<span class="title">add</span><span class="params">(num)</span>;</span></span><br><span class="line"><span class="function">            &#125;<span class="title">else</span> &#123;</span></span><br><span class="line"><span class="function">                <span class="title">smallQueue</span>.<span class="title">add</span><span class="params">(num)</span>;</span></span><br><span class="line"><span class="function">            &#125;</span></span><br><span class="line"><span class="function">            //大根堆等于小根堆, 数字要入大根堆,直接入堆</span></span><br><span class="line"><span class="function">            //大根堆等于小根堆, 数字要入小根堆, 把小根堆堆顶弹给大根堆,数字入小根堆</span></span><br><span class="line"><span class="function">        &#125;<span class="title">else</span> &#123;</span></span><br><span class="line"><span class="function">            <span class="title">if</span> <span class="params">(num&lt;smallQueue.peek())</span>&#123;</span></span><br><span class="line"><span class="function">                <span class="title">bigQueue</span>.<span class="title">add</span><span class="params">(num)</span>;</span></span><br><span class="line"><span class="function">            &#125;<span class="title">else</span> &#123;</span></span><br><span class="line"><span class="function">                <span class="title">bigQueue</span>.<span class="title">add</span><span class="params">(smallQueue.poll())</span>;</span></span><br><span class="line"><span class="function">                <span class="title">smallQueue</span>.<span class="title">add</span><span class="params">(num)</span>;</span></span><br><span class="line"><span class="function">            &#125;</span></span><br><span class="line"><span class="function">        &#125;</span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="title">public</span> <span class="title">double</span> <span class="title">findMedian</span><span class="params">()</span> &#123;</span></span><br><span class="line"><span class="function">        //如果两堆相等,取平均</span></span><br><span class="line"><span class="function">        //否则,取大根堆顶</span></span><br><span class="line"><span class="function">        <span class="title">if</span> <span class="params">(bigQueue.size()==smallQueue.size())</span>&#123;</span></span><br><span class="line"><span class="function">            <span class="title">double</span> <span class="title">res</span> = <span class="params">((double)bigQueue.peek()+(double)smallQueue.peek())</span>/2;</span></span><br><span class="line"><span class="function">            <span class="title">return</span> <span class="title">res</span>;</span></span><br><span class="line"><span class="function">        &#125;<span class="title">else</span> &#123;</span></span><br><span class="line"><span class="function">            <span class="title">return</span> <span class="title">bigQueue</span>.<span class="title">peek</span><span class="params">()</span>;</span></span><br><span class="line"><span class="function">        &#125;</span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode解析</category>
        <category>最优</category>
      </categories>
      <tags>
        <tag>优先级队列</tag>
      </tags>
  </entry>
  <entry>
    <title>和为s的两个数字</title>
    <url>/2021/12/22/leetcode%E9%A2%98%E8%A7%A3/%E5%92%8C%E4%B8%BAs%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可。</p>
<span id="more"></span>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>如图所示, 查找一个固定数字相当于在一个二维空间上寻找一个点位, 这个二维空间从左到右, 从上到下递减.<br>初始点为(0,5), 我们要找到一条最短路径到目标点. 所以,当当前数字比目标小时, 就向下搜寻, 且搜寻到的数要刚好大于目标. 当当前数字比目标大时, 就向左搜寻, 且搜寻数字要刚好小于目标数.而这两种搜寻方式, 都可以通过二分查找实现.<br><img src="/images/QQ20211222232346.png" alt="图片"></p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int[] twoSum(int[] nums, int target) &#123;</span><br><span class="line">        int left = 0;</span><br><span class="line">        int right = nums.length-1;</span><br><span class="line">        while (nums[left]+nums[right] != target)&#123;</span><br><span class="line">            //进行二维查找,当前数字比目标小,就进行纵向搜寻</span><br><span class="line">            //当前数字比目标大,就进行横向搜寻</span><br><span class="line">            //纵向搜寻时,right不变,在left到right间搜寻合适答案</span><br><span class="line">            //纵向搜寻要求找到的和大于targt</span><br><span class="line">            //横向搜寻时,left不限,在left到right间搜寻合适答案</span><br><span class="line">            //横向搜寻要求找到的数小于targt</span><br><span class="line">            if(nums[left]+nums[right] &lt; target)&#123;</span><br><span class="line">                int num1 = target-nums[right];</span><br><span class="line">                int index = Arrays.binarySearch(nums,left+1,right,num1);</span><br><span class="line">                if (index&gt;0)&#123;</span><br><span class="line">                    int[] ints = &#123;num1,target-num1&#125;;</span><br><span class="line">                    return ints;</span><br><span class="line">                &#125;else &#123;</span><br><span class="line">                    left = -index-1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                int num1 = target-nums[left];</span><br><span class="line">                int index = Arrays.binarySearch(nums,left+1,right,num1);</span><br><span class="line">                if (index&gt;0)&#123;</span><br><span class="line">                    int[] ints = &#123;num1,target-num1&#125;;</span><br><span class="line">                    return ints;</span><br><span class="line">                &#125;else &#123;</span><br><span class="line">                    right = -index-2;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        int[] ints = &#123;nums[left],nums[right]&#125;;</span><br><span class="line">        return ints;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode解析</category>
        <category>最优</category>
      </categories>
      <tags>
        <tag>二分查找</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>把数组排成最小的数</title>
    <url>/2021/12/25/leetcode%E9%A2%98%E8%A7%A3/%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。</p>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>本题难点在于想出合适的排序方式</p>
<span id="more"></span>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public String minNumber(int[] nums) &#123;</span><br><span class="line">    String[] strings = new String[nums.length];</span><br><span class="line">    for (int i = 0;i&lt; nums.length;i++)&#123;</span><br><span class="line">        strings[i] = Integer.toString(nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    Arrays.sort(strings, new Comparator&lt;String&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public int compare(String o1, String o2) &#123;</span><br><span class="line">            return compareNum(o1,o2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    StringBuffer res = new StringBuffer();</span><br><span class="line">    for (String s:strings)&#123;</span><br><span class="line">        res.append(s);</span><br><span class="line">    &#125;</span><br><span class="line">    return res.toString();</span><br><span class="line">&#125;</span><br><span class="line">public int compareNum(String num1, String num2)&#123;</span><br><span class="line">        int res = 0;</span><br><span class="line">        if ((num1+num2).compareTo(num2+num1)&gt;0)&#123;</span><br><span class="line">            res = 1;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            res = -1;</span><br><span class="line">        &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode解析</category>
        <category>中等</category>
      </categories>
  </entry>
  <entry>
    <title>反转链表2</title>
    <url>/2021/12/21/leetcode%E9%A2%98%E8%A7%A3/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A82/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给你单链表的头指针 head 和两个整数left 和 right ，其中left &lt;= right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表 </p>
<span id="more"></span>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>这种情况很适合使用栈，因为left和right还不会越界,所以空指针异常也不需要考虑.</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ListNode node;</span><br><span class="line">public ListNode reverseBetween(ListNode head, int left, int right) &#123;</span><br><span class="line">    //使用栈存放</span><br><span class="line">    node = new ListNode(-1);</span><br><span class="line">    node.next = head;</span><br><span class="line">    head = node;</span><br><span class="line">    Stack&lt;ListNode&gt; stack = new Stack&lt;&gt;();</span><br><span class="line">    while (left!=1)&#123;</span><br><span class="line">        head = head.next;</span><br><span class="line">        left--;</span><br><span class="line">        right--;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode pre = head;</span><br><span class="line">    head = head.next;</span><br><span class="line">    right--;</span><br><span class="line">    while (right!=0)&#123;</span><br><span class="line">        stack.push(head);</span><br><span class="line">        head = head.next;</span><br><span class="line">        right--;</span><br><span class="line">    &#125;</span><br><span class="line">    stack.push(head);</span><br><span class="line">    head = head.next;</span><br><span class="line">    //开始串联链表</span><br><span class="line">    while (!stack.isEmpty()) &#123;</span><br><span class="line">        pre.next = stack.pop();</span><br><span class="line">        pre = pre.next;</span><br><span class="line">    &#125;</span><br><span class="line">    pre.next = head;</span><br><span class="line">    return node.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode解析</category>
        <category>中等</category>
      </categories>
      <tags>
        <tag>栈</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis</title>
    <url>/2021/12/25/%E6%A1%86%E6%9E%B6/MyBatis/</url>
    <content><![CDATA[<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>使用maven把依赖配置好.<br>使用idea连接数据库<br>配置mybatis的配置文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE configuration</span><br><span class="line">        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span><br><span class="line">        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;environments default=&quot;development&quot;&gt;</span><br><span class="line">        &lt;environment id=&quot;development&quot;&gt;</span><br><span class="line">            &lt;transactionManager type=&quot;JDBC&quot;/&gt;</span><br><span class="line">            &lt;dataSource type=&quot;POOLED&quot;&gt;</span><br><span class="line">                &lt;property name=&quot;driver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt;</span><br><span class="line">                &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?useSSL=true&amp;amp;useUnicode=true&amp;amp;characterEncoding=UTF-8&amp;amp;serverTimezone=UTC&quot;/&gt;</span><br><span class="line">                &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;</span><br><span class="line">                &lt;property name=&quot;password&quot; value=&quot;lixin123&quot;/&gt;</span><br><span class="line">            &lt;/dataSource&gt;</span><br><span class="line">        &lt;/environment&gt;</span><br><span class="line">    &lt;/environments&gt;</span><br><span class="line">&lt;!--    在这里配置maipper.xml--&gt;</span><br><span class="line">    &lt;mappers&gt;</span><br><span class="line">        &lt;mapper resource=&quot;com/meitianyidian/mybatis/mapper/EmployeeMapper.xml&quot;/&gt;</span><br><span class="line">    &lt;/mappers&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>
<p>使用配置文件构建SqlSessionFactory, 并让它提供创建SqlSession的方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyBatisUtil &#123;</span><br><span class="line">    private static SqlSessionFactory sqlSessionFactory;</span><br><span class="line">    static &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            String resource = &quot;mybatis-config.xml&quot;;</span><br><span class="line">            InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">            sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static SqlSession getSqlSession()&#123;</span><br><span class="line">        return sqlSessionFactory.openSession();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建实体类.<br>因为MyBatis避免了几乎所有的JDBC代码和手动设置参数以及获取结果集. 所以在这里没有了dao, 而是mapper与配置文件的集合.<br>创建mapper接口.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface EmployeeMapper &#123;</span><br><span class="line">    List&lt;Employee&gt; getEmployeeList();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建对应的xml文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper</span><br><span class="line">        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span><br><span class="line">        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;</span><br><span class="line">&lt;!--绑定mapper接口--&gt;</span><br><span class="line">&lt;mapper namespace=&quot;com.meitianyidian.mybatis.mapper.EmployeeMapper&quot;&gt;</span><br><span class="line">&lt;!--    msq语句配置--&gt;</span><br><span class="line">    &lt;select id=&quot;getEmployeeList&quot; resultType=&quot;com.meitianyidian.mybatis.pojo.Employee&quot;&gt;</span><br><span class="line">        select * from tbl_employee</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line"></span><br><span class="line">    &lt;select id=&quot;getEmployeeById&quot; parameterType=&quot;int&quot; resultType=&quot;com.meitianyidian.mybatis.pojo.Employee&quot;&gt;</span><br><span class="line">        select * from tbl_employee where id = #&#123;id&#125;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line"></span><br><span class="line">    &lt;insert id=&quot;addEmployee&quot; parameterType=&quot;com.meitianyidian.mybatis.pojo.Employee&quot;&gt;</span><br><span class="line">        insert into tbl_employee (last_name, gender, email) values (#&#123;last_name&#125;,#&#123;gender&#125;,#&#123;email&#125;)</span><br><span class="line">    &lt;/insert&gt;</span><br><span class="line"></span><br><span class="line">    &lt;update id=&quot;updateEmployee&quot; parameterType=&quot;com.meitianyidian.mybatis.pojo.Employee&quot;&gt;</span><br><span class="line">        update tbl_employee set last_name = #&#123;last_name&#125;,gender = #&#123;gender&#125;,email = #&#123;email&#125; where id = #&#123;id&#125;</span><br><span class="line">    &lt;/update&gt;</span><br><span class="line"></span><br><span class="line">    &lt;delete id=&quot;deleteEmployee&quot; parameterType=&quot;int&quot;&gt;</span><br><span class="line">        delete from tbl_employee where id = #&#123;id&#125;</span><br><span class="line">    &lt;/delete&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure>
<p>创建sqlSession并用其生成mapper实体<br>注意: 因为默认是不自动提交事务的,所以dml语句要进行事务的提交</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void test()&#123;</span><br><span class="line">    SqlSession sqlSession = null;</span><br><span class="line">    List&lt;Employee&gt; employeeList = null;</span><br><span class="line">    //确保能关闭session,使用try-catch-finally</span><br><span class="line">    try &#123;</span><br><span class="line">        sqlSession = MyBatisUtil.getSqlSession();</span><br><span class="line">        //通过类对象与配置文件生成对应的mapper实体</span><br><span class="line">        EmployeeMapper mapper = sqlSession.getMapper(EmployeeMapper.class);</span><br><span class="line">        employeeList = mapper.getEmployeeList();</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        //关闭sqlSession</span><br><span class="line">        sqlSession.close();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(employeeList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="配置解析"><a href="#配置解析" class="headerlink" title="配置解析"></a>配置解析</h1><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- maybatis可以配置多个环境变量, 但每个sqlSession只能选择一个环境变量. 即数据库与sqlSession一一对应. --&gt;</span><br><span class="line">&lt;!-- 使用environments标签的default属性设置默认的环境(environment的id). --&gt;</span><br><span class="line">&lt;environments default=&quot;&quot;&gt;</span><br><span class="line">    &lt;environment id=&quot;&quot;&gt;</span><br><span class="line">        &lt;!-- 用于配置事务管理器 --&gt;</span><br><span class="line">        &lt;transactionManager type=&quot;&quot;&gt;</span><br><span class="line">        &lt;/transactionManager&gt;</span><br><span class="line">        &lt;!-- 用于配置数据源 --&gt;</span><br><span class="line">        &lt;UNPOOLED:无连接池,POOLED:有连接池,JNDI</span><br><span class="line">        &lt;dataSource type=&quot;&quot;&gt;</span><br><span class="line">        &lt;/dataSource&gt;</span><br><span class="line">    &lt;/environment&gt;</span><br><span class="line">&lt;/environments&gt;</span><br></pre></td></tr></table></figure>
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 实现引用标签, 导入后可以在下面的配置使用$&#123;&#125;引用, 当外部文件与property属性冲突时,会使用外部文件 --&gt;</span><br><span class="line">&lt;properties resource=&quot;&quot;&gt;</span><br><span class="line">    &lt;!-- 不使用properties标签是对当前标签属性进行更改 --&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/properties&gt;</span><br></pre></td></tr></table></figure>
<h2 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h2><p>基本类型默认别名前加_,包装类型默认别名为小写开头</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;typeAliases&gt;</span><br><span class="line">    &lt;typeAlias alias=&quot;别名&quot; type=&quot;名称&quot; /&gt;</span><br><span class="line">    &lt;!-- 可以指定一个包名, mybatis会在包名下搜索需要的bean --&gt;</span><br><span class="line">    &lt;package name=&quot;包名&quot; /&gt;</span><br><span class="line">&lt;/typeAliases&gt;</span><br></pre></td></tr></table></figure>
<h2 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;settings&gt;</span><br><span class="line">    &lt;!-- 缓存是否开启 --&gt;</span><br><span class="line">    &lt;setting name=&quot;cacheEnable&quot; value=&quot;true&quot; /&gt;</span><br><span class="line">    &lt;!-- 是否开启懒加载 --&gt;</span><br><span class="line">    &lt;setting name=&quot;lazyLoadingEnable&quot; value=&quot;false&quot; /&gt;</span><br><span class="line">    &lt;!-- 是否开启自动驼峰命名映射 --&gt;</span><br><span class="line">    &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;false&quot; /&gt;</span><br><span class="line">    指定所用日志的具体实现</span><br><span class="line">    &lt;setting name=&quot;logImpl&quot; value=&quot;未设置&quot; /&gt;</span><br><span class="line">&lt;/settings&gt;</span><br></pre></td></tr></table></figure>
<h2 id="映射器"><a href="#映射器" class="headerlink" title="映射器"></a>映射器</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 在这里注册创建的mapper --&gt;</span><br><span class="line">&lt;mappers &gt;</span><br><span class="line">    &lt;!-- 使用xml类路径 --&gt;</span><br><span class="line">    &lt;mapper resource=&quot;&quot; /&gt;</span><br><span class="line">    &lt;!-- 使用mapper实现类全类名(要求其对应的xml文件在同一包下，且同名) --&gt;</span><br><span class="line">    &lt;mapper class=&quot;&quot; /&gt;</span><br><span class="line">    &lt;!-- 将包内的mapper接口实现全部注册为mapper(要求其对应的xml文件在同一包下，且同名) --&gt;</span><br><span class="line">    &lt;package name=&quot;&quot; /&gt;</span><br><span class="line">&lt;/mappers&gt;</span><br></pre></td></tr></table></figure>
<h1 id="生命周期和作用域"><a href="#生命周期和作用域" class="headerlink" title="生命周期和作用域"></a>生命周期和作用域</h1><p>错误使用会导致严重的并发问题。<br>SqlSessionFactoryBuilder：主要执行的是Builder的任务，它的作用是可以接收各种原材料并使用它们组装成为SqlSessionFactory。因为一旦创建SqlSessionFactory就不再需要它了，所以它是局部变量。<br>SqlSessionFactory：主要执行的是Factory的任务，它的作用是可以生产出各种各样的sqlSession。因为sqlSession需要回收，由它统一保管所以运气期间要一直存在，没有理由丢弃或重新创建（单例），它的作用域应该是整个应用。<br>SqlSession：它是执行Sql语句的主体。因为它并不是线程安全的，所以不能被共享，作用域应该是请求或者方法域。因为SqlSession资源很重要，所以要使用finally语句关闭它。</p>
<h1 id="解决属性名与字段名不一致问题"><a href="#解决属性名与字段名不一致问题" class="headerlink" title="解决属性名与字段名不一致问题"></a>解决属性名与字段名不一致问题</h1><p>因为pojo属性的注入是基于反射调用对应set方法，当数据库与pojo属性不一致时就无法注入。<br>1.在sql语句中起别名，别名对应pojo中的属性名（不用）<br>2.使用结果集映射，规定pojo中属性名的映射名</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;resultMap id=&quot;&quot; type=&quot;&quot;&gt;</span><br><span class="line">    &lt;!-- cloumn是数据库的字段，property是实体类属性名 --&gt;</span><br><span class="line">    &lt;result column=&quot;&quot; property=&quot;&quot;/&gt;</span><br><span class="line">&lt;/resultMap&gt;</span><br></pre></td></tr></table></figure>
<h1 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h1><h2 id="STDOUT-LOGGING"><a href="#STDOUT-LOGGING" class="headerlink" title="STDOUT_LOGGING"></a>STDOUT_LOGGING</h2><p>这是标准默认日志工厂，可以直接使用</p>
<h2 id="LOG4G"><a href="#LOG4G" class="headerlink" title="LOG4G"></a>LOG4G</h2><p>1.导入依赖<br>2.创建log4j.properties</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#将等级为DEBUG的日志信息输出到console和file这两个目的地，console和file的定义在下面的代码</span><br><span class="line">log4j.rootLogger=DEBUG,console,file</span><br><span class="line"></span><br><span class="line">#控制台输出的相关设置</span><br><span class="line">log4j.appender.console = org.apache.log4j.ConsoleAppender</span><br><span class="line">log4j.appender.console.Target = System.out</span><br><span class="line">log4j.appender.console.Threshold=DEBUG</span><br><span class="line">log4j.appender.console.layout = org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.console.layout.ConversionPattern=[%c]-%m%n</span><br><span class="line"></span><br><span class="line">#文件输出的相关设置</span><br><span class="line">log4j.appender.file = org.apache.log4j.RollingFileAppender</span><br><span class="line">log4j.appender.file.File=./log/kuang.log</span><br><span class="line">log4j.appender.file.MaxFileSize=10mb</span><br><span class="line">log4j.appender.file.Threshold=DEBUG</span><br><span class="line">log4j.appender.file.layout=org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.file.layout.ConversionPattern=[%p][%d&#123;yy-MM-dd&#125;][%c]%m%n</span><br><span class="line"></span><br><span class="line">#日志输出级别</span><br><span class="line">log4j.logger.org.mybatis=DEBUG</span><br><span class="line">log4j.logger.java.sql=DEBUG</span><br><span class="line">log4j.logger.java.sql.Statement=DEBUG</span><br><span class="line">log4j.logger.java.sql.ResultSet=DEBUG</span><br><span class="line">log4j.logger.java.sql.PreparedStatement=DEBUG</span><br></pre></td></tr></table></figure>
<p>3.需要的时候设置log4j对应级别的输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import org.apache.log4j.Logger;</span><br><span class="line">public class EmployeeMapperTest &#123;</span><br><span class="line">    static Logger logger = Logger.getLogger(EmployeeMapperTest.class);</span><br><span class="line">    方法&#123;</span><br><span class="line">        logger.debug(&quot;调试信息&quot;);</span><br><span class="line">        logger.info(&quot;一般信息&quot;);</span><br><span class="line">        logger.warn(&quot;不会影响程序运行，但最好修正&quot;);</span><br><span class="line">        logger.error(&quot;影响到程序正常运行&quot;);</span><br><span class="line">        logger.fatal(&quot;整个项目无法运行&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h1><h2 id="使用limit分页"><a href="#使用limit分页" class="headerlink" title="使用limit分页"></a>使用limit分页</h2><p>接口创建</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">List&lt;Employee&gt; getEmployeeListLimit(Map&lt;String,Object&gt; map);</span><br></pre></td></tr></table></figure>
<p>mysql语句设置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;select id=&quot;getEmployeeListLimit&quot; resultType=&quot;employee&quot; parameterType=&quot;map&quot;&gt;</span><br><span class="line">    select * from tbl_employee where last_name=#&#123;name&#125; limit #&#123;startIndex&#125;,#&#123;pageSize&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>
<p>测试</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void getEmployeeListLimitTest()&#123;</span><br><span class="line">    HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">    map.put(&quot;name&quot;,&quot;admin2&quot;);</span><br><span class="line">    map.put(&quot;startIndex&quot;,2);</span><br><span class="line">    map.put(&quot;pageSize&quot;,5);</span><br><span class="line">    SqlSession sqlSession = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        sqlSession = MyBatisUtil.getSqlSession();</span><br><span class="line">        //通过类对象与配置文件生成对应的mapper实体</span><br><span class="line">        EmployeeMapper mapper = sqlSession.getMapper(EmployeeMapper.class);</span><br><span class="line">        List&lt;Employee&gt; employeeList = mapper.getEmployeeListLimit(map);</span><br><span class="line">        logger.info(employeeList);</span><br><span class="line">        sqlSession.commit();</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        //关闭sqlSession</span><br><span class="line">        sqlSession.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="RowBounds分页-了解"><a href="#RowBounds分页-了解" class="headerlink" title="RowBounds分页(了解)"></a>RowBounds分页(了解)</h2><h1 id="使用注解开发-建议简单语句使用"><a href="#使用注解开发-建议简单语句使用" class="headerlink" title="使用注解开发(建议简单语句使用)"></a>使用注解开发(建议简单语句使用)</h1><p>不再在xml文件中写sql语句, 而是使用注解直接写sql语句.<br>这么的问题是不能使用resultmap, 如果名称不一致无法注入.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Select(&quot;select * from tbl_employee where last_name=#&#123;name&#125; limit #&#123;startIndex&#125;,#&#123;pageSize&#125;&quot;)</span><br><span class="line">List&lt;Employee&gt; getEmployeeListLimit(Map&lt;String,Object&gt; map);</span><br><span class="line">//或者不使用map,使用注解参数实现</span><br><span class="line">@Select(&quot;select * from tbl_employee where last_name=#&#123;name&#125; limit #&#123;startIndex&#125;,#&#123;pageSize&#125;&quot;)</span><br><span class="line">List&lt;Employee&gt; getEmployeeListLimit(@Param(&quot;name&quot;)String name,@Param(&quot;startIndex&quot;)int startIndex,@Param(&quot;pageSize&quot;)int pageSize);</span><br></pre></td></tr></table></figure>
<h1 id="mybatis执行流程"><a href="#mybatis执行流程" class="headerlink" title="mybatis执行流程"></a>mybatis执行流程</h1><p>1.Resources获取加载全局配置文件<br>2.实例化SqlSessionFactoryBuilder,解析文件流, 生成Configuration.<br>3.使用Configuration生成SqlSessionFactory.<br>4.SqlSessionFactory调用openSession方法取得sqlSession. 中间要生成事务对象以及核心执行器.<br>5.通过sqlSession执行相关语句, 成功使用commit方法提交事务, 失败则调用rollback回滚, 最后调用close关闭session.</p>
<h1 id="复杂查询"><a href="#复杂查询" class="headerlink" title="复杂查询"></a>复杂查询</h1><h2 id="多对一"><a href="#多对一" class="headerlink" title="多对一"></a>多对一</h2><h3 id="按照查询嵌套处理"><a href="#按照查询嵌套处理" class="headerlink" title="按照查询嵌套处理"></a>按照查询嵌套处理</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;select id=&quot;getStudentsList&quot; resultMap=&quot;StudentTeacher&quot;&gt;</span><br><span class="line">    select * from student</span><br><span class="line">&lt;/select&gt;</span><br><span class="line">&lt;!-- 因为不能自动帮助查询老师,所以要使用resultMap定义,结果集会把column给property --&gt;</span><br><span class="line">&lt;resultMap id=&quot;StudentTeacher&quot; type=&quot;Student&quot;&gt;</span><br><span class="line">    &lt;result property=&quot;id&quot; column=&quot;id&quot; /&gt;</span><br><span class="line">    &lt;result property=&quot;name&quot; column=&quot;name&quot; /&gt;</span><br><span class="line">&lt;!--关联对象, 告诉java这个teacher对象对应的类, 获取的方式, 以及查询要使用的属性--&gt;</span><br><span class="line">    &lt;association property=&quot;teacher&quot; column=&quot;tid&quot; javaType=&quot;Teacher&quot; select=&quot;getTeacher&quot; /&gt;</span><br><span class="line">&lt;/resultMap&gt;</span><br><span class="line">&lt;!-- 当上面的association标签被调用时, 会进一步搜寻select中的方法, 并把column的值给这个方法让它调用 --&gt;</span><br><span class="line">&lt;select id=&quot;getTeacher&quot; resultType=&quot;Teacher&quot;&gt;</span><br><span class="line">    select * from teacher where id = #&#123;id&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>
<h3 id="按照结果嵌套处理"><a href="#按照结果嵌套处理" class="headerlink" title="按照结果嵌套处理"></a>按照结果嵌套处理</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;select id=&quot;getgetStudentsList&quot; resultMap=&quot;StudentTeacher&quot;&gt;</span><br><span class="line">    select student.id sid,student.name sname,teacher.name tname from student left join teacher on tid=teacher.id</span><br><span class="line">&lt;/select&gt;</span><br><span class="line">&lt;resultMap id=&quot;StudentTeacher&quot; type=&quot;Student&quot;&gt;</span><br><span class="line">    &lt;result property=&quot;id&quot; column=&quot;sid&quot; /&gt;</span><br><span class="line">    &lt;result property=&quot;name&quot; column=&quot;sname&quot; /&gt;</span><br><span class="line">    &lt;association property=&quot;teacher&quot; javaType=&quot;Teacher&quot;&gt;</span><br><span class="line">        &lt;result property=&quot;name&quot; column=&quot;tnam&quot; /&gt;</span><br><span class="line">    &lt;/association&gt;</span><br><span class="line">&lt;/resultMap&gt;</span><br></pre></td></tr></table></figure>
<h2 id="一对多"><a href="#一对多" class="headerlink" title="一对多"></a>一对多</h2><h3 id="按照查询嵌套处理-1"><a href="#按照查询嵌套处理-1" class="headerlink" title="按照查询嵌套处理"></a>按照查询嵌套处理</h3><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">select</span> id=&quot;getTeacherAndStudents&quot; resultMap=&quot;TeacherAndStudents&quot;&gt;</span><br><span class="line">    <span class="keyword">select</span> * <span class="keyword">from</span> teacher <span class="keyword">where</span> id = #&#123;id&#125;</span><br><span class="line">&lt;/<span class="keyword">select</span>&gt;</span><br><span class="line">&lt;resultMap id=&quot;TeacherAndStudents&quot; <span class="keyword">type</span>=&quot;Teacher&quot;&gt;</span><br><span class="line">    &lt;collection property=&quot;students&quot; javaType=&quot;ArrayList&quot; ofType=&quot;Student&quot; <span class="keyword">select</span>=&quot;getStudents&quot; column=&quot;id&quot;/&gt;</span><br><span class="line">&lt;/resultMap&gt;</span><br><span class="line">&lt;<span class="keyword">select</span> id=&quot;getStudents&quot; resultType=&quot;Student&quot;&gt;</span><br><span class="line">    <span class="keyword">select</span> id,<span class="type">name</span> <span class="keyword">from</span> student <span class="keyword">where</span> tid = #&#123;id&#125;</span><br><span class="line">&lt;/<span class="keyword">select</span>&gt;</span><br></pre></td></tr></table></figure>
<h3 id="按照结果嵌套处理-1"><a href="#按照结果嵌套处理-1" class="headerlink" title="按照结果嵌套处理"></a>按照结果嵌套处理</h3><h1 id="动态SQL"><a href="#动态SQL" class="headerlink" title="动态SQL"></a>动态SQL</h1><h2 id="if"><a href="#if" class="headerlink" title="if"></a>if</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//我们可以在语句中加入if判断, 如果存在这个参数, 则使用这个参数</span><br><span class="line">    &lt;select id=&quot;getStudentsList&quot; resultMap=&quot;StudentTeacher&quot;&gt;</span><br><span class="line">        select * from student where 1=1</span><br><span class="line">        &lt;if test=&quot;id != null&quot;&gt;</span><br><span class="line">            and id &gt; #&#123;id&#125;</span><br><span class="line">        &lt;/if&gt;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line">//而在接口处可以采用重载的方法</span><br><span class="line">    List&lt;Student&gt; getStudentsList(int id);</span><br><span class="line">    List&lt;Student&gt; getStudentsList();</span><br><span class="line">//或者直接在接口处传入map(省事),在map中添加参数</span><br><span class="line">    List&lt;Student&gt; getStudentsList(Map map)</span><br></pre></td></tr></table></figure>
<h2 id="choose-when-otherwise"><a href="#choose-when-otherwise" class="headerlink" title="choose,when,otherwise"></a>choose,when,otherwise</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 使用方法与if类似, 这里的choose相当于switch --&gt;</span><br><span class="line">    &lt;select id=&quot;getStudentsList&quot; resultMap=&quot;StudentTeacher&quot;&gt;</span><br><span class="line">        select * from student where 1=1</span><br><span class="line">        &lt;choose&gt;</span><br><span class="line">            &lt;when test=&quot;&quot;&gt;</span><br><span class="line"></span><br><span class="line">            &lt;/when&gt;</span><br><span class="line">            &lt;otherwise&gt;</span><br><span class="line"></span><br><span class="line">            &lt;/otherwise&gt;</span><br><span class="line">        &lt;/choose&gt;</span><br><span class="line">    &lt;/select&gt;</span><br></pre></td></tr></table></figure>
<h2 id="where"><a href="#where" class="headerlink" title="where"></a>where</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 在上面的if使用中我们发现为了保证语句通顺我们使用了where 1=1 --&gt;</span><br><span class="line">&lt;!-- 为了简化这种操作，可以使用where标签, 这样就能在必要时添加where，且可以正确的进行and或or的剔除 --&gt;</span><br><span class="line">    &lt;select id=&quot;getStudentsList&quot; resultMap=&quot;StudentTeacher&quot;&gt;</span><br><span class="line">        select * from student</span><br><span class="line">        &lt;where&gt;</span><br><span class="line">            &lt;if test=&quot;id != null&quot;&gt;</span><br><span class="line">                and id &gt; #&#123;id&#125;</span><br><span class="line">            &lt;/if&gt;</span><br><span class="line">        &lt;/where&gt;</span><br><span class="line">    &lt;/select&gt;</span><br></pre></td></tr></table></figure>
<h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- set与where类似, 它是为了应对update的拼接问题, 也可以正确剔除逗号 --&gt;</span><br><span class="line">&lt;update id=&quot;updateAuthorIfNecessary&quot;&gt;</span><br><span class="line">  update Author</span><br><span class="line">    &lt;set&gt;</span><br><span class="line">      &lt;if test=&quot;username != null&quot;&gt;username=#&#123;username&#125;,&lt;/if&gt;</span><br><span class="line">      &lt;if test=&quot;password != null&quot;&gt;password=#&#123;password&#125;,&lt;/if&gt;</span><br><span class="line">      &lt;if test=&quot;email != null&quot;&gt;email=#&#123;email&#125;,&lt;/if&gt;</span><br><span class="line">      &lt;if test=&quot;bio != null&quot;&gt;bio=#&#123;bio&#125;&lt;/if&gt;</span><br><span class="line">    &lt;/set&gt;</span><br><span class="line">  where id=#&#123;id&#125;</span><br><span class="line">&lt;/update&gt;</span><br></pre></td></tr></table></figure>
<h2 id="trim"><a href="#trim" class="headerlink" title="trim"></a>trim</h2><p>set与where都是由trim实现的, 所以也可以使用trim自定义标签</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- where设计了前缀剔除 --&gt;</span><br><span class="line">&lt;trim prefix=&quot;WHERE&quot; prefixOverrides=&quot;AND |OR &quot;&gt;</span><br><span class="line">  ...</span><br><span class="line">&lt;/trim&gt;</span><br><span class="line">&lt;!-- set设计了后缀剔除 --&gt;</span><br><span class="line">&lt;trim prefix=&quot;SET&quot; suffixOverrides=&quot;,&quot;&gt;</span><br><span class="line">  ...</span><br><span class="line">&lt;/trim&gt;</span><br></pre></td></tr></table></figure>
<h2 id="sql片段"><a href="#sql片段" class="headerlink" title="sql片段"></a>sql片段</h2><p>可以使用sql标签把复用部分的sql语句包裹起来, 复用时使用include标签复用.<br>注意: sql片段颗粒度要小, 方便复用, 不要包含trim标签</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;sql id=&quot;property&quot;&gt;</span><br><span class="line">  &lt;if test=&quot;username != null&quot;&gt;username=#&#123;username&#125;,&lt;/if&gt;</span><br><span class="line">  &lt;if test=&quot;password != null&quot;&gt;password=#&#123;password&#125;,&lt;/if&gt;</span><br><span class="line">  &lt;if test=&quot;email != null&quot;&gt;email=#&#123;email&#125;,&lt;/if&gt;</span><br><span class="line">  &lt;if test=&quot;bio != null&quot;&gt;bio=#&#123;bio&#125;&lt;/if&gt;</span><br><span class="line">&lt;/sql&gt;</span><br><span class="line">&lt;update id=&quot;updateAuthorIfNecessary&quot;&gt;</span><br><span class="line">  update Author</span><br><span class="line">    &lt;set&gt;</span><br><span class="line">        &lt;include refid=&quot;property&quot;/&gt;</span><br><span class="line">    &lt;/set&gt;</span><br><span class="line">  where id=#&#123;id&#125;</span><br><span class="line">&lt;/update&gt;</span><br></pre></td></tr></table></figure>
<h2 id="froeach"><a href="#froeach" class="headerlink" title="froeach"></a>froeach</h2><p>主要作用是接收集合, 对集合进行拼接</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;select id=&quot;getStudentsByList&quot; parameterType=&quot;map&quot; resultType=&quot;Student&quot;&gt;</span><br><span class="line">    select * from student</span><br><span class="line">    &lt;where&gt;</span><br><span class="line">        &lt;!-- 如果规定了老师的id就使用 --&gt;</span><br><span class="line">        &lt;if test=&quot;tid != null&quot;&gt;</span><br><span class="line">            and tid = #&#123;tid&#125;</span><br><span class="line">        &lt;/if&gt;</span><br><span class="line">        &lt;!-- 如果给了学生的list就使用 --&gt;</span><br><span class="line">        &lt;if test=&quot;studentsList != null&quot;&gt;</span><br><span class="line">        &lt;!-- 例如我需要生成(a or b or c)的句子,abc在同一集合中 --&gt;</span><br><span class="line">            &lt;foreach collection=&quot;studentsList&quot; item=&quot;id&quot; open=&quot;and (&quot; separator=&quot;or&quot; close=&quot;)&quot;&gt;</span><br><span class="line">                id = #&#123;id&#125;</span><br><span class="line">            &lt;/foreach&gt;</span><br><span class="line">        &lt;/if&gt;</span><br><span class="line">    &lt;/where&gt;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>
<h1 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h1><p>使用情况: 经常查询且不经常改变的数据<br>一级缓存默认开启(sqlSession级别),会缓存当前sqlSession查询到的数据.<br>二级缓存要手动开启(namespace级别),通过实现cache接口定义二级缓存.</p>
<h2 id="清除策略"><a href="#清除策略" class="headerlink" title="清除策略"></a>清除策略</h2><p>LRU – 最近最少使用：移除最长时间不被使用的对象。<br>FIFO – 先进先出：按对象进入缓存的顺序来移除它们。<br>SOFT – 软引用：基于垃圾回收器状态和软引用规则移除对象。<br>WEAK – 弱引用：更积极地基于垃圾收集器状态和弱引用规则移除对象。</p>
<h2 id="缓存失效的情况"><a href="#缓存失效的情况" class="headerlink" title="缓存失效的情况"></a>缓存失效的情况</h2><p>所有增删改都因为会更改数据库内容, 导致缓存刷新.<br>sqlSession.clearCache可以手动刷新缓存.</p>
<h2 id="二级缓存配置"><a href="#二级缓存配置" class="headerlink" title="二级缓存配置"></a>二级缓存配置</h2><p>二级缓存会接收一级缓存的内容, 不同mapper的缓存相互独立. 且实体类需要序列化,否则会报错.<br>config文件中开启缓存</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;settings&gt;</span><br><span class="line">    &lt;!-- 缓存是否开启 --&gt;</span><br><span class="line">    &lt;setting name=&quot;cacheEnable&quot; value=&quot;true&quot; /&gt;</span><br><span class="line">&lt;/settings&gt;</span><br></pre></td></tr></table></figure>
<p>mapper配置文件配置缓存</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;cache</span><br><span class="line">    &lt;!-- 清除策略 --&gt;</span><br><span class="line">  eviction=&quot;FIFO&quot;</span><br><span class="line">  &lt;!-- 刷新时间 --&gt;</span><br><span class="line">  flushInterval=&quot;60000&quot;</span><br><span class="line">  &lt;!-- 缓存大小 --&gt;</span><br><span class="line">  size=&quot;512&quot;</span><br><span class="line">  &lt;!-- 是否只读 --&gt;</span><br><span class="line">  readOnly=&quot;true&quot;/&gt;</span><br></pre></td></tr></table></figure>
<h2 id="查询顺序"><a href="#查询顺序" class="headerlink" title="查询顺序"></a>查询顺序</h2><p>二级缓存-&gt;一级缓存-&gt;查询数据库</p>
]]></content>
      <categories>
        <category>框架</category>
      </categories>
  </entry>
  <entry>
    <title>springboot</title>
    <url>/2021/12/29/%E6%A1%86%E6%9E%B6/springboot/</url>
    <content><![CDATA[<h1 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h1><p>这个笔记是建立在SSM笔记基础上的, 着重使用以及boot本身的源码解析.<br>如果在此查询不到, 可以查询对应的SSM笔记.</p>
<span id="more"></span>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>导入场景依赖</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;parent&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.3.4.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/parent&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>
<p>创建主程序类,这是因为以前主程序是由tomcat操控的,而现在由我们接手.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">public class MainApplication &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(MainApplication.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建控制器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class HelloController &#123;</span><br><span class="line">    @RequestMapping(&quot;/hello&quot;)</span><br><span class="line">    public String index()&#123;</span><br><span class="line">        return &quot;Hello, SpringBoot 2!&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="简化配置"><a href="#简化配置" class="headerlink" title="简化配置"></a>简化配置</h2><p>统一在application.properties中修改配置<br>在官方文档查询</p>
<h2 id="简化部署"><a href="#简化部署" class="headerlink" title="简化部署"></a>简化部署</h2><p>在maven中使用如下插件,可以直接把项目打包为jar包, 直接在目标服务器执行即可<br>注意:cmd要关闭快速编辑</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">       &lt;plugins&gt;</span><br><span class="line">           &lt;plugin&gt;</span><br><span class="line">               &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">               &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">           &lt;/plugin&gt;</span><br><span class="line">       &lt;/plugins&gt;</span><br><span class="line">   &lt;/build&gt;</span><br></pre></td></tr></table></figure>
<h1 id="自动配置原理"><a href="#自动配置原理" class="headerlink" title="自动配置原理"></a>自动配置原理</h1><h2 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h2><p>通过在maven中导入父项目的信息从而取得所有可能用上的依赖信息, 这些依赖基本都声明了版本号.<br>所以在使用时只需要导入依赖而不用再关注版本号, 版本号由父项目提供.<br>如果必须要使用特定的版本号, 则在properties标签中声明版本号.<br>场景启动器: spring-boot-starter-web这种格式的依赖是直接配置对应场景下常用的所有依赖.</p>
<h2 id="自动配置"><a href="#自动配置" class="headerlink" title="自动配置"></a>自动配置</h2><p>当前场景需要配置的内容都会由spring帮助配置.<br>默认扫描主程序所在包及其下面所有包,可以在@SpringBootApplication使用scanBasePackages属性设置.</p>
<h2 id="自动配置的过程"><a href="#自动配置的过程" class="headerlink" title="自动配置的过程"></a>自动配置的过程</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@SpringBootApplication以此注解为自动配置的开始. 它是一个复合注解, 又包括:</span><br><span class="line">&#123;</span><br><span class="line">	@SpringBootConfiguration:代表当前类是一个配置类</span><br><span class="line">	@ComponentScan(&quot;&quot;):指定扫描的包</span><br><span class="line">	@EnableAutoConfiguration它又可以分为以下两个注解:</span><br><span class="line">	&#123;</span><br><span class="line">		@AutoConfigurationPackage:导入main文件所在包的所有组件</span><br><span class="line">		@Import(AutoConfigurationImportSelector.class):从配置文件导入写死的127个配置文件</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="按需开启配置"><a href="#按需开启配置" class="headerlink" title="按需开启配置"></a>按需开启配置</h2><p>可以在配置文件中使用debug = true查看哪些配置开启, 哪些配置没有开启.<br>虽然我们127个场景的所有自动配置启动的时候默认全部加载。但是只会按照需求进行部分的配置, 原理就是部分的配置是使用@ConditionalOn…配置的, 没有达到条件就不会配置.</p>
<h2 id="修改默认配置"><a href="#修改默认配置" class="headerlink" title="修改默认配置"></a>修改默认配置</h2><p>通过类型查找, 使用Bean注解返回修改默认配置.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Bean</span><br><span class="line">@ConditionalOnBean(MultipartResolver.class)  //容器中有这个类型组件</span><br><span class="line">@ConditionalOnMissingBean(name = DispatcherServlet.MULTIPART_RESOLVER_BEAN_NAME) //容器中没有这个名字 multipartResolver 的组件</span><br><span class="line">public MultipartResolver multipartResolver(MultipartResolver resolver) &#123;</span><br><span class="line">    //SpringMVC multipartResolver。防止有些用户配置的文件上传解析器不符合规范</span><br><span class="line">    //给@Bean标注的方法传入了对象参数，这个参数的值就会从容器中找。</span><br><span class="line">    //找到后作为返回值返回时, 又因为有Bean注解, 会自动把返回值的name设为方法名, 并交给容器管理</span><br><span class="line">    //这样就有名称正确的组件了</span><br><span class="line">	return resolver;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="以用户配置优先"><a href="#以用户配置优先" class="headerlink" title="以用户配置优先"></a>以用户配置优先</h2><p>使用@ConditionalOnMissingBean注解, 当用户没配置时才启用对应配置, 用户配置了则不启用.</p>
<h1 id="底层注解"><a href="#底层注解" class="headerlink" title="底层注解"></a>底层注解</h1><h2 id="Configuration"><a href="#Configuration" class="headerlink" title="@Configuration"></a>@Configuration</h2><p>用于完全注解开发, 替换xml文件配置组件(默认单例).</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//告诉SpringBoot这是一个配置类,proxyBeanMethods是用来指定bean注解的方法是否使用代理, </span><br><span class="line">//默认是true, 所以不论创建几次都是从ioc容器中获得对象, 而使用false, 则每次获取的都是新对象.</span><br><span class="line">//注意, true的时候取得对象相同是因为返回的是一个代理对象, 而即使是false, 这个代理对象仍在, 可以通过getBean获得.</span><br><span class="line">@Configuration(proxyBeanMethods = false) </span><br><span class="line">public class MyConfig &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Full:外部无论对配置类中的这个组件注册方法调用多少次获取的都是之前注册容器中的单实例对象</span><br><span class="line">     * Lite:不再检查容器中是否有对象, 直接创建, 更快</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Bean //给容器中添加组件。以方法名作为组件的id。返回类型就是组件类型。返回的值，就是组件在容器中的实例</span><br><span class="line">    public User user01()&#123;</span><br><span class="line">        User zhangsan = new User(&quot;zhangsan&quot;, 18);</span><br><span class="line">        //user组件依赖了Pet组件</span><br><span class="line">        zhangsan.setPet(tomcatPet());</span><br><span class="line">        return zhangsan;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean(&quot;tom&quot;)</span><br><span class="line">    public Pet tomcatPet()&#123;</span><br><span class="line">        return new Pet(&quot;tomcat&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以使用注释直接注册组件.</p>
<h2 id="import"><a href="#import" class="headerlink" title="@import"></a>@import</h2><p>注释于组件上方, 导入指定类型的组件, 默认名为全类名.</p>
<h2 id="Conditional"><a href="#Conditional" class="headerlink" title="@Conditional"></a>@Conditional</h2><p>满足指定的条件就进行注入.@ConditionalOn…</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//当有teacher组件时才注册student组件</span><br><span class="line">@ConditionalOnBean(name = &quot;teacher&quot;)</span><br><span class="line">@Repository</span><br><span class="line">public class student&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ImportResource"><a href="#ImportResource" class="headerlink" title="ImportResource"></a>ImportResource</h2><p>springboot并不会自动解析bean.xml, 所以要找一个类上方使用这个注解导入.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@ImportResource(&quot;classpath:bean.xml&quot;)</span><br></pre></td></tr></table></figure>
<h2 id="ConfigurationProperties"><a href="#ConfigurationProperties" class="headerlink" title="@ConfigurationProperties"></a>@ConfigurationProperties</h2><p>使用这个注解时在容器中生成对象时, 会在properties中自动搜寻对应要注入的值进行注入.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- properties中 --&gt;</span><br><span class="line">mycar.brand = &quot;BYD&quot;</span><br><span class="line">mycar.price = 1000000</span><br><span class="line">&lt;!-- 对象中使用此功能 --&gt;</span><br><span class="line">@Component</span><br><span class="line">@ConfigurationProperties(prefix = &quot;mycar&quot;)</span><br><span class="line">public class Car &#123;</span><br><span class="line"></span><br><span class="line">    private String brand;</span><br><span class="line">    private Integer price;</span><br><span class="line">&#125;</span><br><span class="line">&lt;!-- 也可以直接在配置文件class中设置自动注入 --&gt;</span><br><span class="line">&lt;!-- 时候处理第三方类时的注入, 因为第三方类并不会设置为组件 --&gt;</span><br><span class="line">@Configuration</span><br><span class="line">@EnableConfigurationProperties(Car.class)</span><br><span class="line">//1、开启Car配置绑定功能</span><br><span class="line">//2、把这个Car这个组件自动注册到容器中</span><br><span class="line">public class MyConfig &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="yml"><a href="#yml" class="headerlink" title="yml"></a>yml</h1><p>一种不只是标记语言的标记语言.</p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>● key: value  kv之间有空格<br>● 大小写敏感<br>● 使用缩进表示层级关系<br>● 缩进不允许使用tab，只允许空格<br>● 缩进的空格数不重要，只要相同层级的元素左对齐即可<br>● ‘#’表示注释<br>● 字符串无需加引号，如果要加，’’与””表示字符串内容会被 转义/不转义(‘’会直接输出/n)</p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>字面量：单个的、不可再分的值。date、boolean、string、number、null</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">k: v</span><br></pre></td></tr></table></figure>
<p>对象：键值对的集合。map、hash、set、object </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">行内写法：  k: &#123;k1:v1,k2:v2,k3:v3&#125;</span><br><span class="line">#或</span><br><span class="line">k: </span><br><span class="line">  k1: v1</span><br><span class="line">  k2: v2</span><br><span class="line">  k3: v3</span><br></pre></td></tr></table></figure>
<p>数组：一组按次序排列的值。array、list、queue</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">行内写法：  k: [v1,v2,v3]</span><br><span class="line">#或者</span><br><span class="line">k:</span><br><span class="line"> - v1</span><br><span class="line"> - v2</span><br><span class="line"> - v3</span><br></pre></td></tr></table></figure>
<p>@Data表示从配置文件注入</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Data</span><br><span class="line">public class Person &#123;</span><br><span class="line">    </span><br><span class="line">    private String userName;</span><br><span class="line">    private Boolean boss;</span><br><span class="line">    private Date birth;</span><br><span class="line">    private Integer age;</span><br><span class="line">    private Pet pet;</span><br><span class="line">    private String[] interests;</span><br><span class="line">    private List&lt;String&gt; animal;</span><br><span class="line">    private Map&lt;String, Object&gt; score;</span><br><span class="line">    private Set&lt;Double&gt; salarys;</span><br><span class="line">    private Map&lt;String, List&lt;Pet&gt;&gt; allPets;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Data</span><br><span class="line">public class Pet &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private Double weight;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># yaml表示以上对象</span></span><br><span class="line"><span class="attr">person:</span></span><br><span class="line">  <span class="attr">userName:</span> <span class="string">zhangsan</span></span><br><span class="line">  <span class="attr">boss:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">birth:</span> <span class="number">2019</span><span class="string">/12/12</span> <span class="number">20</span><span class="string">:12:33</span></span><br><span class="line">  <span class="attr">age:</span> <span class="number">18</span></span><br><span class="line">  <span class="attr">pet:</span> </span><br><span class="line">    <span class="attr">name:</span> <span class="string">tomcat</span></span><br><span class="line">    <span class="attr">weight:</span> <span class="number">23.4</span></span><br><span class="line">  <span class="attr">interests:</span> [<span class="string">篮球</span>,<span class="string">游泳</span>]</span><br><span class="line">  <span class="attr">animal:</span> </span><br><span class="line">    <span class="bullet">-</span> <span class="string">jerry</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">mario</span></span><br><span class="line">  <span class="attr">score:</span></span><br><span class="line">    <span class="attr">english:</span> </span><br><span class="line">      <span class="attr">first:</span> <span class="number">30</span></span><br><span class="line">      <span class="attr">second:</span> <span class="number">40</span></span><br><span class="line">      <span class="attr">third:</span> <span class="number">50</span></span><br><span class="line">    <span class="attr">math:</span> [<span class="number">131</span>,<span class="number">140</span>,<span class="number">148</span>]</span><br><span class="line">    <span class="attr">chinese:</span> &#123;<span class="attr">first:</span> <span class="number">128</span>,<span class="attr">second:</span> <span class="number">136</span>&#125;</span><br><span class="line">  <span class="attr">salarys:</span> [<span class="number">3999</span>,<span class="number">4999.98</span>,<span class="number">5999.99</span>]</span><br><span class="line">  <span class="attr">allPets:</span></span><br><span class="line">    <span class="attr">sick:</span></span><br><span class="line">      <span class="bullet">-</span> &#123;<span class="attr">name:</span> <span class="string">tom</span>&#125;</span><br><span class="line">      <span class="bullet">-</span> &#123;<span class="attr">name:</span> <span class="string">jerry</span>,<span class="attr">weight:</span> <span class="number">47</span>&#125;</span><br><span class="line">    <span class="attr">health:</span> [&#123;<span class="attr">name:</span> <span class="string">mario</span>,<span class="attr">weight:</span> <span class="number">47</span>&#125;]</span><br></pre></td></tr></table></figure>
<p>在对应的类上使用@ConfigurationProperties注解,设置prefix = “person”就可以自动注入了.</p>
<h1 id="web开发"><a href="#web开发" class="headerlink" title="web开发"></a>web开发</h1><h2 id="静态资源访问"><a href="#静态资源访问" class="headerlink" title="静态资源访问"></a>静态资源访问</h2><p>只要静态资源放在类路径下： called static/public/resources/META-INF/resources<br>就可以直接访问.<br>在访问时会优先去控制器查询是否有动态资源, 如果有动态资源则进行动态资源的访问, 没有就查询是否有静态资源.<br>为了区别静态资源, 可以选择给静态资源添加前缀(默认无前缀).</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  mvc:</span><br><span class="line">  #默认是/**</span><br><span class="line">    static-path-pattern: /res/**</span><br></pre></td></tr></table></figure>
<p>也可以修改默认的静态资源访问路径</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:  </span><br><span class="line">  resources:</span><br><span class="line">  #加中括号是因为这里传入的是数组</span><br><span class="line">    static-locations: [classpath:/haha/]</span><br></pre></td></tr></table></figure>

<p>欢迎页面<br>静态资源路径下有index.html则访问主页面时可以直接跳转.(这个方式配置了静态资源前缀后会失效!)<br>控制器能处理/index则交给控制器处理.</p>
<h2 id="静态资源访问原理"><a href="#静态资源访问原理" class="headerlink" title="静态资源访问原理"></a>静态资源访问原理</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">        public void addResourceHandlers(ResourceHandlerRegistry registry) &#123;</span><br><span class="line">            //这里进行是否映射静态资源路径的判断(配置文件可以修改addMappings属性)</span><br><span class="line">            //resourceProperties对应的就是spring.web.resources</span><br><span class="line">            if (!this.resourceProperties.isAddMappings()) &#123;</span><br><span class="line">                logger.debug(&quot;Default resource handling disabled&quot;);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            //从配置文件取得缓存周期,取得缓存控制器(因此也可以通过配置文件修改)</span><br><span class="line">            Duration cachePeriod = this.resourceProperties.getCache().getPeriod();</span><br><span class="line">            CacheControl cacheControl = this.resourceProperties.getCache().getCachecontrol().toHttpCacheControl();</span><br><span class="line">            //webjars的规则</span><br><span class="line">            if (!registry.hasMappingForPattern(&quot;/webjars/**&quot;)) &#123;</span><br><span class="line">                //为webjars路径下的文件配置查找路径, 配置缓存周期和缓存控制器</span><br><span class="line">                customizeResourceHandlerRegistration(registry.addResourceHandler(&quot;/webjars/**&quot;)</span><br><span class="line">                        .addResourceLocations(&quot;classpath:/META-INF/resources/webjars/&quot;)</span><br><span class="line">                        .setCachePeriod(getSeconds(cachePeriod)).setCacheControl(cacheControl));</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            //静态资源路径的规则</span><br><span class="line">            String staticPathPattern = this.mvcProperties.getStaticPathPattern();</span><br><span class="line">            if (!registry.hasMappingForPattern(staticPathPattern)) &#123;</span><br><span class="line">                customizeResourceHandlerRegistration(registry.addResourceHandler(staticPathPattern)</span><br><span class="line">                        //这里的staticlocation就是配置中的默认静态资源访问路径</span><br><span class="line">                        .addResourceLocations(getResourceLocations(this.resourceProperties.getStaticLocations()))</span><br><span class="line">                        .setCachePeriod(getSeconds(cachePeriod)).setCacheControl(cacheControl));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h2 id="请求参数处理"><a href="#请求参数处理" class="headerlink" title="请求参数处理"></a>请求参数处理</h2><h3 id="rest原理"><a href="#rest原理" class="headerlink" title="rest原理"></a>rest原理</h3><p>boot会帮助我们自动注册hiddenHttpMethodFilter, 它默认接收请求方式的key为_method.<br>它的开启条件是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//项目中没有HiddenHttpMethodFilter就使用</span><br><span class="line">@ConditionalOnMissingBean(&#123;HiddenHttpMethodFilter.class&#125;)</span><br><span class="line">//配置文件的spring.mvc.hiddenmethod.filter.enabled是true</span><br><span class="line">@ConditionalOnProperty(</span><br><span class="line">    prefix = &quot;spring.mvc.hiddenmethod.filter&quot;,</span><br><span class="line">    name = &#123;&quot;enabled&quot;&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>实现过程:(能直接发送的请求方式不会走这个过程)<br>先由Filter判断请求方式, 传入的method是否满足要求. 再把这些交给包装模式的wapper, wapper重写了getMethod方法, 让返回值为传入的method.</p>
<h3 id="请求映射原理"><a href="#请求映射原理" class="headerlink" title="请求映射原理"></a>请求映射原理</h3><p>这里对springMVC的DispatcherServlet服务过程进行进一步的源码分析.</p>
<p>handlermapping取得的方法的过程:<br>程序中所有的mapping注解请求地址和它绑定的控制器的地址都会以键值对的形式存储在handlermapping中, 当收到请求地址时会逐个遍历键值对, 为请求地址分配控制器.<br>所以我们也可以自定义handlermapping为不同前缀的键值对分配不同的handlermapping, 形成前缀与handlermapping的映射, 提高查找控制器的速度.</p>
<p>handleradapter为方法进行适配的具体方法:<br>将handlermapping取得的方法交给handleradapter,handleradapter会持有几种适配器, 逐个使用support方法进行判断是否与当前方法进行适配(因此这里也可以自定义), 如果适配则返回这个适配器.<br>使用这个适配器对方法进行解析, 设置参数解析器与返回值处理器. 接着会取得形参的所有详细信息(参数类型,位置,注解等等), 逐个遍历这些形参, 把这些形参交给参数解析器, 参数解析器会遍历它持有的解析方法, 如果参数与解析方法符合, 则利用它的信息进行解析.</p>
<p>解析器解析自定义类的过程:<br>解析器遍历找到解析自定义类的解析器, 进入这个解析器. 创建空的自定义类对象, 逐个遍历传入的参数, 比对属性名, 比对成功后使用converter转换器将这个参数转换为需要的类型, 再把这个数据交给类对象对应的属性. 这里存在一个问题, 当自定义类中属性的类型converter转换器无法转换时, 会出现异常, 所以当自定义类有自定义类属性时, 需要定制自己的converter转换器.</p>
<h3 id="普通参数与基本注解"><a href="#普通参数与基本注解" class="headerlink" title="普通参数与基本注解"></a>普通参数与基本注解</h3><p>(对springMVC笔记的获取请求参数方法进行重写, 建议对照查看)<br>1.注解(为形参注入的注解)<br>@PathVariable:获取请求地址中的参数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//可以取得单个值, 也可以依靠map取得所有的值</span><br><span class="line">@PathVariable(&quot;id&quot;) Integer id,</span><br><span class="line">@PathVariable(&quot;username&quot;) String name,</span><br><span class="line">@PathVariable Map&lt;String,String&gt; pv,</span><br></pre></td></tr></table></figure>
<p>@RequestHeader:获取请求头中的参数<br>@RequestParam:获取请求中的参数<br>@CookieValue:获取cookie的参数<br>以上都可以通过单个或map获取.<br>@RequestBody:获取整个请求体(只有post才有).<br>@RequestAttribute:获取请求域中的参数.</p>
<p>2.使用原生requestAPI取得参数</p>
<p>3.复杂参数(主要作用是用于域对象的设置)<br>map,model 用于设置request域数据.<br>redirectAttributes用于重定向的数据设置.<br>ServletResponse</p>
<p>4.使用预设的自定义对象接收参数</p>
<h2 id="响应值处理"><a href="#响应值处理" class="headerlink" title="响应值处理"></a>响应值处理</h2><p>参数有自己的解析器, 返回值也有自己的解析器. 拿到返回值与类型, 使用类型与返回值解析器进行比对, 比对成功将返回值交给对应的解析器. 解析器通过内容协商确定要响应的类型, 匹配响应的httpmessageconverter进行类型的转换, 同时在响应头告诉浏览器响应的类型.<br>messageconverter有boot再带的一些转换方法, 引入json,xml依赖等也会为其添加转换方法.也可以自己定制相应的转换器.</p>
<h3 id="ResponseBody"><a href="#ResponseBody" class="headerlink" title="@ResponseBody"></a>@ResponseBody</h3><p>响应分为页面跳转与页面响应.<br>将此注释加到控制器上, 返回的String就会作为响应体送回, 不再进行页面跳转.</p>
<h3 id="内容协商"><a href="#内容协商" class="headerlink" title="内容协商"></a>内容协商</h3><p>浏览器在发送请求的时候会附上自己能接收的响应类型, 这个操作称为内容协商.<br>会先取出可以解析杯发送数据的converter, 再逐个判断是否能发送需要的类型, 当满足要求后就使用.</p>
<h2 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h2><p>编写拦截器.<br>注意, 这三个拦截器不管需不需要都要进行重写, 否则会导致拦截器的excludePathPatterns失效.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class FirstInterceptor implements HandlerInterceptor &#123;</span><br><span class="line">    //这里的返回值决定是否放行</span><br><span class="line">    @Override</span><br><span class="line">    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;FirstInterceptor--&gt;preHandle&quot;);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;FirstInterceptor--&gt;postHandle&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;FirstInterceptor--&gt;afterCompletion&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用springMVC的定制配置拦截器.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class webConfig &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    public WebMvcConfigurer webMvcConfigurer()&#123;</span><br><span class="line">        return new WebMvcConfigurer() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void addInterceptors(InterceptorRegistry registry) &#123;</span><br><span class="line">                registry.addInterceptor(new LogInInterceptor())</span><br><span class="line">                        .addPathPatterns(&quot;/**&quot;)//会拦截包括静态资源内的所有资源</span><br><span class="line">                        .excludePathPatterns(&quot;/&quot;,&quot;login&quot;,&quot;/css/**&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="springMVC的定制"><a href="#springMVC的定制" class="headerlink" title="springMVC的定制"></a>springMVC的定制</h2><p>在webConfig中使用方法返回一个新的WebMvcConfigurer, 并在其中重写要定制的方法.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public WebMvcConfigurer webMvcConfigurer()&#123;</span><br><span class="line">    return new WebMvcConfigurer() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="配置url匹配模式"><a href="#配置url匹配模式" class="headerlink" title="配置url匹配模式"></a>配置url匹配模式</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void configurePathMatch(PathMatchConfigurer configurer) &#123;</span><br><span class="line">    //是否将url末尾的/忽略, /user=/user/</span><br><span class="line">    configurer.setUseTrailingSlashMatch(true);</span><br><span class="line">    //创建一个帮助类并交给configurer, 它本身带有一些优化url的方法</span><br><span class="line">    //可以直接使用, 也可以对它进行一些改造</span><br><span class="line">    UrlPathHelper urlPathHelper = new UrlPathHelper();</span><br><span class="line">    //设置自动删除分号,默认true, 设置为false是为了接收矩阵变量</span><br><span class="line">    urlPathHelper.setRemoveSemicolonContent(false);</span><br><span class="line">    configurer.setUrlPathHelper(urlPathHelper);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="添加converter转换器"><a href="#添加converter转换器" class="headerlink" title="添加converter转换器"></a>添加converter转换器</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void addFormatters(FormatterRegistry registry) &#123;</span><br><span class="line">    //添加转换器</span><br><span class="line">    //假设传入的字符串是以逗号分隔属性</span><br><span class="line">    registry.addConverter(new Converter&lt;String, Student&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public Student convert(String source) &#123;</span><br><span class="line">            if (!source.isEmpty())&#123;</span><br><span class="line">                Student student = new Student();</span><br><span class="line">                String[] split = source.split(&quot;,&quot;);</span><br><span class="line">                student.setName(split[0]);</span><br><span class="line">                student.setAge(Integer.parseInt(split[1]));</span><br><span class="line">                student.setGender(split[2]);</span><br><span class="line">                return student;</span><br><span class="line">            &#125;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="扩展messageconverter"><a href="#扩展messageconverter" class="headerlink" title="扩展messageconverter"></a>扩展messageconverter</h3><p>先自定义messageconverter</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyConverter implements HttpMessageConverter&lt;Student&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    //不允许读</span><br><span class="line">    public boolean canRead(Class clazz, MediaType mediaType) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean canWrite(Class clazz, MediaType mediaType) &#123;</span><br><span class="line">        //如果要写入的类为student则允许写</span><br><span class="line">        if (clazz==Student.class)&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public List&lt;MediaType&gt; getSupportedMediaTypes() &#123;</span><br><span class="line">        //告诉外部可以输出的协议数据类型xml,json,自定义等</span><br><span class="line">        return MediaType.parseMediaTypes(&quot;application/mytype&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    //不写读入方法</span><br><span class="line">    @Override</span><br><span class="line">    public Student read(Class clazz, HttpInputMessage inputMessage) throws IOException, HttpMessageNotReadableException &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void write(Student student, MediaType contentType, HttpOutputMessage outputMessage) throws IOException, HttpMessageNotWritableException &#123;</span><br><span class="line">        //自定义协议数据的写出, 让属性以句子发送</span><br><span class="line">        String data = student.getName()+&quot;今年&quot;+student.getAge()+&quot;岁,是个&quot;+student.getGender()+&quot;生&quot;;</span><br><span class="line">        //写出</span><br><span class="line">        OutputStream body = outputMessage.getBody();</span><br><span class="line">        body.write(data.getBytes());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在WebMvcConfigurer中调用方法, 添加这个messageconverter</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> @Override</span><br><span class="line">public void extendMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) &#123;</span><br><span class="line">    converters.add(new MyConverter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="扩展内容协商功能"><a href="#扩展内容协商功能" class="headerlink" title="扩展内容协商功能"></a>扩展内容协商功能</h3><p>为了使用自定义的messageconverter就需要服务器可以接收到自定义的响应类型请求.<br>传统的写法为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?formant= 响应类型</span><br></pre></td></tr></table></figure>
<p>但服务器默认是不知道自定义的响应类型的, 所以需要扩展内容协商功能<br>这里是重写, 并不是添加.所以如果不添加请求头方式的请求的解析方式的话, 会无法解析请求头发送的请求响应类型.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void configureContentNegotiation(ContentNegotiationConfigurer configurer) &#123;</span><br><span class="line">    //设置接收的属性名与响应类型的对应关系</span><br><span class="line">    HashMap&lt;String, MediaType&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">    map.put(&quot;json&quot;,MediaType.APPLICATION_JSON);</span><br><span class="line">    map.put(&quot;xml&quot;,MediaType.APPLICATION_ATOM_XML);</span><br><span class="line">    map.put(&quot;mytype&quot;,MediaType.parseMediaType(&quot;application/mytype&quot;));</span><br><span class="line">    //使用map生成策略</span><br><span class="line">    //生成参数类型请求解析策略</span><br><span class="line">    ParameterContentNegotiationStrategy parameterContentNegotiationStrategy = new ParameterContentNegotiationStrategy(map);</span><br><span class="line">    //生成请求头类型请求解析策略,如果不添加, 就视为默认</span><br><span class="line">    HeaderContentNegotiationStrategy headerContentNegotiationStrategy = new HeaderContentNegotiationStrategy();</span><br><span class="line">    configurer.strategies(Arrays.asList(parameterContentNegotiationStrategy,headerContentNegotiationStrategy));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="配置拦截器"><a href="#配置拦截器" class="headerlink" title="配置拦截器"></a>配置拦截器</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void addInterceptors(InterceptorRegistry registry) &#123;</span><br><span class="line">    registry.addInterceptor(new LogInInterceptor())</span><br><span class="line">            .addPathPatterns(&quot;/**&quot;)//会拦截包括静态资源内的所有资源</span><br><span class="line">            .excludePathPatterns(&quot;/&quot;,&quot;login&quot;,&quot;/css/**&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>boot不用像SSM一样配置文件上传解析器, 所以可以直接进行设置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@PostMapping(&quot;/testUp&quot;)</span><br><span class="line">//MultipartFile就存储了上传的各种信息</span><br><span class="line">public String testUp(@RequestPart(&quot;photos&quot;)MultipartFile[] photo, HttpSession session) throws IOException &#123;</span><br><span class="line">    //获取上传的文件的文件名</span><br><span class="line">    String fileName = photo.getOriginalFilename();</span><br><span class="line">    //获取上传的文件的后缀名 </span><br><span class="line">    String suffixName = fileName.substring(fileName.lastIndexOf(&quot;.&quot;));</span><br><span class="line">    //将UUID作为文件名, 应对重名</span><br><span class="line">    String uuid = UUID.randomUUID().toString();</span><br><span class="line">    //将uuid和后缀名拼接后的结果作为最终的文件名</span><br><span class="line">    fileName = uuid + suffixName;</span><br><span class="line">    //通过ServletContext获取服务器中photo目录的路径</span><br><span class="line">    ServletContext servletContext = session.getServletContext();</span><br><span class="line">    String photoPath = servletContext.getRealPath(&quot;photo&quot;);</span><br><span class="line">    File file = new File(photoPath);</span><br><span class="line">    //判断photoPath所对应路径是否存在</span><br><span class="line">    if(!file.exists())&#123;</span><br><span class="line">        //若不存在，则创建目录</span><br><span class="line">        file.mkdir();</span><br><span class="line">    &#125;</span><br><span class="line">    // File.separator是文件分隔符, 这样就构成了指向路径与文件名的一个finalPath </span><br><span class="line">    String finalPath = photoPath + File.separator + fileName;</span><br><span class="line">    //上传文件</span><br><span class="line">    photo.transferTo(new File(finalPath));</span><br><span class="line">    return &quot;success&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h3><p>可以在配置文件中修改spring.servlet.multipart的属性来更改配置.</p>
<h3 id="底层过程"><a href="#底层过程" class="headerlink" title="底层过程"></a>底层过程</h3><p>1.自动配置了文件上传解析器<br>2.请求进来使用文件上传解析器判断（isMultipart）并封装（resolveMultipart，返回MultipartHttpServletRequest）文件上传请求<br>3.参数解析器来解析请求中的文件内容封装成MultipartFile<br>4. 将request中文件信息封装为一个Map；MultiValueMap&lt;String, MultipartFile&gt;FileCopyUtils。实现文件流的拷贝</p>
<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><h3 id="默认规则"><a href="#默认规则" class="headerlink" title="默认规则"></a>默认规则</h3><p>1.默认情况下, 所有错误会交给/error映射.<br>2.对于机器客户端会生成json响应, 其中包含错误, http状态和异常的详细信息. 对于浏览器, 会响应一个包含相同内容的页面.<br>3.要进行自定义, 添加view解析为error<br>4.要完全替换默认行为，可以实现 ErrorController 并注册该类型的Bean定义，或添加ErrorAttributes类型的组件以使用现有机制但替换其内容。<br>5.error目录下的4xx,5xx页面会自动解析</p>
<h3 id="自动配置-1"><a href="#自动配置-1" class="headerlink" title="自动配置"></a>自动配置</h3><p>部分源码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ErrorMvcAutoConfiguration &#123;</span><br><span class="line"></span><br><span class="line">    private final ServerProperties serverProperties;</span><br><span class="line"></span><br><span class="line">    public ErrorMvcAutoConfiguration(ServerProperties serverProperties) &#123;</span><br><span class="line">        this.serverProperties = serverProperties;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    //这里就可以看出, 可以自定义ErrorAttributes实现替换</span><br><span class="line">    @ConditionalOnMissingBean(value = ErrorAttributes.class, search = SearchStrategy.CURRENT)</span><br><span class="line">    public DefaultErrorAttributes errorAttributes() &#123;</span><br><span class="line">        return new DefaultErrorAttributes();</span><br><span class="line">    &#125;</span><br><span class="line">        //DefaultErrorAttributes源码, 用于设置生成错误信息</span><br><span class="line">        public class DefaultErrorAttributes implements ErrorAttributes, HandlerExceptionResolver, Ordered &#123;</span><br><span class="line">            //用于将错误信息以键值对放入域对象    </span><br><span class="line">            @Override</span><br><span class="line">            public ModelAndView resolveException(HttpServletRequest request, HttpServletResponse response, Object handler,Exception ex) &#123;</span><br><span class="line">            storeErrorAttributes(request, ex);</span><br><span class="line">            return null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //DefaultErrorAttributes源码结束</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    //这里也是, 可以自定义ErrorController替换</span><br><span class="line">    @ConditionalOnMissingBean(value = ErrorController.class, search = SearchStrategy.CURRENT)</span><br><span class="line">    public BasicErrorController basicErrorController(ErrorAttributes errorAttributes,</span><br><span class="line">            ObjectProvider&lt;ErrorViewResolver&gt; errorViewResolvers) &#123;</span><br><span class="line">        return new BasicErrorController(errorAttributes, this.serverProperties.getError(),</span><br><span class="line">                errorViewResolvers.orderedStream().collect(Collectors.toList()));</span><br><span class="line">    &#125;</span><br><span class="line">        //BasicErrorController源码, 用于设置响应html白页和json</span><br><span class="line">        @Controller</span><br><span class="line">        //$&#123;&#125;表示从配置文件中取出数据,:表示如果前面没有就取后面的</span><br><span class="line">        //如果配置了server.error.path就使用它, 如果没有就取error.path, 还没有就使用/error</span><br><span class="line">        @RequestMapping(&quot;$&#123;server.error.path:$&#123;error.path:/error&#125;&#125;&quot;)</span><br><span class="line">        public class BasicErrorController extends AbstractErrorController &#123;</span><br><span class="line">                //这种不指定value的RequestMapping会在找不到对应的controller时调用</span><br><span class="line">                //用于返回html的请求</span><br><span class="line">                @RequestMapping(produces = MediaType.TEXT_HTML_VALUE)</span><br><span class="line">                public ModelAndView errorHtml(HttpServletRequest request, HttpServletResponse response) &#123;...&#125;</span><br><span class="line">                //用于返回错误json</span><br><span class="line">                @RequestMapping</span><br><span class="line">                public ResponseEntity&lt;Map&lt;String, Object&gt;&gt; error(HttpServletRequest request) &#123;...&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //BasicErrorController源码结束</span><br><span class="line"></span><br><span class="line">    @Configuration(proxyBeanMethods = false)</span><br><span class="line">    //server.error.whitelabel.enable为true就配置错误视图页面</span><br><span class="line">    @ConditionalOnProperty(prefix = &quot;server.error.whitelabel&quot;, name = &quot;enabled&quot;, matchIfMissing = true)</span><br><span class="line">    @Conditional(ErrorTemplateMissingCondition.class)</span><br><span class="line">    protected static class WhitelabelErrorViewConfiguration &#123;</span><br><span class="line"></span><br><span class="line">        private final StaticView defaultErrorView = new StaticView();</span><br><span class="line"></span><br><span class="line">        //如果没有自定义的error就创建一个错误页面</span><br><span class="line">        @Bean(name = &quot;error&quot;)</span><br><span class="line">        @ConditionalOnMissingBean(name = &quot;error&quot;)</span><br><span class="line">        public View defaultErrorView() &#123;</span><br><span class="line">            return this.defaultErrorView;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // If the user adds @EnableWebMvc then the bean name view resolver from</span><br><span class="line">        // WebMvcAutoConfiguration disappears, so add it back in to avoid disappointment.</span><br><span class="line">        //如果使用@EnableWebMvc全面接管mvc的配置,视图解析器会失效, 所以添加这个方法避免.</span><br><span class="line">        @Bean</span><br><span class="line">        @ConditionalOnMissingBean</span><br><span class="line">        public BeanNameViewResolver beanNameViewResolver() &#123;</span><br><span class="line">            BeanNameViewResolver resolver = new BeanNameViewResolver();</span><br><span class="line">            resolver.setOrder(Ordered.LOWEST_PRECEDENCE - 10);</span><br><span class="line">            return resolver;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="异常处理步骤流程"><a href="#异常处理步骤流程" class="headerlink" title="异常处理步骤流程"></a>异常处理步骤流程</h3><p>1.所有方法出现异常都会被catch然后dispatchException封装<br>2.调用processDispatchResult方法处理异常</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void processDispatchResult(HttpServletRequest request, HttpServletResponse response,</span><br><span class="line">        @Nullable HandlerExecutionChain mappedHandler, @Nullable ModelAndView mv,</span><br><span class="line">        @Nullable Exception exception) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">    boolean errorView = false;</span><br><span class="line"></span><br><span class="line">    //这里进行异常的接收, 并且重新设置mv, 将跳转的错误页面封装到view, 将错误信息封装到model</span><br><span class="line">    if (exception != null) &#123;</span><br><span class="line">        if (exception instanceof ModelAndViewDefiningException) &#123;</span><br><span class="line">            logger.debug(&quot;ModelAndViewDefiningException encountered&quot;, exception);</span><br><span class="line">            mv = ((ModelAndViewDefiningException) exception).getModelAndView();</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            Object handler = (mappedHandler != null ? mappedHandler.getHandler() : null);</span><br><span class="line">            mv = processHandlerException(request, response, handler, exception);</span><br><span class="line">            errorView = (mv != null);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        //这部分为processHandlerException源码</span><br><span class="line">        @Nullable</span><br><span class="line">        protected ModelAndView processHandlerException(HttpServletRequest request, HttpServletResponse response,@Nullable Object handler, Exception ex) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">            // Success and error responses may use different content types</span><br><span class="line">            request.removeAttribute(HandlerMapping.PRODUCIBLE_MEDIA_TYPES_ATTRIBUTE);</span><br><span class="line"></span><br><span class="line">            // Check registered HandlerExceptionResolvers...</span><br><span class="line">            //遍历HandlerExceptionResolvers进行异常解析</span><br><span class="line">            //这个解析器列表中包含DefaultErrorAttributes以及另外三个解析器.</span><br><span class="line">            //这三个解析器是:1.自己写的处理方法 2. 自己写的异常类 3.mvc自身处理异常类</span><br><span class="line">            ModelAndView exMv = null;</span><br><span class="line">            if (this.handlerExceptionResolvers != null) &#123;</span><br><span class="line">                //逐个调用解析器进行处理, DefaultErrorAttributes会负责将异常信息封装到请求域中</span><br><span class="line">                //其他三个解析器负责解析, 可能可以解析, 也可能解析不了</span><br><span class="line">                for (HandlerExceptionResolver resolver : this.handlerExceptionResolvers) &#123;</span><br><span class="line">                    exMv = resolver.resolveException(request, response, handler, ex);</span><br><span class="line">                    if (exMv != null) &#123;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //如果处理了异常, 就封装返回</span><br><span class="line">            if (exMv != null) &#123;</span><br><span class="line">                if (exMv.isEmpty()) &#123;</span><br><span class="line">                    request.setAttribute(EXCEPTION_ATTRIBUTE, ex);</span><br><span class="line">                    return null;</span><br><span class="line">                &#125;</span><br><span class="line">                // We might still need view name translation for a plain error model...</span><br><span class="line">                if (!exMv.hasView()) &#123;</span><br><span class="line">                    String defaultViewName = getDefaultViewName(request);</span><br><span class="line">                    if (defaultViewName != null) &#123;</span><br><span class="line">                        exMv.setViewName(defaultViewName);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                if (logger.isTraceEnabled()) &#123;</span><br><span class="line">                    logger.trace(&quot;Using resolved error view: &quot; + exMv, ex);</span><br><span class="line">                &#125;</span><br><span class="line">                else if (logger.isDebugEnabled()) &#123;</span><br><span class="line">                    logger.debug(&quot;Using resolved error view: &quot; + exMv);</span><br><span class="line">                &#125;</span><br><span class="line">                WebUtils.exposeErrorRequestAttributes(request, ex, getServletName());</span><br><span class="line">                return exMv;</span><br><span class="line">            &#125;</span><br><span class="line">            //如果没能处理就将异常抛出</span><br><span class="line">            throw ex;</span><br><span class="line">        &#125;</span><br><span class="line">        //processHandlerException源码结束</span><br><span class="line"></span><br><span class="line">    //如果异常被处理mv会不为空, 就执行下面的内容, 否则将异常抛出</span><br><span class="line">    // Did the handler return a view to render?</span><br><span class="line">    if (mv != null &amp;&amp; !mv.wasCleared()) &#123;</span><br><span class="line">        render(mv, request, response);</span><br><span class="line">        if (errorView) &#123;</span><br><span class="line">            WebUtils.clearErrorRequestAttributes(request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        if (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(&quot;No view rendering, null ModelAndView returned.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) &#123;</span><br><span class="line">        // Concurrent handling started during a forward</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (mappedHandler != null) &#123;</span><br><span class="line">        // Exception (if any) is already handled..</span><br><span class="line">        mappedHandler.triggerAfterCompletion(request, response, null);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3.如果没能处理异常会请求转发到”/error”<br>4.BasicErrorController处理<br>    {<br>        1.选择返回html还是json<br>        2.(html), 获取到请求域中的错误信息<br>        3.遍历errorViewResolvers选择错误视图解析器(未配置只有一个默认解析器)<br>        4.(默认解析器)使用异常代码.html与”error/“拼接路径, 调用对应的视图页面<br>    }  </p>
<h3 id="定制化"><a href="#定制化" class="headerlink" title="定制化"></a>定制化</h3><p>1.向error文件中添加对应错误的html文件<br>2.@ControllerAdvice(类)+@ExceptionHandler(方法)处理全局异常, 这么配置后HandlerExceptionResolvers的第一个解析器在进行异常处理的时候就可以调用这个方法.<br>3.@ResponseStatus(类)+自定义异常, HandlerExceptionResolvers的第二个解析器在进行异常处理的时候就可以调用这个方法.<br>4.springMVC底层异常, 由HandlerExceptionResolvers的第二三个解析器处理</p>
<h2 id="web原生组件注入-servlet-filter-listener"><a href="#web原生组件注入-servlet-filter-listener" class="headerlink" title="web原生组件注入(servlet,filter,listener)"></a>web原生组件注入(servlet,filter,listener)</h2><h3 id="使用servletAPI"><a href="#使用servletAPI" class="headerlink" title="使用servletAPI"></a>使用servletAPI</h3><p>1.在主方法类上使用@ServletComponentScan(basePackages = “包名”),指定扫描原生servlet组件的位置<br>2.配置servlet, 这种方式配置的servlet会跳过Spring的拦截器, 这是因为Spring的拦截器走的DispatcherServlet.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@WebServlet(urlPatterns = &quot;处理路径&quot;)</span><br><span class="line">public class Myservlet extends HttpServlet &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;</span><br><span class="line">        super.doGet(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;</span><br><span class="line">        super.doPost(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>3.配置过滤器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@WebFilter(urlPatterns = &quot;拦截路径&quot;)(单*为servlet写法,双**为spring写法)</span><br><span class="line">public class MyFilter implements Filter &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void init(FilterConfig filterConfig) throws ServletException &#123;</span><br><span class="line">        Filter.super.init(filterConfig);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void destroy() &#123;</span><br><span class="line">        Filter.super.destroy();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4.配饰监听器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@WebListener</span><br><span class="line">public class MyListener implements ServletContextListener &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void contextInitialized(ServletContextEvent sce) &#123;</span><br><span class="line">        ServletContextListener.super.contextInitialized(sce);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void contextDestroyed(ServletContextEvent sce) &#123;</span><br><span class="line">        ServletContextListener.super.contextDestroyed(sce);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用RegistrationBean"><a href="#使用RegistrationBean" class="headerlink" title="使用RegistrationBean"></a>使用RegistrationBean</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class MyRegistConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public ServletRegistrationBean myServlet()&#123;</span><br><span class="line">        MyServlet myServlet = new MyServlet();</span><br><span class="line"></span><br><span class="line">        return new ServletRegistrationBean(myServlet,&quot;/my&quot;,&quot;/my02&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public FilterRegistrationBean myFilter()&#123;</span><br><span class="line"></span><br><span class="line">        MyFilter myFilter = new MyFilter();</span><br><span class="line">//        return new FilterRegistrationBean(myFilter,myServlet());</span><br><span class="line">        FilterRegistrationBean filterRegistrationBean = new FilterRegistrationBean(myFilter);</span><br><span class="line">        filterRegistrationBean.setUrlPatterns(Arrays.asList(&quot;/my&quot;,&quot;/css/*&quot;));</span><br><span class="line">        return filterRegistrationBean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public ServletListenerRegistrationBean myListener()&#123;</span><br><span class="line">        MySwervletContextListener mySwervletContextListener = new MySwervletContextListener();</span><br><span class="line">        return new ServletListenerRegistrationBean(mySwervletContextListener);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="定制Servlet容器"><a href="#定制Servlet容器" class="headerlink" title="定制Servlet容器"></a>定制Servlet容器</h2><p>1.修改server.下的配置文件(推荐)<br>2.自定义一个ConfigurableServletWebServerFactory<br>3.使用WebServerFactoryCustomizer接口更改配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class CustomizationBean implements WebServerFactoryCustomizer&lt;ConfigurableServletWebServerFactory&gt; &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void customize(ConfigurableServletWebServerFactory server) &#123;</span><br><span class="line">        server.setPort(9000);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="定制化-1"><a href="#定制化-1" class="headerlink" title="定制化"></a>定制化</h2><p>正常使用是spring会依据不同的场景使用不同的AutoConfiguration进行配置, 导入不同的组件.<br>1.但是这个组件往往都会使用注解绑定配置文件, 这样我们就可以通过修改配置文件控制组件的导入. 2.除此之外还常会添加@ConditionalOnMissingBean注解, 这个注解也使得我们可以编写自定义的配置类进行替换或增加.<br>3.还可以使用WebMvcConfigurer进行web的定制, 使用WebMvcRegistrations进行最底层的定制.<br>4.使用@EnableWebMvc注解全面接管配置, 完全定制化.</p>
<h1 id="数据访问"><a href="#数据访问" class="headerlink" title="数据访问"></a>数据访问</h1><h2 id="整合druid"><a href="#整合druid" class="headerlink" title="整合druid"></a>整合druid</h2><p>建议参考github文档<br>手动配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class MyDataSource &#123;</span><br><span class="line">    //配置数据库连接池    </span><br><span class="line">    //预先在yml写好需要的数据</span><br><span class="line">    @ConfigurationProperties(&quot;spring.datasource&quot;)</span><br><span class="line">    @Bean</span><br><span class="line">    public DataSource dataSource() throws SQLException &#123;</span><br><span class="line">        DruidDataSource dataSource = new DruidDataSource();</span><br><span class="line">        //开启监控统计功能, 开启防火墙,这部分也可以在配置文件中设置</span><br><span class="line">        dataSource.setFilters(&quot;stat,wall&quot;);</span><br><span class="line">        return dataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    //配置内置监控servlet</span><br><span class="line">    public ServletRegistrationBean statViewServlet()&#123;</span><br><span class="line">        StatViewServlet statViewServlet = new StatViewServlet();</span><br><span class="line">        ServletRegistrationBean&lt;StatViewServlet&gt; registrationBean = new ServletRegistrationBean&lt;&gt;(statViewServlet,&quot;/druid/*&quot;);</span><br><span class="line">        registrationBean.addInitParameter(&quot;loginUsername&quot;,&quot;lixin&quot;);</span><br><span class="line">        registrationBean.addInitParameter(&quot;loginPassword&quot;,&quot;lixin123&quot;);</span><br><span class="line">        return registrationBean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    //WebStatFilter用于采集web-jdbc关联监控的数据。</span><br><span class="line">    public FilterRegistrationBean filterRegistrationBean()&#123;</span><br><span class="line">        WebStatFilter webStatFilter = new WebStatFilter();</span><br><span class="line">        FilterRegistrationBean&lt;WebStatFilter&gt; registrationBean = new FilterRegistrationBean&lt;&gt;(webStatFilter);</span><br><span class="line">        registrationBean.setUrlPatterns(Arrays.asList(&quot;/*&quot;));</span><br><span class="line">        registrationBean.addInitParameter(&quot;exclusions&quot;,&quot;*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*&quot;);</span><br><span class="line">        return registrationBean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>快速配置<br>使用starter配置maven<br>使用配置文件spring.datasource.druid前缀进行配置.</p>
<h2 id="整合mybatis"><a href="#整合mybatis" class="headerlink" title="整合mybatis"></a>整合mybatis</h2><p>使用starter配置maven<br>使用配置文件mybatis前缀进行配置,mapper-locations用于设置文件位置, type-aliases-package设置pojo包<br>注意!:config-location与configuration是不能共存的, 否则会报异常.</p>
<h1 id="AOP使用"><a href="#AOP使用" class="headerlink" title="AOP使用"></a>AOP使用</h1><p>导入aop-start依赖<br>示例:<br>这里使用around是为了调用joinPoint.proceed, 只有这样才能将更改的参数传入方法中.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">@Aspect</span><br><span class="line">public class GetId &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    LibraryMapper libraryMapper;</span><br><span class="line"></span><br><span class="line">    //设置全服务层方法切入点</span><br><span class="line">    @Pointcut(&quot;execution(* com.mtid.student.service.*.*(..))&quot;)</span><br><span class="line">    public void servicePoint()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    //设置admin类方法切入点</span><br><span class="line">    @Pointcut(&quot;execution(* com.mtid.student.service.AdminService.*(..))&quot;)</span><br><span class="line">    public void adminServicePoint()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    //设置student类方法切入点</span><br><span class="line">    @Pointcut(&quot;execution(* com.mtid.student.service.StudentService.*(..))&quot;)</span><br><span class="line">    public void studentServicePoint()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    @Around(value = &quot;servicePoint()&amp;&amp;!(studentServicePoint()||adminServicePoint())&quot; )</span><br><span class="line">    public Object getId(ProceedingJoinPoint joinPoint) throws Throwable &#123;</span><br><span class="line">        Signature signature = joinPoint.getSignature();</span><br><span class="line">        MethodSignature methodSignature = (MethodSignature)signature;</span><br><span class="line">        //取得参数名, 寻找chipNumber</span><br><span class="line">        String[] parameterNames = methodSignature.getParameterNames();</span><br><span class="line">        Object[] args = joinPoint.getArgs();</span><br><span class="line">        String chipNumber = new String();</span><br><span class="line">        for (int i = 0;i&lt;args.length;i++)&#123;</span><br><span class="line">            if (parameterNames[i].equals(&quot;chipNumber&quot;))&#123;</span><br><span class="line">                chipNumber = (String) args[i];</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (chipNumber!=null)&#123;</span><br><span class="line">            String id = libraryMapper.getId(chipNumber);</span><br><span class="line">            for (int i = 0;i&lt;args.length;i++)&#123;</span><br><span class="line">                if (parameterNames[i].equals(&quot;id&quot;))&#123;</span><br><span class="line">                    args[i] = id;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return (Object) joinPoint.proceed(args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>切入点表达式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">execution([权限修饰符][返回类型][类的全路径][方法名称]([参数列表]))</span><br><span class="line">//对类中的方法进行增强</span><br><span class="line">execution(* com.company.Dao.BookDao.add(..))</span><br><span class="line">//对类中所有方法进行增强</span><br><span class="line">execution(* com.company.Dao.BookDao.*(..))</span><br><span class="line">//对包中所有方法进行增强</span><br><span class="line">execution(* com.company.Dao.*.*(..))</span><br></pre></td></tr></table></figure>

<p>通知类型</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//前置通知</span><br><span class="line">@Before(value = &quot;切入点表达式&quot;)</span><br><span class="line">//最终通知</span><br><span class="line">@After()</span><br><span class="line">//后置通知</span><br><span class="line">@AfterReturning()</span><br><span class="line">//异常通知</span><br><span class="line">@AfterThrowing()</span><br><span class="line">//环绕通知</span><br><span class="line">@Around()</span><br><span class="line">public void around(ProceedingJoinPoint proceedingJoinPoint) &#123;</span><br><span class="line">    //前增强</span><br><span class="line">    proceedingJoinPoint.proceed();</span><br><span class="line">    //后增强</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="JUnit5"><a href="#JUnit5" class="headerlink" title="JUnit5"></a>JUnit5</h1><table>
<thead>
<tr>
<th>常用注解</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>@Test</td>
<td>表示是测试方法</td>
</tr>
<tr>
<td>@DisplayName</td>
<td>为测试方法或类设置展示名称</td>
</tr>
<tr>
<td>@BeforeEach</td>
<td>每个单元测试前执行</td>
</tr>
<tr>
<td>@AfterEach</td>
<td></td>
</tr>
<tr>
<td>@BeforeAll</td>
<td>需要静态方法</td>
</tr>
<tr>
<td>@AfteAll</td>
<td>需要静态方法</td>
</tr>
<tr>
<td>@Disabled</td>
<td>禁言测试方法</td>
</tr>
<tr>
<td>@Timeout</td>
<td>设置时间限制</td>
</tr>
<tr>
<td>@RepeatedTest</td>
<td>重复测试</td>
</tr>
</tbody></table>
<p>断言失败后面的代码就不会执行,Assertions包</p>
<table>
<thead>
<tr>
<th>断言</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>assertEquals</td>
<td>判断是否相等</td>
</tr>
<tr>
<td>assertNotEquals</td>
<td></td>
</tr>
<tr>
<td>assertSame</td>
<td>是否是同一对象</td>
</tr>
<tr>
<td>assertNotSame</td>
<td></td>
</tr>
<tr>
<td>assertTrue</td>
<td>是否为真</td>
</tr>
<tr>
<td>assertFalse</td>
<td></td>
</tr>
<tr>
<td>assertNull</td>
<td></td>
</tr>
<tr>
<td>assertNotNull</td>
<td></td>
</tr>
<tr>
<td>assertArrayEquals</td>
<td>判断是否数组相等</td>
</tr>
</tbody></table>
<p>参数化测试 使用注解 @ParameterizedTest<br>@ValueSource:为参数化测试指定入参来源, 支持八大类和String以及Class<br>@NullSource: 表示为参数化测试提供一个null的入参<br>@EnumSource: 表示为参数化测试提供一个枚举入参<br>@CsvFileSource：表示读取指定CSV文件内容作为参数化测试入参<br>@MethodSource：表示读取指定方法的返回值作为参数化测试入参(注意方法返回需要是一个流)</p>
<h1 id="指标监控"><a href="#指标监控" class="headerlink" title="指标监控"></a>指标监控</h1><h2 id="引入场景"><a href="#引入场景" class="headerlink" title="引入场景"></a>引入场景</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>访问 <a href="http://localhost:8080/actuator/">http://localhost:8080/actuator/</a>**<br>暴露所有监控信息为HTTP</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">management:</span><br><span class="line">  endpoints:</span><br><span class="line">    enabled-by-default: true #暴露所有端点信息</span><br><span class="line">    web:</span><br><span class="line">      exposure:</span><br><span class="line">        include: &#x27;*&#x27;  #以web方式暴露</span><br></pre></td></tr></table></figure>

<h2 id="常用端点"><a href="#常用端点" class="headerlink" title="常用端点"></a>常用端点</h2><p>最常用的Endpoint<br>● Health：监控状况</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#用于开启详细监控状态</span><br><span class="line">management:</span><br><span class="line">  endpoints:</span><br><span class="line">    health:</span><br><span class="line">        show-details: always</span><br></pre></td></tr></table></figure>
<p>● Metrics：运行时指标<br>提供详细的、层级的、空间指标信息，这些信息可以被pull（主动推送）或者push（被动获取）方式得到；<br>    通过Metrics对接多种监控系统<br>    简化核心Metrics开发<br>    添加自定义Metrics或者扩展已有Metric<br>● Loggers：日志记录</p>
<table>
<thead>
<tr>
<th>ID</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>auditevents</td>
<td>暴露当前应用程序的审核事件信息。需要一个AuditEventRepository组件。</td>
</tr>
<tr>
<td>beans</td>
<td>显示应用程序中所有Spring Bean的完整列表。</td>
</tr>
<tr>
<td>caches</td>
<td>暴露可用的缓存。</td>
</tr>
<tr>
<td>conditions</td>
<td>显示自动配置的所有条件信息，包括匹配或不匹配的原因。</td>
</tr>
<tr>
<td>configprops</td>
<td>显示所有@ConfigurationProperties。</td>
</tr>
<tr>
<td>env</td>
<td>暴露Spring的属性ConfigurableEnvironment</td>
</tr>
<tr>
<td>flyway</td>
<td>显示已应用的所有Flyway数据库迁移。需要一个或多个Flyway组件。</td>
</tr>
<tr>
<td>health</td>
<td>显示应用程序运行状况信息。</td>
</tr>
<tr>
<td>httptrace</td>
<td>显示HTTP跟踪信息（默认情况下，最近100个HTTP请求-响应）。需要一个HttpTraceRepository组件。</td>
</tr>
<tr>
<td>info</td>
<td>显示应用程序信息。</td>
</tr>
<tr>
<td>integrationgraph</td>
<td>显示Spring integrationgraph 。需要依赖spring-integration-core。</td>
</tr>
<tr>
<td>loggers</td>
<td>显示和修改应用程序中日志的配置。</td>
</tr>
<tr>
<td>liquibase</td>
<td>显示已应用的所有Liquibase数据库迁移。需要一个或多个Liquibase组件。</td>
</tr>
<tr>
<td>metrics</td>
<td>显示当前应用程序的“指标”信息。</td>
</tr>
<tr>
<td>mappings</td>
<td>显示所有@RequestMapping路径列表。</td>
</tr>
<tr>
<td>scheduledtasks</td>
<td>显示应用程序中的计划任务。</td>
</tr>
<tr>
<td>sessions</td>
<td>允许从Spring Session支持的会话存储中检索和删除用户会话。需要使用Spring Session的基于Servlet的Web应用程序。</td>
</tr>
<tr>
<td>shutdown</td>
<td>使应用程序正常关闭。默认禁用。</td>
</tr>
<tr>
<td>startup</td>
<td>显示由ApplicationStartup收集的启动步骤数据。需要使用SpringApplication进行配置BufferingApplicationStartup。</td>
</tr>
<tr>
<td>threaddump</td>
<td>执行线程转储。</td>
</tr>
</tbody></table>
<h2 id="定制Endpoint"><a href="#定制Endpoint" class="headerlink" title="定制Endpoint"></a>定制Endpoint</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class MyHealthIndicator implements HealthIndicator &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Health health() &#123;</span><br><span class="line">        int errorCode = check(); // perform some specific health check</span><br><span class="line">        if (errorCode != 0) &#123;</span><br><span class="line">            return Health.down().withDetail(&quot;Error Code&quot;, errorCode).build();</span><br><span class="line">        &#125;</span><br><span class="line">        return Health.up().build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="可视化"><a href="#可视化" class="headerlink" title="可视化"></a>可视化</h2><p>针对微服务进行多服务器的监控, 需要另起端口<br>引入依赖</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;de.codecentric&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-admin-starter-server&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.5.1&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>在主程序使用@EnableAdminServer注解开启</p>
<p>在需要被监控的微服务中引入依赖</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;de.codecentric&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-admin-starter-client&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.5.1&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>配置汇报端口<br>spring.boot.admin.client.url=<a href="http://localhost/">http://localhost</a>:</p>
<h1 id="原理解析"><a href="#原理解析" class="headerlink" title="原理解析"></a>原理解析</h1><h2 id="Profile功能"><a href="#Profile功能" class="headerlink" title="Profile功能"></a>Profile功能</h2><p>在创建配置文件时使用-环境名的形式区分不同环境下使用的配置文件.<br>在默认配置文件中使用spring.profiles.active属性配置要切换的环境名.<br>即使打包为jar包, 也可以在cmd中进行配置启动(命令行可以直接修改配置文件)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java -jar包 --spring.profile.active=环境名</span><br></pre></td></tr></table></figure>

<p>@Profile注解可以针对当前环境名选定启用哪部分方法或者类<br>当一个接口被两个类实现时, 可以使用@Profile(“环境名”)指定接口自动注入时注入到哪个类中.</p>
<p>也可以使用多个环境配置进行互补配置, 会优先使用上面的环境, 没有的话就向下查询</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring.profiles.active=myprod</span><br><span class="line">spring.profiles.group.myprod[0]=环境1</span><br><span class="line">spring.profiles.group.myprod[1]=环境2</span><br></pre></td></tr></table></figure>
<h2 id="外部化配置"><a href="#外部化配置" class="headerlink" title="外部化配置"></a>外部化配置</h2><p>1.外部配置源<br>常用：Java属性文件、YAML文件、环境变量、命令行参数<br>2.配置文件查找位置<br>(1) classpath 根路径<br>(2) classpath 根路径下config目录<br>(3) jar包当前目录<br>(4) jar包当前目录的config目录<br>(5) /config子目录的直接子目录<br>3、配置文件加载顺序：<br>    当前jar包内部的application.properties和application.yml<br>    当前jar包内部的application-{profile}.properties 和 application-{profile}.yml<br>    引用的外部jar包的application.properties和application.yml<br>    引用的外部jar包的application-{profile}.properties 和 application-{profile}.yml<br>4、指定环境优先，外部优先，后面的可以覆盖前面的同名配置项</p>
<h2 id="SpringBoot原理"><a href="#SpringBoot原理" class="headerlink" title="SpringBoot原理"></a>SpringBoot原理</h2>]]></content>
      <categories>
        <category>框架</category>
      </categories>
  </entry>
  <entry>
    <title>Spring</title>
    <url>/2021/12/13/%E6%A1%86%E6%9E%B6/Spring5/</url>
    <content><![CDATA[<h1 id="IOC容器"><a href="#IOC容器" class="headerlink" title="IOC容器"></a>IOC容器</h1><h2 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h2><h3 id="什么是IOC"><a href="#什么是IOC" class="headerlink" title="什么是IOC"></a>什么是IOC</h3><p>IOC是一种思想, 传统应用程序都是由我们在类内部主动创建依赖对象, 从而导致类与类之间高耦合, 难于测试. 有了IOC容器后, 把创建和查找依赖对象的控制权交给了容器(转交这个控制权就是控制反转), 由容器进行注入组合对象, 所以对象与对象之间是松散耦合, 这样也方便测试, 利于功能复用, 更重要的是使得程序的整个体系结构变得非常灵活.</p>
<h3 id="IOC与DI"><a href="#IOC与DI" class="headerlink" title="IOC与DI"></a>IOC与DI</h3><p>IOC是指将创建对象的权限交由容器的思想. 实现这种思想有两种方法DL与DI, DL是当需要对象时找到这个对象, DI是当需要的时候, 直接把对象注入.</p>
<span id="more"></span>
<h2 id="BeanFactory接口"><a href="#BeanFactory接口" class="headerlink" title="BeanFactory接口"></a>BeanFactory接口</h2><p>spring提供的两个工厂接口:<br>BeanFactory:是spring内部使用的接口,一般不使用.(加载配置文件的时候不会创建,获取时才创建)<br>ApplicationContext:BeanFactory的子类,对其进行的功能的增强.(加载配置文件时直接创建)<br>    两个实现类:<br>    FileSystemXmlApplicationContext:盘路径<br>    ClassPathXmlApplicationContext:项目路径</p>
<h2 id="Bean管理"><a href="#Bean管理" class="headerlink" title="Bean管理"></a>Bean管理</h2><h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><p>Bean分为普通Bean和FactoryBean.<br>普通Bean:返回的就是定义的类型<br>FactoryBean(让类实现FactoryBean,getObject方法中写入要返回的类型):返回的不一定是定义的类型</p>
<h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>可以设置Bean是否为单例模式(默认单例)<br>scope属性更改: singleton(单例),prototype(多例),request(一次请求一个),session.<br>singleton是懒汉式的,它在加载配置文件时就生成了对象, prototype不是, 也没法是.</p>
<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>1.构造器创建<br>2.设置属性<br>3.调用Bean的初始化方法(在bean标签的init-method属性中设置初始化要调用的方法)<br>4.Bean对象可用<br>5.当容器关闭的调用Bean的销毁方法(destroy-method属性设置销毁时要调用的方法) </p>
<h3 id="基于xml注入"><a href="#基于xml注入" class="headerlink" title="基于xml注入"></a>基于xml注入</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;bean id=&quot;&quot; class=&quot;&quot;&gt;</span><br><span class="line">&lt;!-- set方法注入 --&gt;</span><br><span class="line">	&lt;property name=&quot;属性名&quot; value= &gt;&lt;/property&gt;</span><br><span class="line">&lt;!-- 构造器注入  --&gt;</span><br><span class="line">	&lt;constructor-arg name=&quot;属性名或index&quot; value= &gt;&lt;/constructor-arg&gt;</span><br><span class="line">&lt;!-- 注入对象 --&gt;</span><br><span class="line">	&lt;property name=&quot;属性名&quot; ref=&quot;id&quot; &gt;&lt;/property&gt;</span><br><span class="line">&lt;!-- 注入对象 --&gt;</span><br><span class="line">	&lt;property name=&quot;属性名&quot;&gt;</span><br><span class="line">		&lt;bean&gt;&lt;/bean&gt;</span><br><span class="line">	&lt;/property&gt;	</span><br><span class="line">&lt;!-- 修改注入对象的属性(这是通过get方法取到数据再调用set实现的) --&gt;</span><br><span class="line">	&lt;property name=&quot;对象名.属性&quot; value= &gt;&lt;/property&gt;</span><br><span class="line">&lt;!-- 注入数组,list,set --&gt;</span><br><span class="line">	&lt;property name=&quot;属性名&quot;&gt;</span><br><span class="line">		&lt;array(list,set)&gt;</span><br><span class="line">			&lt;value&gt;值&lt;/value&gt;</span><br><span class="line">			&lt;value&gt;值&lt;/value&gt;</span><br><span class="line">	&lt;!-- 注入对象 --&gt;</span><br><span class="line">			&lt;ref bean=&quot;id&quot;&gt;&lt;/ref&gt;		</span><br><span class="line">		&lt;/array(list,set)&gt;</span><br><span class="line">	&lt;/property&gt;</span><br><span class="line">&lt;!-- 注入map	 --&gt;</span><br><span class="line">	&lt;property name=&quot;属性名&quot;&gt;</span><br><span class="line">		&lt;map&gt;</span><br><span class="line">			&lt;entry key=&quot;&quot; value=&quot;&quot;&gt;&lt;/entry&gt;</span><br><span class="line">		&lt;/map&gt;</span><br><span class="line">	&lt;/property&gt;		</span><br><span class="line">&lt;!-- 注入null --&gt;</span><br><span class="line">	&lt;property name=&quot;&quot;&gt;</span><br><span class="line">		&lt;null/&gt;</span><br><span class="line">	&lt;/property&gt;</span><br><span class="line">&lt;!-- 注入特殊符号(可以使用xml的转义字符) --&gt;</span><br><span class="line">	&lt;property name=&quot;&quot;&gt;</span><br><span class="line">		&lt;value&gt;&lt;![CDATA[内容]]&gt;&lt;/value&gt;</span><br><span class="line">	&lt;/property&gt;	</span><br><span class="line">&lt;/bean&gt; </span><br></pre></td></tr></table></figure>
<p>提取公共部分:<br>1.配置文件引入名称空间util<br>2.设置标签</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;util:list id=&quot;bookList&quot;&gt;</span><br><span class="line">	&lt;value&gt;&lt;/value&gt;</span><br><span class="line">&lt;/util:list&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=&quot;&quot; class=&quot;&quot;&gt;</span><br><span class="line">	&lt;property name=&quot;&quot; ref=&quot;bookList&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<p>调用:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ApplicationContext context = new ClassPathXmlApplicationContext(xml文件路径);</span><br><span class="line">User user = context.getBean(&quot;id&quot;,类名);</span><br></pre></td></tr></table></figure>
<h3 id="xml自动装配"><a href="#xml自动装配" class="headerlink" title="xml自动装配"></a>xml自动装配</h3><p>autowrite属性: byName(根据名称自动装配),byType(根据类型自动装配)<br>byName: 需要属性名与被注入的对象id相同.<br>    底层:使用默认构造器构建结束后,逐个调用set方法,在配置文件中搜寻id相同的bean对象进行创建再,调用set.<br>byType: 被自动注入的bean对象只允许在配置文件配置此类的一个<br>    底层:使用默认构造器构建结束后,逐个调用set方法,在配置文件中搜寻class与需求类型一直的对象进行创建.</p>
<h3 id="引入外部文件"><a href="#引入外部文件" class="headerlink" title="引入外部文件"></a>引入外部文件</h3><p>配置文件引入名称空间context</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;context:property-placeholder location=&quot;classpath:&quot;/&gt;</span><br><span class="line">&lt;bean id=&quot;&quot; class=&quot;&quot;&gt;</span><br><span class="line">	&lt;property name=&quot;&quot; vlaue=&quot;$&#123;properties文件中的属性名&#125;&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<h3 id="基于注解注入"><a href="#基于注解注入" class="headerlink" title="基于注解注入"></a>基于注解注入</h3><p>使用注解简化xml配置<br>1.引入aop jar包<br>2.xml文件中开启组件扫描</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 引入名称空间context --&gt;</span><br><span class="line">&lt;context:component-scan base-packge=&quot;扫描包名,逗号分隔&quot; use-default-filters=&quot;false&quot;&gt;</span><br><span class="line">	&lt;!-- 只扫描注解类型为Controller的文件 --&gt;</span><br><span class="line">	&lt;context:include-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&gt;</span><br><span class="line">	&lt;!-- 黑名单在默认过滤器也可以使用 --&gt;</span><br><span class="line">	&lt;context:exclude-filter .../&gt;</span><br><span class="line">&lt;/context:component-sacn&gt;</span><br></pre></td></tr></table></figure>
<p>3.在类上面添加注解<br>默认id为首字母小写.</p>
<h4 id="对象注解"><a href="#对象注解" class="headerlink" title="对象注解:"></a>对象注解:</h4><p>注解于类上方<br>@Component(通用注解)<br>@Service(服务层注解)<br>@Controller(web层注解)<br>@Repository(持久层注解)    </p>
<h4 id="属性注入"><a href="#属性注入" class="headerlink" title="属性注入:"></a>属性注入:</h4><p>注解于属性上方<br>@Autowired:根据属性类型自动装配<br>@Qualifier(value = “id”):根据属性名称自动装配(需要与Autowired一起使用)<br>@Resource(name=”id”):可以根据类型注入,也可以根据名称注入(不写name为类型注入,写name属性为名称注入)<br>@Value:注入普通类型属性(vale = ):<br>基于注解的属性注入是不需要set和get方法的,即使他是私有的,在反射时spring也会自动调用setaccessible函数取消私有权限. </p>
<h4 id="完全注解开发"><a href="#完全注解开发" class="headerlink" title="完全注解开发"></a>完全注解开发</h4><p>使用Configuration注解把class文件作为配置类,代替xml<br>使用CompontScan(basePackage= {“”})配置扫描<br>在类中使用@Bean注解配置组件:会返回以方法名注册的组件交给容器<br>将ClassPathXmlApplicationContext取得配置文件的方式改为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ApplicationContext context = new AnnotationConfigApplicationContext(配置类对象);</span><br></pre></td></tr></table></figure>
<h1 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h1><p>AOP即面向切面编程,利用AOP可以对业务逻辑的各个部分进行隔离,降低耦合度.<br>OOP使代码被划分到了一个个类中, 降低了代码的复杂度, 使类可复用, 但这样划分会使得代码重复度增高.  因此产生了AOP, 它是一种在运行时, 动态的将代码切入到指定类的指定方法的指定位置上的一种编程思想.<br>这种编程思想也很好的符合了开闭原则.</p>
<h2 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h2><p>1.有接口的时候使用JDK动态代理<br>2.没有接口的时候使用CGLIB动态代理</p>
<h3 id="jdk动态代理"><a href="#jdk动态代理" class="headerlink" title="jdk动态代理"></a>jdk动态代理</h3><p>java.lang.reflect<br>Proxy类:newProxyInstance(类加载器,接口类,InvocationHandler)方法可以利用反射直接生成代理对象<br>Method类:略<br>InvocationHandler接口:实现此接口的invoke方法用于完成代理类要的功能.<br>    代理类要的功能:调用目标方法, 执行目标方法的功能. 功能的增强.<br>1.创建接口,创建被代理类<br>2.创建实现了InvocationHandler接口的实现类,</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MySellHandler implements InvocationHandler&#123;</span><br><span class="line">	//这里保存被代理的对象</span><br><span class="line">	private Object target = null;</span><br><span class="line">	//动态代理目标是活动的,不是固定的,需要注入</span><br><span class="line">	//传入是谁,就给谁动态代理</span><br><span class="line">	public MySellHandler(Object target)&#123;</span><br><span class="line">		this.target = target;</span><br><span class="line">	&#125;</span><br><span class="line">	//这里的method是依据proxy调用的方法来的,prxy.method()这样.也就是是说这部分的额外代码是通用的.</span><br><span class="line">	//如果要针对特定的方法进行增强,可以使用method.getName来过滤</span><br><span class="line">	@Override</span><br><span class="line">	public Object invoke(Object proxy,Method method,Object[] args) throw Throwable &#123;</span><br><span class="line">		//这里写各种附加的操作</span><br><span class="line">		//实现对被代理对象方法的调用</span><br><span class="line">		Object res = method.invoke(target,args);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3.创建代理对象,并用接口接收创建的对象</p>
<h3 id="CGLIB动态代理"><a href="#CGLIB动态代理" class="headerlink" title="CGLIB动态代理"></a>CGLIB动态代理</h3><p>原理与JDK类似, 但因为没有接口, 要取得方法只能通过继承实现, 即对目标的子类进行代理.</p>
<h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><p>1.连接点<br>类中可以被增强的方法.<br>2.切入点<br>实际真正增强的方法.<br>3.通知(增强)<br>实际被增强的部分.<br>分为:前置通知, 后置通知, 环绕通知, 异常通知, 最终通知(finally).<br>4.切面<br>把通知应用到切入点的过程.</p>
<h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><p>1.一般基于AspectJ实现AOP操作. 它并不是Spring组成部分, 一般与Spring组合使用.<br>2.切入点表达式<br>指定对哪个类的哪个方法进制增强</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">execution([权限修饰符][返回类型][类的全路径][方法名称]([参数列表]))</span><br><span class="line">//对类中的方法进行增强</span><br><span class="line">execution(* com.company.Dao.BookDao.add(..))</span><br><span class="line">//对类中所有方法进行增强</span><br><span class="line">execution(* com.company.Dao.BookDao.*(..))</span><br><span class="line">//对包中所有方法进行增强</span><br><span class="line">execution(* com.company.Dao.*.*(..))</span><br></pre></td></tr></table></figure>
<h3 id="基于注解"><a href="#基于注解" class="headerlink" title="基于注解"></a>基于注解</h3><p>1.创建一个类, 定义方法<br>2.创建增强类, 编写增强方法,<br>3.配置文件中配置context名称空间, 配置aop名称空间, 开启注解扫描<br>4.对要操作的类进行对象注解, 再在增强类上使用@Aspect注解表示要生成代理对象</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">@Aspect</span><br><span class="line">public class AOPPlus &#123;</span><br><span class="line"></span><br><span class="line">    public void plus()&#123;</span><br><span class="line">        System.out.println(&quot;在这里进行了增强&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>5.开启Aspect生成代理对象</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt;</span><br></pre></td></tr></table></figure>
<p>6.配置通知类型<br>在增强类上使用配置通知类型注解, 使用切入点表达式配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//前置通知</span><br><span class="line">@Before(value = &quot;切入点表达式&quot;)</span><br><span class="line">//最终通知</span><br><span class="line">@After()</span><br><span class="line">//后置通知</span><br><span class="line">@AfterReturning()</span><br><span class="line">//异常通知</span><br><span class="line">@AfterThrowing()</span><br><span class="line">//环绕通知</span><br><span class="line">@Around()</span><br><span class="line">public void around(ProceedingJoinPoint proceedingJoinPoint) &#123;</span><br><span class="line">	//前增强</span><br><span class="line">	proceedingJoinPoint.proceed();</span><br><span class="line">	//后增强</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">@Aspect</span><br><span class="line">public class AOPPlus &#123;</span><br><span class="line">    //对HelloWord所有方法进行增强</span><br><span class="line">    @Before(&quot;execution(* pojo.HelloWord.*(..))&quot;)</span><br><span class="line">    public void plus()&#123;</span><br><span class="line">        System.out.println(&quot;在这里进行了增强&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>7.相同切入点抽取</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Pointcut(value = &quot;切入点表达式&quot;)</span><br><span class="line">public void pointDemo&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>8.设置增强类的优先级<br>使用@Order(num)注解来设置优先级<br>9.配置完成后使用context.getBean取到的就是代理对象<br>10.完全注解开发</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ComponentScan(basePackages = &#123;&quot;扫描包&quot;&#125;)</span><br><span class="line">//开启自动代理</span><br><span class="line">@EnableAspectJAutoProxy(proxyTargetClass = true)</span><br><span class="line">public class ConfigAop &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="基于xml配置文件-一般不用"><a href="#基于xml配置文件-一般不用" class="headerlink" title="基于xml配置文件(一般不用)"></a>基于xml配置文件(一般不用)</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;bean id=&quot;book&quot; class=&quot;&quot;&gt;&lt;/bean&gt;</span><br><span class="line">&lt;bean id=&quot;bookProxy&quot; class=&quot;&quot;&gt;&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--配置aop增强--&gt;</span><br><span class="line">&lt;aop:config&gt;</span><br><span class="line">    &lt;!--切入点--&gt;</span><br><span class="line">    &lt;aop:pointcut id=&quot;p&quot; expression=&quot;execution()&quot;/&gt;</span><br><span class="line">    &lt;!--配置切面--&gt;</span><br><span class="line">    &lt;aop:aspect ref=&quot;bookProxy&quot;&gt;</span><br><span class="line">        &lt;!--增强作用在具体的方法上--&gt;</span><br><span class="line">        &lt;aop:before method=&quot;before&quot; pointcut-ref=&quot;p&quot;/&gt;</span><br><span class="line">    &lt;/aop:aspect&gt;</span><br><span class="line">&lt;/aop:config&gt;</span><br></pre></td></tr></table></figure>
<h1 id="JDBCTemplate"><a href="#JDBCTemplate" class="headerlink" title="JDBCTemplate"></a>JDBCTemplate</h1><p>作用与BasicDao相当</p>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>配置数据库连接池, 配置JDBCTemplate</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span><br><span class="line">      destroy-method=&quot;close&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;url&quot; value=&quot;&quot; /&gt;</span><br><span class="line">    &lt;property name=&quot;username&quot; value=&quot;&quot; /&gt;</span><br><span class="line">    &lt;property name=&quot;password&quot; value=&quot;&quot; /&gt;</span><br><span class="line">    &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot; /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;</span><br><span class="line">    &lt;!--注入dataSource--&gt;</span><br><span class="line">    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;    </span><br></pre></td></tr></table></figure>
<h2 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h2><p>因为jdbcTemplate相当于BasicDao, 所以在Dao类执行操作时要持有它, 所以要在Dao类中注入jdbcTemplate对象. 同理, service类主要负责调用不同的Dao类方法实现服务, 所以也要在service类中注入需要的Dao类.</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>update(sql,arges)</td>
<td>dml语句</td>
</tr>
<tr>
<td>queryForObject(sql,clazz)</td>
<td>查询返回某个值</td>
</tr>
<tr>
<td>queryForObject(sql,new BeanPropertyRowMapper&lt;Book&gt;(Book.class),args)</td>
<td>查询返回对象</td>
</tr>
<tr>
<td>query(sql,new BeanPropertyRowMapper&lt;Book&gt;(Book.class),args)</td>
<td>查询返回集合</td>
</tr>
<tr>
<td>batchUpdate(sql,batchArgs)</td>
<td>批操作</td>
</tr>
</tbody></table>
<h1 id="事务操作-声明式"><a href="#事务操作-声明式" class="headerlink" title="事务操作(声明式)"></a>事务操作(声明式)</h1><p>这里的技术应该是基于AOP的Filter过滤器实现的,为添加注解的方法外套一层事务操作.</p>
<h2 id="基于注解-1"><a href="#基于注解-1" class="headerlink" title="基于注解"></a>基于注解</h2><p>1.在配置文件配置事务管理器</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--创建事务管理器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--注入数据源(前面配置的数据库连接池)--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>2.引入tx名称空间<br>3.开启事务注解</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;&gt;&lt;/tx:annotation-driven&gt;</span><br></pre></td></tr></table></figure>
<p>4.service类(方法)上添加@Transactional注解</p>
<h3 id="Transactional属性详解"><a href="#Transactional属性详解" class="headerlink" title="Transactional属性详解"></a>Transactional属性详解</h3><table>
<thead>
<tr>
<th>属性</th>
<th>作用</th>
<th>可填值</th>
</tr>
</thead>
<tbody><tr>
<td>propagation</td>
<td>事务传播行为</td>
<td>七个事务传播行为</td>
</tr>
<tr>
<td>isolation</td>
<td>隔离级别</td>
<td>四个隔离级别</td>
</tr>
<tr>
<td>timeout</td>
<td>超时时间</td>
<td>默认-1,单位为秒</td>
</tr>
<tr>
<td>readOnly</td>
<td>是否只读</td>
<td>默认false</td>
</tr>
<tr>
<td>rollbackFor</td>
<td>出现哪些异常就回滚</td>
<td>异常类</td>
</tr>
<tr>
<td>norollbackFor</td>
<td>出现哪些异常不回滚</td>
<td>异常类</td>
</tr>
</tbody></table>
<h2 id="基于xml"><a href="#基于xml" class="headerlink" title="基于xml"></a>基于xml</h2><p>1.配置事务管理器<br>2.配置通知</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;tx:advice id=&quot;txadvice&quot;&gt;</span><br><span class="line">    &lt;!--配置事务参数--&gt;</span><br><span class="line">    &lt;tx:attributes&gt;</span><br><span class="line">        &lt;!--指定哪种规则的方法上面添加事务--&gt;</span><br><span class="line">        &lt;tx:method name=&quot;accountMoney&quot; propagation=&quot;REQUIRED&quot;/&gt;</span><br><span class="line">        &lt;!--&lt;tx:method name=&quot;account*&quot;/&gt;--&gt;</span><br><span class="line">    &lt;/tx:attributes&gt;</span><br><span class="line">&lt;/tx:advice&gt;</span><br></pre></td></tr></table></figure>
<p>3.配置切入点和切面</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;aop:config&gt;</span><br><span class="line">    &lt;!--配置切入点--&gt;</span><br><span class="line">    &lt;aop:pointcut id=&quot;pt&quot; expression=&quot;execution(* com.atguigu.spring5.service.UserService.*(..))&quot;/&gt;</span><br><span class="line">    &lt;!--配置切面--&gt;</span><br><span class="line">    &lt;aop:advisor advice-ref=&quot;txadvice&quot; pointcut-ref=&quot;pt&quot;/&gt;</span><br><span class="line">&lt;/aop:config&gt;</span><br></pre></td></tr></table></figure>
<h2 id="完全注解"><a href="#完全注解" class="headerlink" title="完全注解"></a>完全注解</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration //配置类</span><br><span class="line">@ComponentScan(basePackages = &quot;com.atguigu&quot;) //组件扫描</span><br><span class="line">@EnableTransactionManagement //开启事务</span><br><span class="line">public class TxConfig &#123;</span><br><span class="line"></span><br><span class="line">    //创建数据库连接池</span><br><span class="line">    @Bean</span><br><span class="line">    public DruidDataSource getDruidDataSource() &#123;</span><br><span class="line">        DruidDataSource dataSource = new DruidDataSource();</span><br><span class="line">        dataSource.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line">        dataSource.setUrl(&quot;jdbc:mysql:///user_db&quot;);</span><br><span class="line">        dataSource.setUsername(&quot;root&quot;);</span><br><span class="line">        dataSource.setPassword(&quot;root&quot;);</span><br><span class="line">        return dataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //创建JdbcTemplate对象</span><br><span class="line">    @Bean</span><br><span class="line">    public JdbcTemplate getJdbcTemplate(DataSource dataSource) &#123;</span><br><span class="line">        //到ioc容器中根据类型找到dataSource</span><br><span class="line">        JdbcTemplate jdbcTemplate = new JdbcTemplate();</span><br><span class="line">        //注入dataSource</span><br><span class="line">        jdbcTemplate.setDataSource(dataSource);</span><br><span class="line">        return jdbcTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="整合log4j日志框架"><a href="#整合log4j日志框架" class="headerlink" title="整合log4j日志框架"></a>整合log4j日志框架</h1><p>1.导入jar包<br>2.创建log4j.xml文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!--日志级别以及优先级排序: OFF &gt; FATAL &gt; ERROR &gt; WARN &gt; INFO &gt; DEBUG &gt; TRACE &gt; ALL --&gt;</span><br><span class="line">&lt;!--Configuration后面的status用于设置log4j2自身内部的信息输出，可以不设置，当设置成trace时，可以看到log4j2内部各种详细输出--&gt;</span><br><span class="line">&lt;configuration status=&quot;INFO&quot;&gt;</span><br><span class="line">    &lt;!--先定义所有的appender--&gt;</span><br><span class="line">    &lt;appenders&gt;</span><br><span class="line">        &lt;!--输出日志信息到控制台--&gt;</span><br><span class="line">        &lt;console name=&quot;Console&quot; target=&quot;SYSTEM_OUT&quot;&gt;</span><br><span class="line">            &lt;!--控制日志输出的格式--&gt;</span><br><span class="line">            &lt;PatternLayout pattern=&quot;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%t] %-5level %logger&#123;36&#125; - %msg%n&quot;/&gt;</span><br><span class="line">    &lt;/console&gt;</span><br><span class="line">    &lt;/appenders&gt;</span><br><span class="line">    &lt;!--然后定义logger，只有定义了logger并引入的appender，appender才会生效--&gt;</span><br><span class="line">    &lt;!--root：用于指定项目的根日志，如果没有单独指定Logger，则会使用root作为默认的日志输出--&gt;</span><br><span class="line">    &lt;loggers&gt;</span><br><span class="line">        &lt;root level=&quot;info&quot;&gt;</span><br><span class="line">            &lt;appender-ref ref=&quot;Console&quot;/&gt;</span><br><span class="line">        &lt;/root&gt;</span><br><span class="line">    &lt;/loggers&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>
<h1 id="Nullable注解"><a href="#Nullable注解" class="headerlink" title="@Nullable注解"></a>@Nullable注解</h1><p>可以使用到方法,属性,参数上面,用于应对空指针异常问题.</p>
<h1 id="整合JUnit5"><a href="#整合JUnit5" class="headerlink" title="整合JUnit5"></a>整合JUnit5</h1><p>1.引入jar包<br>2.创建测试类,使用注解完成</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//@ExtendWith(SpringExtension.class)</span><br><span class="line">//@ContextConfiguration(&quot;classpath:bean1.xml&quot;)</span><br><span class="line"></span><br><span class="line">@SpringJUnitConfig(locations = &quot;classpath:bean1.xml&quot;)</span><br><span class="line">public class JTest5 &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    //注入测试类</span><br><span class="line">    private UserService userService;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void test1() &#123;</span><br><span class="line">        userService.accountMoney();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>
<h1 id="WebFlux"><a href="#WebFlux" class="headerlink" title="WebFlux"></a>WebFlux</h1><h2 id="基本知识-1"><a href="#基本知识-1" class="headerlink" title="基本知识"></a>基本知识</h2><p>与MVC类似, 但是是响应式编程.基于Reactor的相关API实现的.<br>Spring WebFlux在应对高并发的请求时，借助于异步IO，能够以少量而稳定的线程处理更高吞吐量的请求.<br>当连接池不足以满足用户需求时考虑使用.</p>
<p>同步与异步:<br>同步是指在发出调用时没有得到结果前是不返回的, 调用者在主动等待调用结果.<br>异步是指发出调用后这个调用就直接返回, 没有返回结果, 直到被调用者通知或者使用回调函数才处理结果.<br>阻塞与非阻塞:<br>请求不能立即得到应答，需要等待，那就是阻塞；否则可以理解为非阻塞。<br>例子:去买彩票, 店家说买好了我电话通知你走吧, 这是异步, 而当场告诉你买好了就是同步.<br>而店家实际执行买彩票这个操作有两种手段, 收到要求后就直接给你说买好了, 然后店家去买彩票, 这是非阻塞, 而如果店家是先买好才通知买好了, 这就是阻塞.</p>
<p>响应式编程:<br>必须得继承Observable, 这是java8的实现方法, 实际情况是webFlex是基于java9及后续的操作.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ObserverDemo extends Observable &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ObserverDemo observer = new ObserverDemo();</span><br><span class="line">        //为目标添加观察者</span><br><span class="line">        observer.addObserver(((o, arg) -&gt; System.out.println(&quot;发生变化&quot;)));</span><br><span class="line">        observer.addObserver(((o, arg) -&gt; System.out.println(&quot;手动被观察者通知, 准备改变&quot;)));</span><br><span class="line">        //通知观察者目标已经改变</span><br><span class="line">        observer.setChanged();</span><br><span class="line">        observer.notifyObservers();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Reactor实现响应式编程"><a href="#Reactor实现响应式编程" class="headerlink" title="Reactor实现响应式编程"></a>Reactor实现响应式编程</h2><p>Reactor有两个核心类, Mono和Flux, 这两个类都实现了Publisher接口, Flux对象返回N个元素, Mono返回0或1个元素.</p>
]]></content>
      <categories>
        <category>框架</category>
      </categories>
  </entry>
  <entry>
    <title>SpringMVC</title>
    <url>/2021/12/20/%E6%A1%86%E6%9E%B6/SpringMVC/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>MVC是一种软件架构思想, 将软件按模型(Bean和Service以及Dao), 视图(jsp,html), 控制器(servlet)分开.<br>SpringMVC基于原生servlet进行了封装, 功能更强大.</p>
<span id="more"></span>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="配置web-xml"><a href="#配置web-xml" class="headerlink" title="配置web.xml"></a>配置web.xml</h2><h3 id="默认配置"><a href="#默认配置" class="headerlink" title="默认配置"></a>默认配置</h3><p>此配置作用下, SpringMVC的配置文件默认位于WEB-INF下,默认名称为name-servlet.xml.<br>这样配置其实并不好, 因为使用maven后要求配置文件统一存在resources文件夹下.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  &lt;servlet&gt;</span><br><span class="line">    &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt;</span><br><span class="line">    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;</span><br><span class="line">  &lt;/servlet&gt;</span><br><span class="line">  &lt;servlet-mapping&gt;</span><br><span class="line">    &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt;</span><br><span class="line">&lt;!--    /表示浏览器除了jsp的所有请求(因为jsp本身就是servlet)--&gt;</span><br><span class="line">    &lt;url-pattern&gt;/&lt;/url-pattern&gt; </span><br><span class="line">  &lt;/servlet-mapping&gt;</span><br></pre></td></tr></table></figure>
<h3 id="扩展配置-推荐"><a href="#扩展配置-推荐" class="headerlink" title="扩展配置(推荐)"></a>扩展配置(推荐)</h3><p>在servlet中使用init-param规定配置文件路径,同时使用load-on-satratup标签使前端控制器在服务器启动时初始化.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  &lt;servlet&gt;</span><br><span class="line">    &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt;</span><br><span class="line">    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;</span><br><span class="line">    &lt;init-param&gt;</span><br><span class="line">      &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;</span><br><span class="line">      &lt;!-- 因为项目被编译时所有resources下所有配置文件都会放在classpath下 --&gt;</span><br><span class="line">      &lt;param-value&gt;classpath:spring-mvc.xml&lt;/param-value&gt;</span><br><span class="line">    &lt;/init-param&gt;</span><br><span class="line">    &lt;!-- 使前端控制器在服务器启动时初始化. --&gt;</span><br><span class="line">    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;</span><br><span class="line">  &lt;/servlet&gt;</span><br><span class="line">  &lt;servlet-mapping&gt;</span><br><span class="line">    &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt;</span><br><span class="line">&lt;!--    /表示浏览器除了jsp的所有请求(因为jsp本身就是servlet)--&gt;</span><br><span class="line">    &lt;url-pattern&gt;/&lt;/url-pattern&gt; </span><br><span class="line">  &lt;/servlet-mapping&gt;</span><br></pre></td></tr></table></figure>
<h2 id="创建控制器"><a href="#创建控制器" class="headerlink" title="创建控制器"></a>创建控制器</h2><p>spring配置文件中打开扫描器, 配置thymeleaf视图解析器.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--扫描控制层组件--&gt;</span><br><span class="line">&lt;context:component-scan base-package=&quot;controller&quot;&gt;&lt;/context:component-scan&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 配置Thymeleaf视图解析器 --&gt;</span><br><span class="line">&lt;bean id=&quot;viewResolver&quot; class=&quot;org.thymeleaf.spring5.view.ThymeleafViewResolver&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;order&quot; value=&quot;1&quot;/&gt;</span><br><span class="line">    &lt;property name=&quot;characterEncoding&quot; value=&quot;UTF-8&quot;/&gt;</span><br><span class="line">    &lt;property name=&quot;templateEngine&quot;&gt;</span><br><span class="line">        &lt;bean class=&quot;org.thymeleaf.spring5.SpringTemplateEngine&quot;&gt;</span><br><span class="line">            &lt;property name=&quot;templateResolver&quot;&gt;</span><br><span class="line">                &lt;bean class=&quot;org.thymeleaf.spring5.templateresolver.SpringResourceTemplateResolver&quot;&gt;</span><br><span class="line">                    &lt;!-- 视图前缀 --&gt;</span><br><span class="line">                    &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/templates/&quot;/&gt;</span><br><span class="line">                    &lt;!-- 视图后缀 --&gt;</span><br><span class="line">                    &lt;property name=&quot;suffix&quot; value=&quot;.html&quot;/&gt;</span><br><span class="line">                    &lt;property name=&quot;templateMode&quot; value=&quot;HTML5&quot;/&gt;</span><br><span class="line">                    &lt;property name=&quot;characterEncoding&quot; value=&quot;UTF-8&quot; /&gt;</span><br><span class="line">                &lt;/bean&gt;</span><br><span class="line">            &lt;/property&gt;</span><br><span class="line">        &lt;/bean&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<p>使用@Controller对象注解对要使用前端控制器的方法进行注解.<br>使用@RequestMapping注解将请求与方法进行绑定,value设定绑定的请求.当发送指定的请求时, 会在controller中检索绑定的方法, 再由Thymeleaf视图解析器解析返回的字符串,转发对应路径资源.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Controller</span><br><span class="line">public class HelloController &#123;</span><br><span class="line">    @RequestMapping(value = &quot;/&quot;)</span><br><span class="line">    public String index()&#123;</span><br><span class="line">        return &quot;index&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    @RequestMapping(&quot;/target&quot;)</span><br><span class="line">    public String target()&#123;</span><br><span class="line">        return &quot;target&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="RequestMapping"><a href="#RequestMapping" class="headerlink" title="RequestMapping"></a>RequestMapping</h1><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><p>将请求与方法进行绑定,value设定绑定的请求.当发送指定的请求时, 会在controller中检索绑定的方法, 再由Thymeleaf视图解析器解析返回的字符串,转发对应路径资源.<br>value是可以使用正则表达式的.</p>
<h2 id="位置"><a href="#位置" class="headerlink" title="位置"></a>位置</h2><p>标识类:设置映射请求的请求路径的初始信息.<br>标识方法:设置映射请求的具体路径信息.<br>当标识位置在类上时, 发送请求需要附加类的请求路径, 否则无法访问对应类中的方法.<br>这样处理后, 就可以在方法上为RequestMapping设置相同的value了.</p>
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><table>
<thead>
<tr>
<th>属性</th>
<th>作用</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>value</td>
<td>通过请求地址匹配请求</td>
<td>请求地址</td>
</tr>
<tr>
<td>method</td>
<td>通过请求方法匹配请求</td>
<td>使用RequestMethod调用</td>
</tr>
<tr>
<td>params</td>
<td>通过请求参数匹配请求</td>
<td>可以填入param,!param,param=value,param!=value</td>
</tr>
<tr>
<td>headers</td>
<td>通过请求头匹配请求</td>
<td>与params相同</td>
</tr>
</tbody></table>
<p>对于指定请求方式的控制器方法, 可以使用派生注解@请求方式+Mapping<br>value,method是或判断, params,headers是与判断</p>
<h2 id="支持ant风格路径"><a href="#支持ant风格路径" class="headerlink" title="支持ant风格路径"></a>支持ant风格路径</h2><p>?:表示任意单个字符<br>*:表示任意的0或多个字符<br>**:表示任意一层或多层目录</p>
<h2 id="支持占位符-RESTFul实现"><a href="#支持占位符-RESTFul实现" class="headerlink" title="支持占位符(RESTFul实现)"></a>支持占位符(RESTFul实现)</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RequestMapping(&quot;/target/&#123;id&#125;&quot;)</span><br><span class="line">public String target(@PathVariable(&quot;id&quot;)Integer id)&#123;</span><br><span class="line">    return &quot;success&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="SpringMVC获取请求参数"><a href="#SpringMVC获取请求参数" class="headerlink" title="SpringMVC获取请求参数"></a>SpringMVC获取请求参数</h1><p>(已经在boot笔记web:请求参数处理:普通参数与基本注解进行重写, 建议对照查看)</p>
<h2 id="通过servletAPI获取-一般不用"><a href="#通过servletAPI获取-一般不用" class="headerlink" title="通过servletAPI获取(一般不用)"></a>通过servletAPI获取(一般不用)</h2><p>将HttpServletRequest作为控制器形参, 前端控制器在调用时会自动为其注入属性, 在方法中直接进行调用.</p>
<h2 id="通过控制器形参获取请求参数"><a href="#通过控制器形参获取请求参数" class="headerlink" title="通过控制器形参获取请求参数"></a>通过控制器形参获取请求参数</h2><p>在控制器的形参中写入与请求参数的参数名, 会在调用时直接注入, 在方法中可以直接调用.<br>多个同名参数可以使用String(自动使用,分割),也可以使用String[]接收.<br>没有的参数也接受自动注入,注入null.</p>
<h2 id="通过-RequestParam获取请求参数"><a href="#通过-RequestParam获取请求参数" class="headerlink" title="通过@RequestParam获取请求参数"></a>通过@RequestParam获取请求参数</h2><p>在控制器形参前使用@RequestParam为形参绑定请求参数, 在调用时注入.<br>因为RequestParam源码中required方法为默认true, 所以不接受空注入(可改).<br>value: 形参名称.<br>required: 是否接受空注入.<br>defaultValue: 空参时默认参数(required无效).</p>
<h2 id="通过-RequestHeader获取请求参数"><a href="#通过-RequestHeader获取请求参数" class="headerlink" title="通过@RequestHeader获取请求参数"></a>通过@RequestHeader获取请求参数</h2><p>与@RequestParam类似, 但为形参绑定的是header中的参数.</p>
<h2 id="通过-CookieValue获取请求参数"><a href="#通过-CookieValue获取请求参数" class="headerlink" title="通过@CookieValue获取请求参数"></a>通过@CookieValue获取请求参数</h2><p>与@RequestParam类似, 但为形参绑定的是cookie中的参数.</p>
<h2 id="通过实体类获取请求参数"><a href="#通过实体类获取请求参数" class="headerlink" title="通过实体类获取请求参数"></a>通过实体类获取请求参数</h2><p>当发送的请求参数名与已有的实体类的属性名一致(一一对应)时, 控制器可以直接写入该实体类的形参, 直接调用.<br>get请求乱码由tomcat配置文件解决, post请求乱码由编码过滤器CharacterEncodingFilter类解决.<br>因为设置编码方式只允许在第一次获取请求参数的行为中, 所以这个过滤器要配置在最上方.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--配置编码过滤器--&gt;</span><br><span class="line">&lt;filter&gt;</span><br><span class="line">    &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;</span><br><span class="line">    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;</span><br><span class="line">    &lt;init-param&gt;</span><br><span class="line">        &lt;param-name&gt;encoding&lt;/param-name&gt;</span><br><span class="line">        &lt;param-value&gt;UTF-8&lt;/param-value&gt;</span><br><span class="line">    &lt;/init-param&gt;</span><br><span class="line">    &lt;init-param&gt;</span><br><span class="line">        &lt;param-name&gt;forceResponseEncoding&lt;/param-name&gt;</span><br><span class="line">        &lt;param-value&gt;true&lt;/param-value&gt;</span><br><span class="line">    &lt;/init-param&gt;</span><br><span class="line">&lt;/filter&gt;</span><br></pre></td></tr></table></figure>
<p>#域对象共享数据</p>
<h2 id="使用ServletAPI向request域对象共享数据-一般不用"><a href="#使用ServletAPI向request域对象共享数据-一般不用" class="headerlink" title="使用ServletAPI向request域对象共享数据(一般不用)"></a>使用ServletAPI向request域对象共享数据(一般不用)</h2><p>因为控制器可以直接注入request, 所以可以使用ServletAPI对域对象进行操作.</p>
<h2 id="使用ModelAndView向request域对象共享数据-域对象共享数据的根源方法"><a href="#使用ModelAndView向request域对象共享数据-域对象共享数据的根源方法" class="headerlink" title="使用ModelAndView向request域对象共享数据(域对象共享数据的根源方法)"></a>使用ModelAndView向request域对象共享数据(域对象共享数据的根源方法)</h2><p>model主要用于向请求域共享数据, view主要用于设置视图, 实现页面跳转.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RequestMapping(&quot;/target&quot;)</span><br><span class="line">public ModelAndView target()&#123;</span><br><span class="line">    //创建</span><br><span class="line">    ModelAndView modelAndView = new ModelAndView();</span><br><span class="line">    //设置域对象</span><br><span class="line">    modelAndView.addObject(&quot;key&quot;,&quot;value&quot;);</span><br><span class="line">    //设置视图名称</span><br><span class="line">    modelAndView.setViewName(&quot;target&quot;);</span><br><span class="line">    return modelAndView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用Model向request域对象共享数据"><a href="#使用Model向request域对象共享数据" class="headerlink" title="使用Model向request域对象共享数据"></a>使用Model向request域对象共享数据</h2><p>在控制器的形参中加入Model使用, 返回String, 二者交与ModelAndView包装处理.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RequestMapping(&quot;/target&quot;)</span><br><span class="line">public String target(Model model)&#123;</span><br><span class="line">    //设置域对象</span><br><span class="line">    model.addAttribute(&quot;key&quot;,&quot;value&quot;);</span><br><span class="line">    return &quot;target&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用map向request域对象共享数据"><a href="#使用map向request域对象共享数据" class="headerlink" title="使用map向request域对象共享数据"></a>使用map向request域对象共享数据</h2><p>与Model使用相同.</p>
<h2 id="使用ModelMap向request域对象共享数据"><a href="#使用ModelMap向request域对象共享数据" class="headerlink" title="使用ModelMap向request域对象共享数据"></a>使用ModelMap向request域对象共享数据</h2><p>与Model使用相同.</p>
<h2 id="使用原生Api向session域对象共享数据-推荐"><a href="#使用原生Api向session域对象共享数据-推荐" class="headerlink" title="使用原生Api向session域对象共享数据(推荐)"></a>使用原生Api向session域对象共享数据(推荐)</h2><p>在控制器形参中加入HttpSession进行调用.</p>
<h2 id="向application域中共享数据"><a href="#向application域中共享数据" class="headerlink" title="向application域中共享数据"></a>向application域中共享数据</h2><p>通过session.getServletContext()取得application, 在对其进行设置.</p>
<h1 id="SpringMVC的视图"><a href="#SpringMVC的视图" class="headerlink" title="SpringMVC的视图"></a>SpringMVC的视图</h1><p>默认视图InternalResourceView(转发视图)和RedirectView(重定向视图).<br>当工程引入jstl依赖后, 转发视图会自动转为JstlView.<br>若使用视图技术为thymeleaf, 由此视图解析器得到的就是ThymeleafView.</p>
<h2 id="ThymeleafView"><a href="#ThymeleafView" class="headerlink" title="ThymeleafView"></a>ThymeleafView</h2><p>当视图名称没有前缀时, 会使用thymeleaf解析.</p>
<h2 id="转发视图"><a href="#转发视图" class="headerlink" title="转发视图"></a>转发视图</h2><p>以”forward:”为前缀, 加相对路径</p>
<h2 id="重定向视图"><a href="#重定向视图" class="headerlink" title="重定向视图"></a>重定向视图</h2><p>以”redirect:”为前缀, 加相对路径</p>
<h2 id="视图控制器"><a href="#视图控制器" class="headerlink" title="视图控制器"></a>视图控制器</h2><p>只需要控制器器进行页面跳转时可以这样设置.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 使用这个标签后会导致controller的所有请求映射全部失效 --&gt;</span><br><span class="line">&lt;mvc:view-controller path=&quot;&quot; view-name=&quot;&quot;&gt;&lt;/mvc:view-controller&gt;</span><br><span class="line">&lt;!-- 为了不让controller的地址映射失效, 要使用这个标签配置 --&gt;</span><br><span class="line">&lt;!-- 开启MVC的注解驱动 --&gt;</span><br><span class="line">&lt;mvc:annotation-driven /&gt;</span><br></pre></td></tr></table></figure>
<p>这里的view-name符合上述前缀规则.</p>
<h2 id="SpringMVC视图解析器"><a href="#SpringMVC视图解析器" class="headerlink" title="SpringMVC视图解析器"></a>SpringMVC视图解析器</h2><p>用于解析jsp.<br>默认为转发视图.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/templates/&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean</span><br></pre></td></tr></table></figure>
<h1 id="RESTFul"><a href="#RESTFul" class="headerlink" title="RESTFul"></a>RESTFul</h1><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><p>RESTFul架构风格, 它可以有效减少url的复杂度. 因为同一资源可能会需要多种状态的操作, 不使用RESTFul架构原则就是单纯的在url上对资源与状态进行拼接, 这会增大url的复杂度.<br>如果仅围绕资源进行url进行创建, 而针对状态的操作全部存放于Header中进行表述, 这样相同的请求路径就使用不同的请求方式就能实现不同的操作.</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><table>
<thead>
<tr>
<th>操作</th>
<th>传统方式</th>
<th>RSEST风格</th>
</tr>
</thead>
<tbody><tr>
<td>查询操作</td>
<td>getUserById?id = 1</td>
<td>user/1 GET请求方式</td>
</tr>
<tr>
<td>保存操作</td>
<td>saveUser</td>
<td>user POST请求方式</td>
</tr>
<tr>
<td>删除操作</td>
<td>deletUser?id = 1</td>
<td>user/1 DELETE请求方式</td>
</tr>
<tr>
<td>更新操作</td>
<td>updateUser</td>
<td>user PUT请求</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@GetMapping(&quot;/user/&#123;id&#125;&quot;)</span><br><span class="line">@PostMapping(&quot;/user&quot;)</span><br><span class="line">@DeleteMapping(&quot;/user/&#123;id&#125;&quot;)</span><br><span class="line">@PutMapping(&quot;/user&quot;)</span><br></pre></td></tr></table></figure>
<h2 id="使用HiddenHttpMethodFilter生成其他请求方式"><a href="#使用HiddenHttpMethodFilter生成其他请求方式" class="headerlink" title="使用HiddenHttpMethodFilter生成其他请求方式"></a>使用HiddenHttpMethodFilter生成其他请求方式</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;filter&gt;</span><br><span class="line">  &lt;filter-name&gt;HiddenHttpMethodFilter&lt;/filter-name&gt;</span><br><span class="line">  &lt;filter-class&gt;org.springframework.web.filter.HiddenHttpMethodFilter&lt;/filter-class&gt;</span><br><span class="line">&lt;/filter&gt;</span><br><span class="line">&lt;filter-mapping&gt;</span><br><span class="line">  &lt;filter-name&gt;HiddenHttpMethodFilter&lt;/filter-name&gt;</span><br><span class="line">  &lt;url-pattern&gt;/*&lt;/url-pattern&gt;</span><br><span class="line">&lt;/filter-mapping&gt;</span><br></pre></td></tr></table></figure>
<p>它会获取当前的请求方式以及_Method的参数, 如果当前请求方式为post, 则替换为_method中的方法.<br>delete因为一般是超链接, 所以要写一个单击绑定事件绑定一个隐藏的表单, 让表单代替这个超链接发送信息.</p>
<h2 id="RESTFul案例"><a href="#RESTFul案例" class="headerlink" title="RESTFul案例"></a>RESTFul案例</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Controller</span><br><span class="line">public class EmployeeController &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private EmployeeDao employeeDao;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;/employee&quot;)</span><br><span class="line">    public ModelAndView showEmployees()&#123;</span><br><span class="line">        ModelAndView mv = new ModelAndView();</span><br><span class="line">        mv.addObject(&quot;employees&quot;,employeeDao.getAll());</span><br><span class="line">        mv.setViewName(&quot;showEmployees&quot;);</span><br><span class="line">        return mv;</span><br><span class="line">    &#125;</span><br><span class="line">    @DeleteMapping(&quot;/employee/&#123;id&#125;&quot;)</span><br><span class="line">    public ModelAndView deletEmployee(@PathVariable Integer id)&#123;</span><br><span class="line">        ModelAndView mv = new ModelAndView();</span><br><span class="line">        employeeDao.delete(id);</span><br><span class="line">        mv.setViewName(&quot;redirect:/employee&quot;);</span><br><span class="line">        return mv;</span><br><span class="line">    &#125;</span><br><span class="line">    @PostMapping(&quot;/employee&quot;)</span><br><span class="line">    public String addEmployee(Employee employee)&#123;</span><br><span class="line">        employeeDao.save(employee);</span><br><span class="line">        return &quot;redirect:/employee&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    @GetMapping(&quot;/employee/&#123;id&#125;&quot;)</span><br><span class="line">    public ModelAndView showEmployee(@PathVariable Integer id)&#123;</span><br><span class="line">        ModelAndView modelAndView = new ModelAndView();</span><br><span class="line">        modelAndView.addObject(&quot;employee&quot;,employeeDao.get(id));</span><br><span class="line">        modelAndView.setViewName(&quot;update&quot;);</span><br><span class="line">        return modelAndView;</span><br><span class="line">    &#125;</span><br><span class="line">    @PutMapping (&quot;/employee&quot;)</span><br><span class="line">    public String updateEmployee(Employee employee)&#123;</span><br><span class="line">        employeeDao.save(employee);</span><br><span class="line">        return &quot;redirect:/employee&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="HttpMessageConverter"><a href="#HttpMessageConverter" class="headerlink" title="HttpMessageConverter"></a>HttpMessageConverter</h1><h2 id="RequestBody"><a href="#RequestBody" class="headerlink" title="@RequestBody"></a>@RequestBody</h2><p>获取请求体,控制器使用此注释String形参接收即可.</p>
<h2 id="RequestEntity"><a href="#RequestEntity" class="headerlink" title="RequestEntity"></a>RequestEntity</h2><p>封装整个请求报文, 在控制器使用RequestEntity类形参使用, 有getHeaders和getBody两个方法.</p>
<h2 id="ResponseBody"><a href="#ResponseBody" class="headerlink" title="@ResponseBody"></a>@ResponseBody</h2><p>将此注释加到控制器上, 返回的String就会作为响应体送回.<br>如果要返回其他数据, 可以使用json(只加入依赖即可, json依靠ResponseBody注解实现自动转换).</p>
<h2 id="RestController"><a href="#RestController" class="headerlink" title="@RestController"></a>@RestController</h2><p>因为在微服务中服务与服务间需要进行数据交互, 所以会大量依靠json传输数据, 而json又依靠ResponseBody注解进行自动转换, 所以几乎每个控制器都要添加这个注解ResponseBody.<br>所以产生了RestController注解, 将它注解在类上, 相当于使用了Controller注解, 且为此类所有方法添加ResponseBody注解.</p>
<h2 id="ResponseEntity"><a href="#ResponseEntity" class="headerlink" title="ResponseEntity"></a>ResponseEntity</h2><p>作为控制器的返回值返回整个报文, 常用于文件下载上传.</p>
<h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RequestMapping(&quot;/testDown&quot;)</span><br><span class="line">public ResponseEntity&lt;byte[]&gt; testResponseEntity(HttpSession session) throws IOException &#123;</span><br><span class="line">    //获取ServletContext对象</span><br><span class="line">    ServletContext servletContext = session.getServletContext();</span><br><span class="line">    //获取服务器中文件的真实路径</span><br><span class="line">    String realPath = servletContext.getRealPath(&quot;/static/img/1.jpg&quot;);</span><br><span class="line">    System.out.println(realPath);</span><br><span class="line">    //创建输入流</span><br><span class="line">    InputStream is = new FileInputStream(realPath);</span><br><span class="line">    //创建字节数组</span><br><span class="line">    byte[] bytes = new byte[is.available()];</span><br><span class="line">    //将流读到字节数组中</span><br><span class="line">    is.read(bytes);</span><br><span class="line">    //创建HttpHeaders对象设置响应头信息</span><br><span class="line">    MultiValueMap&lt;String, String&gt; headers = new HttpHeaders();</span><br><span class="line">    //设置要下载方式以及下载文件的名字</span><br><span class="line">    headers.add(&quot;Content-Disposition&quot;, &quot;attachment;filename=1.jpg&quot;);</span><br><span class="line">    //设置响应状态码</span><br><span class="line">    HttpStatus statusCode = HttpStatus.OK;</span><br><span class="line">    //创建ResponseEntity对象</span><br><span class="line">    ResponseEntity&lt;byte[]&gt; responseEntity = new ResponseEntity&lt;&gt;(bytes, headers, statusCode);</span><br><span class="line">    //关闭输入流</span><br><span class="line">    is.close();</span><br><span class="line">    return responseEntity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="上传"><a href="#上传" class="headerlink" title="上传"></a>上传</h3><p>导入上传依赖<br>设置文件上传解析器, 使上传的各种内容可以被封装到MultipartFile类中</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&lt;bean <span class="attribute">id</span>=<span class="string">&quot;multipartResolver&quot;</span> <span class="attribute">class</span>=<span class="string">&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;</span>&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RequestMapping(&quot;/testUp&quot;)</span><br><span class="line">//MultipartFile就存储了上传的各种信息</span><br><span class="line">public String testUp(MultipartFile photo, HttpSession session) throws IOException &#123;</span><br><span class="line">    //获取上传的文件的文件名</span><br><span class="line">    String fileName = photo.getOriginalFilename();</span><br><span class="line">    //获取上传的文件的后缀名</span><br><span class="line">    String suffixName = fileName.substring(fileName.lastIndexOf(&quot;.&quot;));</span><br><span class="line">    //将UUID作为文件名, 应对重名</span><br><span class="line">    String uuid = UUID.randomUUID().toString();</span><br><span class="line">    //将uuid和后缀名拼接后的结果作为最终的文件名</span><br><span class="line">    fileName = uuid + suffixName;</span><br><span class="line">    //通过ServletContext获取服务器中photo目录的路径</span><br><span class="line">    ServletContext servletContext = session.getServletContext();</span><br><span class="line">    String photoPath = servletContext.getRealPath(&quot;photo&quot;);</span><br><span class="line">    File file = new File(photoPath);</span><br><span class="line">    //判断photoPath所对应路径是否存在</span><br><span class="line">    if(!file.exists())&#123;</span><br><span class="line">        //若不存在，则创建目录</span><br><span class="line">        file.mkdir();</span><br><span class="line">    &#125;</span><br><span class="line">    // File.separator是文件分隔符, 这样就构成了指向路径与文件名的一个finalPath </span><br><span class="line">    String finalPath = photoPath + File.separator + fileName;</span><br><span class="line">    //上传文件</span><br><span class="line">    photo.transferTo(new File(finalPath));</span><br><span class="line">    return &quot;success&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h1><p>拦截器包含三个方法<br>preHandle: 控制器方法前执行<br>postHandle: 控制器方法后执行<br>afterCompletion: 视图渲染结束后执行</p>
<h2 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h2><p>spring配置文件中配置拦截器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;mvc:interceptors&gt;</span><br><span class="line">&lt;!-- 全部拦截 --&gt;</span><br><span class="line">    &lt;ref bean=&quot;拦截器类名&quot;&gt;&lt;/ref&gt;</span><br><span class="line">&lt;!-- 部分拦截 --&gt;</span><br><span class="line">    &lt;mvc:interceptor&gt;</span><br><span class="line">    &lt;!-- /*是任意一级目录, /**是全路径 --&gt;</span><br><span class="line">        &lt;mvc:mapping path=&quot;/**&quot;/&gt;</span><br><span class="line">        &lt;mvc:exclude-mapping path=&quot;/&quot;/&gt;</span><br><span class="line">        &lt;ref bean=&quot;firstInterceptor&quot;&gt;&lt;/ref&gt;</span><br><span class="line">    &lt;/mvc:interceptor&gt;</span><br><span class="line">&lt;/mvc:interceptors&gt;</span><br></pre></td></tr></table></figure>
<p>编写拦截器方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class FirstInterceptor implements HandlerInterceptor &#123;</span><br><span class="line">    //这里的返回值决定是否放行</span><br><span class="line">    @Override</span><br><span class="line">    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;FirstInterceptor--&gt;preHandle&quot;);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;FirstInterceptor--&gt;postHandle&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;FirstInterceptor--&gt;afterCompletion&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h2><p>多个拦截器时preHandle与配置顺序相同, 剩下两个方法与配置顺序相反.<br>拦截器的遍历是使用的指针, 这个指针会在preHandle方法调用后进行后移, 剩下的两个方法通过指针前移调用方法.<br>且当preHandle方法链出现false时不会在调用postHandle方法链, 但仍会调用afterCompletion方法链.<br>例: 设置5个过滤器, 在第3个过滤器进行拦截, 那么会执行1,2,3的preHandle方法以及1,2的afterCompletion方法.</p>
<h1 id="异常处理器"><a href="#异常处理器" class="headerlink" title="异常处理器"></a>异常处理器</h1><h2 id="基于配置"><a href="#基于配置" class="headerlink" title="基于配置"></a>基于配置</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--配置异常处理--&gt;</span><br><span class="line">&lt;bean class=&quot;org.springframework.web.servlet.handler.SimpleMappingExceptionResolver&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;exceptionMappings&quot;&gt;</span><br><span class="line">        &lt;props&gt;</span><br><span class="line">            &lt;prop key=&quot;异常全类名&quot;&gt;跳转的视图&lt;/prop&gt;</span><br><span class="line">        &lt;/props&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;!-- 设置将异常信息共享在请求域中的键, 会把这里的value作为key, 异常作为value存放在域中 --&gt;</span><br><span class="line">    &lt;property name=&quot;exceptionAttribute&quot; value=&quot;ex&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<h2 id="基于注解"><a href="#基于注解" class="headerlink" title="基于注解"></a>基于注解</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//Controller注释进行异常捕获只能捕获该Controller中的异常</span><br><span class="line">//而ControllerAdvice注释可以捕获其覆盖的所有Controller(默认所有)的异常</span><br><span class="line">@ControllerAdvice</span><br><span class="line">public class ExceptionController &#123;</span><br><span class="line"></span><br><span class="line">    @ExceptionHandler(value = &#123;异常全类名&#125;)</span><br><span class="line">    public String testException(Exception ex, Model model)&#123;</span><br><span class="line">        model.addAttribute(&quot;ex&quot;, ex);</span><br><span class="line">        return &quot;error&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="注解配置MVC"><a href="#注解配置MVC" class="headerlink" title="注解配置MVC"></a>注解配置MVC</h1><p>替代web.xml</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//web工程的初始化类，用来代替web.xml</span><br><span class="line">public class WebInit extends AbstractAnnotationConfigDispatcherServletInitializer &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 指定spring的配置类</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    protected Class&lt;?&gt;[] getRootConfigClasses() &#123;</span><br><span class="line">        return new Class[]&#123;SpringConfig.class&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 指定springMVC的配置类</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    protected Class&lt;?&gt;[] getServletConfigClasses() &#123;</span><br><span class="line">        return new Class[]&#123;WebConfig.class&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 指定DispatcherServlet的映射规则，即url-pattern</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    protected String[] getServletMappings() &#123;</span><br><span class="line">        return new String[]&#123;&quot;/&quot;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 注册过滤器</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    protected Filter[] getServletFilters() &#123;</span><br><span class="line">        CharacterEncodingFilter characterEncodingFilter = new CharacterEncodingFilter();</span><br><span class="line">        characterEncodingFilter.setEncoding(&quot;UTF-8&quot;);</span><br><span class="line">        characterEncodingFilter.setForceResponseEncoding(true);</span><br><span class="line">        HiddenHttpMethodFilter hiddenHttpMethodFilter = new HiddenHttpMethodFilter();</span><br><span class="line">        return new Filter[]&#123;characterEncodingFilter, hiddenHttpMethodFilter&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>替代Spring.xml</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//SSM整合后学习</span><br></pre></td></tr></table></figure>
<p>替代SpringMVC.xml</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//将当前类标识为一个配置类</span><br><span class="line">@Configuration</span><br><span class="line">//1、扫描组件</span><br><span class="line">@ComponentScan(&quot;com.atguigu.mvc.controller&quot;)</span><br><span class="line">//5、mvc注解驱动</span><br><span class="line">@EnableWebMvc</span><br><span class="line">public class WebConfig implements WebMvcConfigurer &#123;</span><br><span class="line"></span><br><span class="line">    //4、default-servlet-handler</span><br><span class="line">    @Override</span><br><span class="line">    public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) &#123;</span><br><span class="line">        configurer.enable();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //8、拦截器</span><br><span class="line">    @Override</span><br><span class="line">    public void addInterceptors(InterceptorRegistry registry) &#123;</span><br><span class="line">        TestInterceptor testInterceptor = new TestInterceptor();</span><br><span class="line">        registry.addInterceptor(拦截器类名).addPathPatterns(&quot;/**&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //3、view-controller对请求路径配置资源</span><br><span class="line">    @Override</span><br><span class="line">    public void addViewControllers(ViewControllerRegistry registry) &#123;</span><br><span class="line">        registry.addViewController(&quot;/&quot;).setViewName(&quot;index&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //6、文件上传解析器</span><br><span class="line">    @Bean</span><br><span class="line">    public MultipartResolver multipartResolver()&#123;</span><br><span class="line">        CommonsMultipartResolver commonsMultipartResolver = new CommonsMultipartResolver();</span><br><span class="line">        return commonsMultipartResolver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //7、异常处理</span><br><span class="line">    @Override</span><br><span class="line">    public void configureHandlerExceptionResolvers(List&lt;HandlerExceptionResolver&gt; resolvers) &#123;</span><br><span class="line">        SimpleMappingExceptionResolver exceptionResolver = new SimpleMappingExceptionResolver();</span><br><span class="line">        Properties prop = new Properties();</span><br><span class="line">        //为异常与跳转页面进行绑定</span><br><span class="line">        prop.setProperty(&quot;java.lang.ArithmeticException&quot;, &quot;error&quot;);</span><br><span class="line">        exceptionResolver.setExceptionMappings(prop);</span><br><span class="line">        //设置域中共享异常的键   </span><br><span class="line">        exceptionResolver.setExceptionAttribute(&quot;exception&quot;);</span><br><span class="line">        resolvers.add(exceptionResolver);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //配置生成模板解析器</span><br><span class="line">    @Bean</span><br><span class="line">    public ITemplateResolver templateResolver() &#123;</span><br><span class="line">        WebApplicationContext webApplicationContext = ContextLoader.getCurrentWebApplicationContext();</span><br><span class="line">        // ServletContextTemplateResolver需要一个ServletContext作为构造参数，可通过WebApplicationContext 的方法获得</span><br><span class="line">        ServletContextTemplateResolver templateResolver = new ServletContextTemplateResolver(</span><br><span class="line">                webApplicationContext.getServletContext());</span><br><span class="line">        templateResolver.setPrefix(&quot;/WEB-INF/templates/&quot;);</span><br><span class="line">        templateResolver.setSuffix(&quot;.html&quot;);</span><br><span class="line">        templateResolver.setCharacterEncoding(&quot;UTF-8&quot;);</span><br><span class="line">        templateResolver.setTemplateMode(TemplateMode.HTML);</span><br><span class="line">        return templateResolver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //生成模板引擎并为模板引擎注入模板解析器</span><br><span class="line">    @Bean</span><br><span class="line">    public SpringTemplateEngine templateEngine(ITemplateResolver templateResolver) &#123;</span><br><span class="line">        SpringTemplateEngine templateEngine = new SpringTemplateEngine();</span><br><span class="line">        templateEngine.setTemplateResolver(templateResolver);</span><br><span class="line">        return templateEngine;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //生成视图解析器并未解析器注入模板引擎</span><br><span class="line">    @Bean</span><br><span class="line">    public ViewResolver viewResolver(SpringTemplateEngine templateEngine) &#123;</span><br><span class="line">        ThymeleafViewResolver viewResolver = new ThymeleafViewResolver();</span><br><span class="line">        viewResolver.setCharacterEncoding(&quot;UTF-8&quot;);</span><br><span class="line">        viewResolver.setTemplateEngine(templateEngine);</span><br><span class="line">        return viewResolver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="从整体看SpringMVC"><a href="#从整体看SpringMVC" class="headerlink" title="从整体看SpringMVC"></a>从整体看SpringMVC</h1><h2 id="常用组件"><a href="#常用组件" class="headerlink" title="常用组件"></a>常用组件</h2><table>
<thead>
<tr>
<th>名称</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>DispatcherServlet：前端控制器</td>
<td>统一处理请求和响应，整个流程控制的中心，由它调用其它组件处理用户的请求</td>
</tr>
<tr>
<td>HandlerMapping：控制器映射器</td>
<td>根据请求的url、method等信息查找Handler，即控制器方法</td>
</tr>
<tr>
<td>Handler:控制器</td>
<td>在DispatcherServlet的控制下Handler对具体的用户请求进行处理</td>
</tr>
<tr>
<td>HandlerAdapter：处理器适配器</td>
<td>通过HandlerAdapter对控制器方法进行执行</td>
</tr>
<tr>
<td>ViewResolver：视图解析器</td>
<td>进行视图解析，得到相应的视图</td>
</tr>
<tr>
<td>View：视图</td>
<td>将模型数据通过页面展示给用户</td>
</tr>
</tbody></table>
<h2 id="DispatcherServlet初始化过程"><a href="#DispatcherServlet初始化过程" class="headerlink" title="DispatcherServlet初始化过程"></a>DispatcherServlet初始化过程</h2><p><img src="/images/DEF117C6A91CF649B77F4FB4025678B7.png" alt="初始化过程"></p>
<h2 id="DispatcherServlet服务过程"><a href="#DispatcherServlet服务过程" class="headerlink" title="DispatcherServlet服务过程"></a>DispatcherServlet服务过程</h2><p><img src="/images/4691F0FD3B43E392EA6959BBD17525D5.png" alt="服务过程"></p>
<h2 id="SpringMVC执行流程"><a href="#SpringMVC执行流程" class="headerlink" title="SpringMVC执行流程"></a>SpringMVC执行流程</h2><p>1.用户向服务器发送请求, 请求被DispatcherServlet捕获<br>2.交由handlerMapping处理判断是否存在映射, 没有就报404<br>3.有的话把对应的映射交给handlerAdapter, handlerAdapter为即将调用的控制器进行一系列的准备工作(提取req的信息, 注入参数, 数据验证等等)<br>4.然后交给prehandler进行处理<br>5.处理后再交给控制器, 控制器进行一些列操作并且设置mv<br>6.再由posthandler处理<br>7.处理后再交给视图解析器进行解析mv并渲染视图<br>8.接着执行拦截器的afterCompletion<br>9.最后把渲染结果交给客户端</p>
]]></content>
      <categories>
        <category>框架</category>
      </categories>
  </entry>
  <entry>
    <title>maven</title>
    <url>/2021/12/20/%E5%B7%A5%E5%85%B7/maven/</url>
    <content><![CDATA[<h1 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h1><p>1.帮助开发人员做项目的编译,测试,打包,安装部署等工作.<br>2.管理依赖</p>
<span id="more"></span>
<h1 id="约定的目录结构"><a href="#约定的目录结构" class="headerlink" title="约定的目录结构"></a>约定的目录结构</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hello 项目文件夹</span><br><span class="line">	\src</span><br><span class="line">		\main</span><br><span class="line">			\java</span><br><span class="line">			\resources</span><br><span class="line">		\test</span><br><span class="line">			\java</span><br><span class="line">			\resources</span><br><span class="line">	\pom.xml</span><br></pre></td></tr></table></figure>
<h1 id="pom文件"><a href="#pom文件" class="headerlink" title="pom文件"></a>pom文件</h1><h2 id="gav"><a href="#gav" class="headerlink" title="gav"></a>gav</h2><p>用来确定资源,是资源的唯一标识符.<br>1.每个项目都要有自己的gav.<br>2.管理依赖,也需要使用gav作为标识.在maven仓库中搜索依赖的gav.<br>gropId:组织id,一般使用组织域名的倒写.如果项目较大,还可以加上项目名称.<br>artifactId:项目名称,如果gropId中有项目名称,就用子项目的名称.<br>version:版本号,使用数字,一般三位.</p>
<h2 id="dependencies和dependency"><a href="#dependencies和dependency" class="headerlink" title="dependencies和dependency"></a>dependencies和dependency</h2><p>与gav组合管理依赖.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">	&lt;dependency&gt;</span><br><span class="line">		gav</span><br><span class="line">	&lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>
<h2 id="packaging"><a href="#packaging" class="headerlink" title="packaging"></a>packaging</h2><p>项目的打包类型,可以是jar,war,rar,ear,pom,默认是jar.</p>
<h1 id="dependencyManagement和dependencies"><a href="#dependencyManagement和dependencies" class="headerlink" title="dependencyManagement和dependencies"></a>dependencyManagement和dependencies</h1><p>dependencyManagement能让所有子项目不需要进行版本管理, 如果没有声明版本号maven会沿着父项目向上走, 直到遇到dependencyManagement后使用它其中的版本号.</p>
<h1 id="maven的生命周期-插件和命令"><a href="#maven的生命周期-插件和命令" class="headerlink" title="maven的生命周期,插件和命令"></a>maven的生命周期,插件和命令</h1><p>生命周期:项目构建的各个阶段.包括清理,编译,测试,报告,打包,安装,部署.<br>插件:要完成maven的各个阶段要使用maven命令,执行的命令是通过插件完成的,是jar.<br>命令:执行maven功能是由命令发出的.</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>mvn clan</td>
<td>删除以前生成的数据,删除target目录</td>
</tr>
<tr>
<td>mvn cmpile</td>
<td>编译代码</td>
</tr>
<tr>
<td>mvn test-compile</td>
<td>编译test代码</td>
</tr>
<tr>
<td>mvn test</td>
<td>执行test-classes目录的程序</td>
</tr>
<tr>
<td>mvn package</td>
<td>把项目资源都放进一个压缩文件中</td>
</tr>
<tr>
<td>mvn install</td>
<td>把生成的打包文件安装到maven仓库</td>
</tr>
</tbody></table>
<h1 id="配置插件"><a href="#配置插件" class="headerlink" title="配置插件"></a>配置插件</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 设置构建项目相关内容 --&gt;</span><br><span class="line">&lt;build&gt;</span><br><span class="line">	&lt;plugins&gt;</span><br><span class="line">		&lt;!-- 插件信息 --&gt;</span><br><span class="line">		&lt;plugin&gt;</span><br><span class="line">			&lt;groupId&gt;org.apche.maven.plugins&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;</span><br><span class="line">			&lt;version&gt;3.8.1&lt;/version&gt;</span><br><span class="line">			&lt;!-- 修改的配置 --&gt;</span><br><span class="line">			&lt;configuration&gt;</span><br><span class="line">				&lt;source&gt;1.8&lt;/source&gt;&lt;!-- 指定编译代码的jdk版本 --&gt;</span><br><span class="line">				&lt;target&gt;1.8&lt;/target&gt;&lt;!-- 运行java代码使用的jak版本 --&gt;</span><br><span class="line">			&lt;/configuration&gt;</span><br><span class="line">		&lt;/plugin&gt;</span><br><span class="line">	&lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure>
<h1 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h1><p>scope用来表示依赖范围,规定依赖生效的阶段.<br>compile:默认,所有阶段<br>test:测试阶段<br>provided:项目在部署到服务器时不需要提供这个依赖(servlet和jsp)    </p>
<h1 id="一些配置防止资源导出失败的问题"><a href="#一些配置防止资源导出失败的问题" class="headerlink" title="一些配置防止资源导出失败的问题"></a>一些配置防止资源导出失败的问题</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;build&gt;    </span><br><span class="line">    &lt;resources&gt;</span><br><span class="line">      &lt;resource&gt;</span><br><span class="line">        &lt;directory&gt;src/main/java&lt;/directory&gt;</span><br><span class="line">        &lt;includes&gt;</span><br><span class="line">          &lt;include&gt;**/*.xml&lt;/include&gt;</span><br><span class="line">          &lt;include&gt;**/*.properties&lt;/include&gt;</span><br><span class="line">        &lt;/includes&gt;</span><br><span class="line">        &lt;filtering&gt;true&lt;/filtering&gt;</span><br><span class="line">      &lt;/resource&gt;</span><br><span class="line">      &lt;resource&gt;</span><br><span class="line">        &lt;directory&gt;src/main/resources&lt;/directory&gt;</span><br><span class="line">        &lt;includes&gt;</span><br><span class="line">          &lt;include&gt;**/*.xml&lt;/include&gt;</span><br><span class="line">          &lt;include&gt;**/*.properties&lt;/include&gt;</span><br><span class="line">        &lt;/includes&gt;</span><br><span class="line">        &lt;filtering&gt;true&lt;/filtering&gt;</span><br><span class="line">      &lt;/resource&gt;</span><br><span class="line">    &lt;/resources&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title>git操作手册</title>
    <url>/2021/11/19/%E5%B7%A5%E5%85%B7/git%E6%93%8D%E4%BD%9C%E6%89%8B%E5%86%8C/</url>
    <content><![CDATA[<p>此为git常用命令备忘</p>
<span id="more"></span>

<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>本地库操作</td>
<td></td>
</tr>
<tr>
<td>git init</td>
<td>初始化本地库</td>
</tr>
<tr>
<td>git status</td>
<td>显示本地库状态</td>
</tr>
<tr>
<td>git add 文件名</td>
<td>提交文件至暂存区</td>
</tr>
<tr>
<td>git rm –cached 文件名</td>
<td>删除暂存区文件</td>
</tr>
<tr>
<td>git commit -m “日志” 文件名</td>
<td>将暂存区文件提交到本地库(当合并冲突导致进入合并中状态时，提交文件不允许添加文件名)</td>
</tr>
<tr>
<td>git reflog</td>
<td>查看引用日志信息</td>
</tr>
<tr>
<td>git log</td>
<td>查看详细日志</td>
</tr>
<tr>
<td>git reset –hard 版本号</td>
<td>版本穿梭</td>
</tr>
<tr>
<td>git branch -v</td>
<td>查看分支</td>
</tr>
<tr>
<td>git branch 分支名</td>
<td>创建分支</td>
</tr>
<tr>
<td>git checkout 分支名</td>
<td>切换分支</td>
</tr>
<tr>
<td>git merge 分支名</td>
<td>合并分支</td>
</tr>
<tr>
<td>远程库操作</td>
<td></td>
</tr>
<tr>
<td>git remote -v</td>
<td>查看远程地址别名</td>
</tr>
<tr>
<td>git remote add 别名 地址</td>
<td>为远程地址命名</td>
</tr>
<tr>
<td>git push 别名 分支</td>
<td>推到远程库</td>
</tr>
<tr>
<td>git pull 别名 分支</td>
<td>拉到本地库</td>
</tr>
<tr>
<td>git clone 链接</td>
<td>克隆到本地</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Thymeleaf</title>
    <url>/2021/12/22/%E5%B7%A5%E5%85%B7/Thymeleaf/</url>
    <content><![CDATA[<h1 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h1><p>在Spring中配置thymeleaf</p>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 配置Thymeleaf视图解析器 --&gt;</span><br><span class="line">&lt;bean id=&quot;viewResolver&quot; class=&quot;org.thymeleaf.spring5.view.ThymeleafViewResolver&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;order&quot; value=&quot;1&quot;/&gt;</span><br><span class="line">    &lt;property name=&quot;characterEncoding&quot; value=&quot;UTF-8&quot;/&gt;</span><br><span class="line">    &lt;property name=&quot;templateEngine&quot;&gt;</span><br><span class="line">        &lt;bean class=&quot;org.thymeleaf.spring5.SpringTemplateEngine&quot;&gt;</span><br><span class="line">            &lt;property name=&quot;templateResolver&quot;&gt;</span><br><span class="line">                &lt;bean class=&quot;org.thymeleaf.spring5.templateresolver.SpringResourceTemplateResolver&quot;&gt;</span><br><span class="line">                    &lt;!-- 视图前缀 --&gt;</span><br><span class="line">                    &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/templates/&quot;/&gt;</span><br><span class="line">                    &lt;!-- 视图后缀 --&gt;</span><br><span class="line">                    &lt;property name=&quot;suffix&quot; value=&quot;.html&quot;/&gt;</span><br><span class="line">                    &lt;property name=&quot;templateMode&quot; value=&quot;HTML5&quot;/&gt;</span><br><span class="line">                    &lt;property name=&quot;characterEncoding&quot; value=&quot;UTF-8&quot; /&gt;</span><br><span class="line">                &lt;/bean&gt;</span><br><span class="line">            &lt;/property&gt;</span><br><span class="line">        &lt;/bean&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<p>在页面中引入thymeleaf</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;</span><br></pre></td></tr></table></figure>
<h1 id="常用语法"><a href="#常用语法" class="headerlink" title="常用语法"></a>常用语法</h1><p>解析绝对路径:th修饰属性,通过@{}修饰绝对路径</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;a th:href=&quot;@&#123;/target&#125;&quot;&gt;访问目标页面&lt;/a&gt;</span><br></pre></td></tr></table></figure>
<p>在html中使用EL表达式取得域对象:th修饰属性</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;p th:text=&quot;$&#123;key&#125;&quot;&gt;&lt;/p&gt;</span><br></pre></td></tr></table></figure>
<p>遍历数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;tr class=&quot;grade&quot; th:each=&quot;user,stats:$&#123;users&#125;&quot;&gt;</span><br><span class="line">    &lt;td th:text=&quot;$&#123;stats.count&#125;&quot;&gt;&lt;/td&gt;</span><br><span class="line">    &lt;td th:text=&quot;$&#123;user.userName&#125;&quot;&gt;&lt;/td&gt;</span><br><span class="line">    &lt;td th:text=&quot;$&#123;user.passWord&#125;&quot;&gt;&lt;/td&gt;</span><br><span class="line">&lt;/tr&gt;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title>linux常用命令</title>
    <url>/2021/11/19/%E5%B7%A5%E5%85%B7/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>一些常用的命令</p>
<span id="more"></span>
<h1 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h1><table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>cd + 文件路径</td>
<td>进入到该文件路径下</td>
</tr>
<tr>
<td>cd..</td>
<td>进入到当前上一级目录</td>
</tr>
<tr>
<td>cd ~</td>
<td>返回到当前用户身份的根目录($代表普通用户，#代表root)</td>
</tr>
<tr>
<td>ls</td>
<td>展示当前目录中所有的文件和文件夹名称</td>
</tr>
<tr>
<td>ll</td>
<td>展示当前目录中所有的文件和文件夹名称的详细信息</td>
</tr>
<tr>
<td>ls -a</td>
<td>除了ls的功能，还能显示出隐藏文件</td>
</tr>
<tr>
<td>mkdir+文件夹名称</td>
<td>创建一个文件夹</td>
</tr>
<tr>
<td>rmdir + 文件夹名称</td>
<td>删除一个文件夹</td>
</tr>
<tr>
<td>touch + 文件名</td>
<td>创建一个文件</td>
</tr>
<tr>
<td>rm + 文件名</td>
<td>删除一个文件</td>
</tr>
<tr>
<td>rm -rf + 文件的名称</td>
<td>删除文件夹已经文件夹中的所有内容，强制删除不询问</td>
</tr>
<tr>
<td>mv + 文件+路径</td>
<td>移动文件到指定路径下</td>
</tr>
<tr>
<td>mv -r + 文件夹+路径</td>
<td>移动文件夹到指定路径下</td>
</tr>
<tr>
<td>cp + 文件 + 路径</td>
<td>拷贝文件到指定路径下</td>
</tr>
<tr>
<td>cat + 文件</td>
<td>输出文件的内容</td>
</tr>
<tr>
<td>tar + 命令选项 + 压缩包名</td>
<td>压缩或解压 -cvzf表示压缩 -xzvf表示解压</td>
</tr>
</tbody></table>
<h1 id="Vi-Vim"><a href="#Vi-Vim" class="headerlink" title="Vi/Vim"></a>Vi/Vim</h1><p>vim+文件名：如果文件存在，直接打开该文件，如果文件不存在，那么会创建该名字的新文件并打开<br>vim分为三个模式，一个是ESC模式（一般模式），一个是I模式（编辑模式），还有一个是命令模式<br>一般模式是通过移动光标在代码段上，输入命令完成操作,编辑模式就是正常的输入内容</p>
<p>一般模式常用命令:</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>(数字)+dd</td>
<td>删除行</td>
</tr>
<tr>
<td>x</td>
<td>删除光标所在字符</td>
</tr>
<tr>
<td>(数字)+yy</td>
<td>拷贝行</td>
</tr>
<tr>
<td>p</td>
<td>粘贴</td>
</tr>
<tr>
<td>u</td>
<td>撤销到上一步</td>
</tr>
</tbody></table>
<p>命令模式常用的命令:</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>w</td>
<td>保存文件</td>
</tr>
<tr>
<td>q</td>
<td>退出</td>
</tr>
<tr>
<td>wq</td>
<td>保存并退出</td>
</tr>
<tr>
<td>q！</td>
<td>不保存强制退出</td>
</tr>
<tr>
<td>/关键字</td>
<td>在内容中搜素该关键字，n往下搜素下一个，N往上搜索上一个</td>
</tr>
<tr>
<td>set nu</td>
<td>显示行数</td>
</tr>
</tbody></table>
<h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>ps</td>
<td>查看进程PID</td>
</tr>
<tr>
<td>ps -ef</td>
<td>查看Linux系统下所有运行的进程的详细信息</td>
</tr>
<tr>
<td>ps -ef &#124; grep + 关键字</td>
<td>查看指定关键字的进程的详细信息</td>
</tr>
<tr>
<td>top -p + PID</td>
<td>查看指定PID进程的资源使用情况</td>
</tr>
<tr>
<td>top -Hp + PID</td>
<td>查看指定PID进程中的所有线程的使用情况</td>
</tr>
<tr>
<td>kill -9 PID</td>
<td>强制杀死进程号为PID的进程</td>
</tr>
</tbody></table>
<h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>ping</td>
<td>检测host地址或者域名代表的主机是否可达</td>
</tr>
<tr>
<td>ifconfig</td>
<td>查看当前主机的所有网卡以及工作状态</td>
</tr>
<tr>
<td>netstat</td>
<td>查看当前主机的tcp端口使用的情况，服务端的情况</td>
</tr>
<tr>
<td>netstat -tanp</td>
<td>查看tcp，发送缓冲区等数据</td>
</tr>
<tr>
<td>netcat</td>
<td>可以模拟实现一个tcp/udp服务器客户端</td>
</tr>
<tr>
<td>netcat -l host port</td>
<td>模拟实现一个可以收发数据的TCP服务器</td>
</tr>
<tr>
<td>netcat host port</td>
<td>模拟实现一个可以收发数据的TCP客户端</td>
</tr>
<tr>
<td>tcpdump</td>
<td>在Linux上非常实用的抓包工具</td>
</tr>
<tr>
<td>tcpdump -i [网卡名称] host [ip地址] port [端口号]</td>
<td>验证TCP三次握手，四次挥手</td>
</tr>
<tr>
<td>telnet ip地址 port端口号</td>
<td>一个简单的TCP客户端，模拟远程登录</td>
</tr>
<tr>
<td>curl + url地址</td>
<td>开发javaweb的时候，模拟浏览器连接http服务器</td>
</tr>
<tr>
<td>curl -v url地址</td>
<td>可以把模拟的浏览器客户端和http服务器通信的细节全部输出</td>
</tr>
</tbody></table>
<h1 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h1><p>1.find搜索:指定目录下搜索文件速度较慢</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find / -name &quot;Test.java&quot;</span><br><span class="line">//在根目录下递归查找Test.java</span><br><span class="line"></span><br><span class="line">find / -name &quot;Test*&quot;</span><br><span class="line">//在根目录下递归查找Test开头的所有文件</span><br><span class="line"></span><br><span class="line">find / -iname &quot;Test*&quot;</span><br><span class="line">//忽略大小写在根目录下递归查找Test开头的所有文件</span><br></pre></td></tr></table></figure>
<p>2.locate 搜索的文件名称（支持通配符）<br>搜索文件，可以使用sudo updatedb，手动更新linux系统记录的文件数据库，加速locate文件查找，该种搜索方法最近安装的内容可能无法找到，但是查询的速度很快。<br>3.whereis + 文件名<br>不是用来搜索文件用的，主要是用来搜索系统环境变量配置的路径下的可执行文件<br>4.grep<br>grep用来检索文件内容</p>
<h1 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h1><p>查看日志文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tail -f xxx.log                查看日志的末尾，一般用来动态查看日志</span><br><span class="line">tail -n 100  xxx.log           查看后100行日志</span><br></pre></td></tr></table></figure>
<p>批量替换文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sed -i &#x27;s/^Str/String/&#x27; replace.java</span><br><span class="line">将replace.java文件中的Str替换为String</span><br><span class="line"></span><br><span class="line">sed -i &#x27;s/\.$/\;/&#x27; replace.java</span><br><span class="line">将replace.java文件中的以.结尾的替换为；     $代表以什么结尾</span><br><span class="line"></span><br><span class="line">sed -i &#x27;s/Jack/me/g&#x27; replace.java</span><br><span class="line">将replace.java文件中Jack替换为me，加g的原因是可以替换一行的中的多个，如果不加则只会替换该行中的第一个Jack</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title>正则表达式</title>
    <url>/2021/11/29/%E5%B7%A5%E5%85%B7/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="正则表达式语法"><a href="#正则表达式语法" class="headerlink" title="正则表达式语法"></a>正则表达式语法</h1><p>注意：要正确使用转义字符。java：\\，其他\。</p>
<span id="more"></span>
<h2 id="限定符"><a href="#限定符" class="headerlink" title="限定符"></a>限定符</h2><table>
<thead>
<tr>
<th>符号</th>
<th>解释</th>
<th>示例</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>*</td>
<td>克林闭包</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>+</td>
<td>正闭包</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>?</td>
<td>可重复0次或1次</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>{n}</td>
<td>只能输入n个字符</td>
<td>[abcd]{3}</td>
<td>abcd四字母组成的3长度字符串</td>
</tr>
<tr>
<td>{n,}</td>
<td>至少n个字符</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>{n,m}</td>
<td>至少n个，至多m个字符</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>?</td>
<td>非贪婪匹配</td>
<td>\\d+?</td>
<td>输出尽可能短的数字串，默认是输出尽可能长的</td>
</tr>
</tbody></table>
<h2 id="选择匹配符"><a href="#选择匹配符" class="headerlink" title="选择匹配符"></a>选择匹配符</h2><table>
<thead>
<tr>
<th>符号</th>
<th>解释</th>
<th>示例</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>|</td>
<td>匹配”|”之前或之后的内容</td>
<td>ab|cd</td>
<td>ab或cd</td>
</tr>
</tbody></table>
<h2 id="分组组合和反向引用符"><a href="#分组组合和反向引用符" class="headerlink" title="分组组合和反向引用符"></a>分组组合和反向引用符</h2><table>
<thead>
<tr>
<th>符号</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>(pattern)</td>
<td>非命名捕获分组，使用index查询</td>
</tr>
<tr>
<td>(?&lt;name&gt;pattern)</td>
<td>命名捕获分组，可以使用组名或index查询</td>
</tr>
<tr>
<td>(?:pattern)</td>
<td>匹配但不捕获分组index，无法靠index查找。作用：apple(?:|s)=(apple|apples)</td>
</tr>
<tr>
<td>(?=pattern)</td>
<td>匹配但不捕获分组信息。作用：win(?=7|8|9),会找到win后面是7，8，9的win，但不会匹配win10的win</td>
</tr>
<tr>
<td>(?!pattern)</td>
<td>该表达式与上一个式子作用相反。</td>
</tr>
</tbody></table>
<h2 id="字符匹配符"><a href="#字符匹配符" class="headerlink" title="字符匹配符"></a>字符匹配符</h2><table>
<thead>
<tr>
<th>符号</th>
<th>解释</th>
<th>示例</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>[]</td>
<td>可接收的字符列表</td>
<td>[efgh]</td>
<td>efgh中的任意一个字符</td>
</tr>
<tr>
<td>[^]</td>
<td>不接收的字符列表</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>-</td>
<td>连字符</td>
<td>A-Z</td>
<td>A—Z间的的所有字符</td>
</tr>
<tr>
<td>.</td>
<td>匹配除\n以外的任何字符</td>
<td>a..b</td>
<td>a开头，b结尾，4长度字符</td>
</tr>
<tr>
<td>\\d</td>
<td>匹配单个数字，相当[0-9]</td>
<td>\\d{3}(\\d)?</td>
<td>包含三个或四个数字的字符串</td>
</tr>
<tr>
<td>\\D</td>
<td>匹配单个非数字</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>\\w</td>
<td>匹配单个数字，字母</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>\\W</td>
<td>匹配单个非数字且非字母的字符</td>
<td>-</td>
<td>-</td>
</tr>
</tbody></table>
<h2 id="定位符"><a href="#定位符" class="headerlink" title="定位符"></a>定位符</h2><table>
<thead>
<tr>
<th>符号</th>
<th>解释</th>
<th>示例</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>^</td>
<td>指定起始符</td>
<td>^[0-9]+[a-z]*</td>
<td>以至少一个数字开头，后面任意长度字母的字符串</td>
</tr>
<tr>
<td>$</td>
<td>指定结束符</td>
<td>^[0-9]\-[a-z]+$</td>
<td>以数字开头接-并且至少一个字母结尾的字符串</td>
</tr>
<tr>
<td>\\b</td>
<td>匹配目标字符串的边界</td>
<td>han\\b</td>
<td>空格前或结尾的都为han</td>
</tr>
<tr>
<td>\\B</td>
<td>匹配目标字符串的非边界</td>
<td>han\\B</td>
<td>han出现在非边界的位置</td>
</tr>
</tbody></table>
<h2 id="反向引用"><a href="#反向引用" class="headerlink" title="反向引用"></a>反向引用</h2><p>使用括号捕获的内容可以在这个括号后被重复使用，从而写出比较实用的匹配模式。<br>内部反向引用：\\分组号。外部反向引用：$分组号。(用于外部函数中的调用)<br>例：(\\d)(\\d)\\2\\1,这个表达式可以匹配一个四字符长度的回文字符串。</p>
<h1 id="java中的正则表达式"><a href="#java中的正则表达式" class="headerlink" title="java中的正则表达式"></a>java中的正则表达式</h1><h2 id="正则表达式的使用"><a href="#正则表达式的使用" class="headerlink" title="正则表达式的使用"></a>正则表达式的使用</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//创建一个pattern对象</span><br><span class="line">new Pattern.complie(&quot;正则表达式&quot;);</span><br><span class="line">//创建一个匹配对象</span><br><span class="line">new pattern.matcher(文本);</span><br><span class="line">//开始循环匹配,find返回找到的内容</span><br><span class="line">while(matcher.find())&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<!-- more -->
<h2 id="matcher-group"><a href="#matcher-group" class="headerlink" title="matcher.group()"></a>matcher.group()</h2><p>group(0)中存放找到的所有内容的index。<br>group(n)中存放第n个()中的内容的index。</p>
<h2 id="常用类"><a href="#常用类" class="headerlink" title="常用类"></a>常用类</h2><table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>Pattern.matches(正则表达式,匹配内容)</td>
<td>返回一个布尔值表示是否整体匹配</td>
</tr>
<tr>
<td>matcher.start()</td>
<td>返回匹配字符串的首字符index</td>
</tr>
<tr>
<td>matcher.end()</td>
<td>返回匹配字符串末尾字符index+1</td>
</tr>
<tr>
<td>matcher.matches</td>
<td>返回一个布尔值表示是否整体匹配</td>
</tr>
<tr>
<td>matcher.replaceAll(替换内容)</td>
<td>将匹配的字符串替换为输入的替换内容。注意：原本的文本内容不会发生变换，只是返回一个被替换的字符串</td>
</tr>
<tr>
<td>matcher.replaceAll(被替换内容,替换内容)</td>
<td>将匹配到的内容的被替换内容替换为替换内容</td>
</tr>
</tbody></table>
<h2 id="String类中的正则表达式"><a href="#String类中的正则表达式" class="headerlink" title="String类中的正则表达式"></a>String类中的正则表达式</h2><p>String类有部分方法是支持正则表达式的。<br>str.matches(正则表达式) 判断是否完全匹配<br>str.split(正则表达式)依据正则表达进行分割<br>str.replaceAll(正则表达式,替换内容)将与正则表达匹配的内容替换为替换内容</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title>JDBC</title>
    <url>/2021/11/21/%E7%AC%94%E8%AE%B0/JDBC/</url>
    <content><![CDATA[<h1 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h1><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">//前置工作，在项目下创建一个文件夹，将mysql.jar文件拷贝到该目录下</span><br><span class="line">      //点击<span class="keyword">add</span> <span class="keyword">to</span> project加入到项目中。实现driver的抽象类。</span><br><span class="line">      // <span class="number">1</span>注册驱动</span><br><span class="line">      Driver driver = <span class="built_in">new</span> Driver();</span><br><span class="line">      //<span class="number">2</span>得到连接,mysql连接本质是socket连接</span><br><span class="line">      String url = &quot;jdbc:mysql://主机ip:端口/数据库名&quot;;</span><br><span class="line">      Properties properties = <span class="built_in">new</span> Properties();</span><br><span class="line">      properties.setProperty(&quot;user&quot;,&quot;用户名&quot;);</span><br><span class="line">      properties.setProperty(&quot;password&quot;,&quot;密码&quot;);</span><br><span class="line">      <span class="keyword">Connection</span> <span class="keyword">connect</span> = driver.<span class="keyword">connect</span>(url, properties);//这个<span class="keyword">connect</span>等同于socket</span><br><span class="line">      //<span class="number">3</span>执行<span class="keyword">sql</span></span><br><span class="line">      String <span class="keyword">sql</span> = &quot;要执行的sql语句&quot;;</span><br><span class="line">      //生成语法的执行器,返回值为更改的行数</span><br><span class="line">      <span class="keyword">Statement</span> <span class="keyword">statement</span> = <span class="keyword">connect</span>.createStatement();</span><br><span class="line">      <span class="type">int</span> <span class="keyword">rows</span> = <span class="keyword">statement</span>.executeUpdate(<span class="keyword">sql</span>);//只能存放dlm语句，<span class="keyword">select</span>用Query</span><br><span class="line">      //关闭连接资源</span><br><span class="line">      <span class="keyword">statement</span>.<span class="keyword">close</span>();</span><br><span class="line">      <span class="keyword">connect</span>.<span class="keyword">close</span>();</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h1 id="数据库连接方式"><a href="#数据库连接方式" class="headerlink" title="数据库连接方式"></a>数据库连接方式</h1><p>上面的方法可以连接数据库，但问题是这是一个静态加载，灵活性差，依赖性强。<br>可以使用反射机制取得driver，实现静态加载。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">        Class clazz = <span class="module-access"><span class="module"><span class="identifier">Class</span>.</span></span><span class="keyword">for</span><span class="constructor">Name(<span class="string">&quot;驱动路径&quot;</span>)</span>;</span><br><span class="line"><span class="comment">//下面这句话是可以不写的，在dirver中有一段静态代码，只要类加载后，会自动帮助注册驱动</span></span><br><span class="line">        Driver dirver = (Dirver)clazz.<span class="keyword">new</span><span class="constructor">Instance()</span>;</span><br></pre></td></tr></table></figure>
<p>还可以使用drivermanager来获取connect，但这个方法是静态同步调用，会造成低效率和死锁，不再展开。</p>
<h2 id="最常用的数据库连接方式："><a href="#最常用的数据库连接方式：" class="headerlink" title="最常用的数据库连接方式："></a>最常用的数据库连接方式：</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//mysql驱动5.1.6后这句类加载也可以省略，会自动调用。建议写上，防止多个驱动存在。</span><br><span class="line">//最省略的写法就是只要将驱动放入项目中，然后直接取得connection即可。</span><br><span class="line">Class clazz = Class.forName(&quot;驱动路径&quot;);</span><br><span class="line">//这里可以直接将这些信息存储到properties文件中，通过IO流取出。</span><br><span class="line">//new properties;</span><br><span class="line">//properties.load(new FileInpitStream(文件路径));</span><br><span class="line">String url = &quot;jdbc:mysql://主机ip:端口/数据库名&quot;;</span><br><span class="line">String user = </span><br><span class="line">String password = </span><br><span class="line">Connection connect = Drivermanager.getConnection(url,user,password);</span><br></pre></td></tr></table></figure>
<h1 id="ResultSet"><a href="#ResultSet" class="headerlink" title="ResultSet"></a>ResultSet</h1><p>在执行select语句后，会返回一个类似于迭代器的resultset。</p>
<figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ResultSet</span> <span class="keyword">resultset</span> = statement.executeQuery(<span class="string">&quot;查询语句&quot;</span>);</span><br><span class="line"><span class="comment">//next为向下移动，还可以使用previous向上移动</span></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">resultset</span>.next())&#123;</span><br><span class="line">        <span class="comment">//get方法中既可以填写索引，也可以填写列名。</span></span><br><span class="line">    int id = <span class="keyword">resultset</span>.getInt(<span class="number">1</span>);<span class="comment">//取出第一列，取出类型为int</span></span><br><span class="line">    <span class="params">...</span><span class="params">...</span></span><br><span class="line">&#125;</span><br><span class="line">resulset.close;</span><br><span class="line">statement.close();</span><br><span class="line">connect.close();</span><br></pre></td></tr></table></figure>
<h1 id="Statement"><a href="#Statement" class="headerlink" title="Statement"></a>Statement</h1><h2 id="执行SQl语句的三种渠道："><a href="#执行SQl语句的三种渠道：" class="headerlink" title="执行SQl语句的三种渠道："></a>执行SQl语句的三种渠道：</h2><p>1.Statement[存在SQl注入风险(注入非法的SQL语句攻击数据库)，一般不使用]。<br>2.PreparedStatement[预处理]。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">//PreparedStatement的使用方式</span></span><br><span class="line">String sql = <span class="string">&quot;select name, pwd from admin where name = ? and pwd = ?&quot;</span><span class="comment">//?相当于占位符</span></span><br><span class="line"><span class="comment">//preparedStatement有别于Statement，在创建时就要输入sql语句</span></span><br><span class="line">PreparedStatement preparedStatement = connection.prepared<span class="constructor">Statement(<span class="params">sql</span>)</span>;</span><br><span class="line">preparedStatement.set<span class="constructor">String(1,<span class="params">admin_name</span>)</span>;<span class="comment">//对应问号的位置，admin_name中存储接收的用户名</span></span><br><span class="line">preparedStatement.set<span class="constructor">String(2,<span class="params">admin_pwd</span>)</span>;</span><br><span class="line">ResultSet resultset = preparedStatement.execute<span class="constructor">Query()</span>;</span><br></pre></td></tr></table></figure>
<p>3.CallableStatement[存储过程]。</p>
<h2 id="Statement接口"><a href="#Statement接口" class="headerlink" title="Statement接口"></a>Statement接口</h2><p>executeUpdate(sql)执行dml语句，返回影响的行数。<br>executeQuery(sql)执行查询，返回ResultSet。<br>execute(sql)执行任意语句，返回布尔值，用于不需要返回行数或者结果集的语句。</p>
<h1 id="JDBCUtils的开发"><a href="#JDBCUtils的开发" class="headerlink" title="JDBCUtils的开发"></a>JDBCUtils的开发</h1><p>因为在JDBC过程中，数据库的连接和释放资源属于高重复度内容，因此一般将这些内容进行封装。</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDBCUtils</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">String</span> user;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">String</span> password;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">String</span> url;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">String</span> driver;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用静态代码块初始化</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Properties properties = <span class="keyword">new</span> <span class="type">Properties</span>();</span><br><span class="line">            properties.load(<span class="keyword">new</span> <span class="type">FileInputStream</span>(<span class="string">&quot;文件路径&quot;</span>));</span><br><span class="line">            user = properties.getProperty(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">            password = properties.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">            url = properties.getProperty(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">            driver = properties.getProperty(<span class="string">&quot;driver&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">//1.将编译异常转化为运行异常</span></span><br><span class="line">            <span class="comment">//2.调用者可以选择捕获改异常，也可以选择默认操作</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//连接数据库</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Connection getConnection()&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> DriverManager.getConnection(url,user,password);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//关闭资源</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> void close(ResultSet resultSet, Statement statement, Connection connection)&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (resultSet != <span class="literal">null</span>)&#123;</span><br><span class="line">                resultSet.close();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (statement != <span class="literal">null</span>)&#123;</span><br><span class="line">                statement.close();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (connection != <span class="literal">null</span>)&#123;</span><br><span class="line">                connection.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>首先要调用Connection.setAutoCommit(false),取消自动提交事务。<br>然后再使用Connection.commit()手动提交，使用Connection.rollback回滚事务(一般写在catch中)。</p>
<h1 id="批处理"><a href="#批处理" class="headerlink" title="批处理"></a>批处理</h1><p>启用批处理需要修改url语句。<br>String url = “jdbc:mysql://主机ip:端口/数据库名？rewriteBatchedStatements = true”;<br>preparedStatement.addBatch();将sql语句加入到集合中。<br>preparedStatement.executeBatch();批量执行sql语句。<br>preparedStatement.clearBatch();清空集合。</p>
<h1 id="传统连接方式的弊端"><a href="#传统连接方式的弊端" class="headerlink" title="传统连接方式的弊端"></a>传统连接方式的弊端</h1><p>1.每次向数据库建立连接时都要加载connection，再验证。<br>2.如果程序异常没能正常关闭会导致内存泄露。<br>3.不能控制创建的连接数量，连接过多会导致数据库崩溃。</p>
<h1 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h1><p>给定规定的连接口，所有连接接入走连接池，并排队，由连接池统一管理。<br>实现DataSource接口。</p>
<h2 id="C3P0"><a href="#C3P0" class="headerlink" title="C3P0"></a>C3P0</h2><p>类名：ComboPooledDataSource</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//给予连接池需要的信息，让连接池创建接向数据库的连接</span><br><span class="line">new ComboPooledDataSource();</span><br><span class="line">comboPooledDataSource.setDriverClass(驱动路径);</span><br><span class="line">comboPooledDataSource.setJdbcUrl(url);</span><br><span class="line">comboPooledDataSource.setUser(user);</span><br><span class="line">comboPooledDataSource.setPassword(password);</span><br><span class="line">//设置连接池的初始连接数和最大连接数</span><br><span class="line">comboPooledDataSource.setInitialPoolSize(int);</span><br><span class="line">comboPooledDataSource.setMaxPoolSize(int);</span><br><span class="line">//从连接池取得连接,注意这里的connection不是由DriverManager创建的，所以close方法也不同。</span><br><span class="line">Connection connection = comboPooledDataSource.getConnection();</span><br><span class="line">//这里的关闭并不是关闭了连接，而是把连接还给了连接池</span><br><span class="line">connection.close();</span><br></pre></td></tr></table></figure>
<p>除了上面这种连接方式，还可以将这些信息统一写在c3p0的config文件中，初始化时直接使用。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="constructor">ComboPooledDataSource(<span class="params">cofig</span>文件的数据源名称)</span>;</span><br></pre></td></tr></table></figure>
<h2 id="Druid-负责建立连接"><a href="#Druid-负责建立连接" class="headerlink" title="Druid(负责建立连接)"></a>Druid(负责建立连接)</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Properties properties = new Properties();</span><br><span class="line">properties.load(new FileInputStream(&quot;德鲁伊需要的配置文件&quot;));</span><br><span class="line">DataSource dataSource = DruidDataSourceFactory.createDataSource(properties);</span><br><span class="line">Connection connection = dataSource.getConnection();</span><br><span class="line">connection.close();</span><br></pre></td></tr></table></figure>
<p>这之后就可以基于druid重写JDBCUtils。</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="keyword">class</span> JDBCUtilsByDruid&#123;</span><br><span class="line">    private static DataSource dataSource;</span><br><span class="line">    static &#123;</span><br><span class="line">        Properties properties = <span class="built_in">new</span> Properties();</span><br><span class="line">        try &#123;</span><br><span class="line">            //废弃这个方法改用下面的新方法加载配置文件，这个加载方法会在web层出现空指针异常，原因不明</span><br><span class="line">            //properties.<span class="keyword">load</span>(<span class="built_in">new</span> FileInputStream(&quot;配置文件&quot;));</span><br><span class="line">            InputStream inputStream = JDBCUtilsByDruid.<span class="keyword">class</span>.getClassLoader().getResourceAsStream(&quot;book.properties&quot;);</span><br><span class="line">            properties.<span class="keyword">load</span>(inputStream);</span><br><span class="line">            dataSource = DruidDataSourceFactory.createDataSource(properties);</span><br><span class="line">        &#125; catch (<span class="keyword">Exception</span> e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">public</span> static <span class="keyword">Connection</span> getConnection() throws SQLException &#123;</span><br><span class="line">        <span class="keyword">return</span> dataSource.getConnection();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">public</span> static <span class="type">void</span> <span class="keyword">close</span>(ResultSet resultSet, <span class="keyword">Statement</span> <span class="keyword">statement</span>, <span class="keyword">Connection</span> <span class="keyword">connection</span>)&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            <span class="keyword">if</span> (resultSet != <span class="keyword">null</span>)&#123;</span><br><span class="line">                resultSet.<span class="keyword">close</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">statement</span> != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">statement</span>.<span class="keyword">close</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">connection</span> != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">connection</span>.<span class="keyword">close</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (SQLException e) &#123;</span><br><span class="line">            throw <span class="built_in">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="ApDBUtils-负责存储收到的信息"><a href="#ApDBUtils-负责存储收到的信息" class="headerlink" title="ApDBUtils(负责存储收到的信息)"></a>ApDBUtils(负责存储收到的信息)</h1><p>问题1：目前，当需要对resultset进行操作时，connection不能关闭，但连接池给的连接是有限的。<br>问题2：结果集只能使用一次。<br>问题3：结果集取得信息的方法并不方便。<br>解决办法：创建一个类，每行的数据创建为一个对象，使用List连接起来。<br>这个类就是下面的Actor.class,也是俗称的javabean。<br>向项目中加入DBUtils的包</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Connection connection = JDBCUtilsByDruid.getConnection();</span><br><span class="line">QueryRunner queryRunner = new QueryRunner();</span><br><span class="line">//select</span><br><span class="line">&#123;</span><br><span class="line">    //query方法就是执行一个sql语句并返回一个包含结果集的list</span><br><span class="line">    //最后的1是指sql语句中？要赋予的值</span><br><span class="line">    //使用这个办法不需要关闭结果集，在这句话的源码中，最后会自动关闭resultset和preparedStatement。</span><br><span class="line">    List&lt;Actor&gt; list =</span><br><span class="line">            queryRunner.query(connection,sql,new BeanListHandler&lt;&gt;(Actor.class),？赋值);</span><br><span class="line">    //单行查询</span><br><span class="line">    Actor actor = queryRunner.query(connection,sql,new BeanHandler&lt;&gt;(Actor.class),？赋值);</span><br><span class="line">    //单行单列</span><br><span class="line">    Object o = queryRunner.query(connection,sql,new ScalarHandler(),？赋值);</span><br><span class="line">&#125;</span><br><span class="line">//dml语句</span><br><span class="line">&#123;</span><br><span class="line">    int affectedRow = queryRunner.update(connection,sql,？赋值);</span><br><span class="line">&#125;</span><br><span class="line">DBUtilsByDruid.close(null,null,connection);</span><br></pre></td></tr></table></figure>
<h1 id="BasicDao"><a href="#BasicDao" class="headerlink" title="BasicDao"></a>BasicDao</h1><p>目前，JDBCUtilsByDruid已经实现了对Druid的封装，但DBUtils的操作依然繁琐，所以需要将<br>这整个操作进行封装，这样整个操作就简洁起来了。为了操作方便，对每个表制作一个对应的Dao。<br>在Dao的方法开发中，并不建议使用静态方法，因为这样你不再能保证connection不被两个以上的<br>线程同时调用，造成线程混乱。<br>另外BasicDao是基于泛型制定的方法，要想静态化只能将其下所有子类做静态化。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//开发BasicDao，作为其它类的父类，子类主要负责一些额外操作和确定类型</span><br><span class="line">public class BasicDao&lt;T&gt;&#123;</span><br><span class="line">    private QueryRunner qr = new QueryRunner();</span><br><span class="line">    //开发通用的dml方法，针对任意的表</span><br><span class="line">    public int update(String sql,Object...parameters)&#123;</span><br><span class="line">        //因为建立连接需要在try—catch-finally操作中，为了在finally关闭</span><br><span class="line">        //在外面先建立connection</span><br><span class="line">        Connection connection = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            connection = JDBCUtilsByDruid.getConnection();</span><br><span class="line">            int affectedRow = qr.update(connection,sql,parameters);</span><br><span class="line">            return affectedRow;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            throw new RuntimeException(e);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            //因为使用了DBUtils工具，所以只需要关闭(交还)connection即可</span><br><span class="line">            JDBCUtilsByDruid.close(null,null,connection);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //返回多行数据，针对任意的表</span><br><span class="line">    public List&lt;T&gt; queryMultiply(String sql,Class&lt;T&gt; clazz,Object... parameters)&#123;</span><br><span class="line">        Connection connection = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            connection = JDBCUtilsByDruid.getConnection();</span><br><span class="line">            List&lt;T&gt; list =</span><br><span class="line">                    qr.query(connection,sql,new BeanListHandler&lt;T&gt;(clazz),parameters);</span><br><span class="line">            return list;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            throw new RuntimeException(e);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            //因为使用了DBUtils工具，所以只需要关闭(交还)connection即可</span><br><span class="line">            JDBCUtilsByDruid.close(null,null,connection);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //返回单行数据</span><br><span class="line">    public T querySingle(String sql,Class&lt;T&gt; clazz,Object... parameters)&#123;</span><br><span class="line">        Connection connection = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            connection = JDBCUtilsByDruid.getConnection();</span><br><span class="line">            return qr.query(connection,sql,new BeanHandler&lt;T&gt;(clazz),parameters);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            throw new RuntimeException(e);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            //因为使用了DBUtils工具，所以只需要关闭(交还)connection即可</span><br><span class="line">            JDBCUtilsByDruid.close(null,null,connection);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //返回单个数据</span><br><span class="line">    public Object queryScalar(String sql,Object... parameters)&#123;</span><br><span class="line">        Connection connection = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            connection = JDBCUtilsByDruid.getConnection();</span><br><span class="line">            return qr.query(connection,sql,new ScalarHandler(),parameters);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            throw new RuntimeException(e);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            //因为使用了DBUtils工具，所以只需要关闭(交还)connection即可</span><br><span class="line">            JDBCUtilsByDruid.close(null,null,connection);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//使用具体表对应的类型继承BasicDao</span><br><span class="line">public class ActorDao extends BasicDao&lt;Actor&gt;&#123;</span><br><span class="line">        //这里根据业务需求写特有方法</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title>javaweb</title>
    <url>/2021/11/28/%E7%AC%94%E8%AE%B0/javaweb/</url>
    <content><![CDATA[<h1 id="html和css"><a href="#html和css" class="headerlink" title="html和css"></a>html和css</h1><span id="more"></span>
<h2 id="html常用标签"><a href="#html常用标签" class="headerlink" title="html常用标签"></a>html常用标签</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;br/&gt;换行</span><br><span class="line">&lt;hr/&gt;水平线</span><br><span class="line">&lt;front&gt;&lt;/front&gt;修改文本大小，颜色，样式(color,face,size)</span><br><span class="line">&lt;h1-6&gt;1-6标题(align=对齐方式)</span><br><span class="line">&lt;a&gt;&lt;/a&gt;超链接(href=域名,target=选择发生跳转的页面)</span><br><span class="line">&lt;ul&gt;&lt;/ul&gt;无序列表</span><br><span class="line">&lt;li&gt;&lt;/li&gt;列表项</span><br><span class="line">&lt;img/&gt;图片(src=路径,width=宽,height=高,border=边框宽度,alt=图片消失时提示)</span><br><span class="line">&lt;ifanme&gt;&lt;/ifanme&gt;子页面(src=子页面文件路径,width,height,name用于超链接选择target)</span><br><span class="line">文本</span><br><span class="line">&lt;div&gt;&lt;/div&gt;默认独占一行</span><br><span class="line">&lt;span&gt;&lt;/span&gt;长度为封装数据的长度</span><br><span class="line">&lt;p&gt;&lt;/p&gt;上下各占一行</span><br><span class="line">表格</span><br><span class="line">&lt;table&gt;&lt;/table&gt;表格(align,border,width,height,cellspacing=单元格间距)</span><br><span class="line">&lt;tr&gt;&lt;/tr&gt;表格行</span><br><span class="line">&lt;th&gt;&lt;/th&gt;居中加粗的单元格</span><br><span class="line">&lt;td&gt;&lt;/td&gt;单元格(align,colspan=行占用单元格数量,rowspan=列占用单元格数量)</span><br><span class="line">&lt;b&gt;&lt;/b&gt;加粗</span><br><span class="line">表单</span><br><span class="line">&lt;from&gt;&lt;/form&gt;表单(action=提交的服务器地址,method=get/post提交方式)</span><br><span class="line">&lt;input/&gt;输入栏(type=输入类型,value=默认值)</span><br><span class="line">&lt;input/&gt;单选框(type=&quot;radio&quot;,name=分组)</span><br><span class="line">&lt;select&gt;&lt;/select&gt;下拉列框</span><br><span class="line">&lt;option&gt;&lt;/option&gt;选项</span><br><span class="line">&lt;textarea&gt;&lt;/textarea&gt;多行文本输入框(row,cols= 每行字数)</span><br><span class="line">&lt;input type=&quot;reset&quot; value=&quot;重置&quot;/&gt;</span><br><span class="line">&lt;input type=&quot;sbmit&quot; value=&quot;提交&quot;/&gt;</span><br><span class="line">表单提交时，数据没发给服务器的三种情况：</span><br><span class="line">1.没有使用name命名</span><br><span class="line">2.单选、复选、下拉列表的选项都需要添加value属性</span><br><span class="line">3.表单项不在form中</span><br></pre></td></tr></table></figure>
<h2 id="常用字符实体"><a href="#常用字符实体" class="headerlink" title="常用字符实体"></a>常用字符实体</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">空格：&amp;nbsp;</span><br><span class="line">小于号：&amp;lt;</span><br><span class="line">大于号：&amp;gt;</span><br><span class="line">双引号：&amp;quot;</span><br><span class="line">单引号：&amp;apos;</span><br></pre></td></tr></table></figure>
<h2 id="css和html的结合"><a href="#css和html的结合" class="headerlink" title="css和html的结合"></a>css和html的结合</h2><p>1.在标签的style属性上设置”key:value value”,修改标签样式<br>2.在head标签中使用style标签定义，style标签中使用css语法。<br>3.把css样式写为一个文件，通过link标签引入。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;文件路径&quot;/&gt;</span><br></pre></td></tr></table></figure>
<h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><p>1.标签选择器: 标签名{}<br>2.id选择器： #id{}<br>3.class选择器： 标签名.class{}<br>4.组合选择器<br>class选择器与id选择器的区别：id选择器的值是唯一的，class选择器可以多标签公用。</p>
<h1 id="js"><a href="#js" class="headerlink" title="js"></a>js</h1><h2 id="js和html代码的结合"><a href="#js和html代码的结合" class="headerlink" title="js和html代码的结合"></a>js和html代码的结合</h2><p>1.在head或者body标签中使用script标签写js代码<br>2.使用script标签引入js文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;path&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="与java语法不同部分"><a href="#与java语法不同部分" class="headerlink" title="与java语法不同部分"></a>与java语法不同部分</h2><p>赋值使用var对任意类型赋值。<br>==与===，前者只比较字面值，后者比较数值与类型。<br>逻辑运算与c相同，所有数值可做布尔类型变量。0，null，undefined，””为false。<br>&amp;&amp;运算，当表达式全为真时返回最后一个表达式的值，有假时返回第一个为假的表达式值。<br>||运算，当表达式全为假时返回最后一个表达式的值，有真时返回第一个为真的表达式值。<br>数组中可以放类型不同的数据，且长度可变。 var arr = [];<br>函数定义：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function 函数名(形参)&#123;&#125;</span><br><span class="line">var 函数名 = function(形参)&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>函数不允许重载，只会覆盖。<br>所有js函数都有隐藏参数arguments，等于java的Object…，所有参数都在他的数组中。<br>对象的定义方法与c语言结构体类似，不同的是可以在其中定义函数。</p>
<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p>事件分为静态注册与动态注册。<br>onload 加载完成事件(body)<br>onclick 单机事件(button)<br>onblur 失去焦点事件(input)<br>onchange 内容改变事件(select,input)<br>onsubmit 提交事件(form)(通过返回false阻止提交事件)</p>
<h2 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h2><p>document文件通过树结构管理所有html中的对象(所有标签对象化)<br>document结构及方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var document&#123;</span><br><span class="line">	var id = ;</span><br><span class="line">	var tagName= ;</span><br><span class="line">	var parentNode= ;</span><br><span class="line">	var children= ;</span><br><span class="line">	var value= ;</span><br><span class="line">	var tpye= ;</span><br><span class="line">	var innerHTML= ;(起始标签到终止标签的中间内容)</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line">document.getElementById()</span><br><span class="line">//下面的两种返回的是集合，操作与数组相同</span><br><span class="line">document.getElementsByName()</span><br><span class="line">document.getElementsByTagName(标签名)</span><br><span class="line">document.createElement(标签名)</span><br></pre></td></tr></table></figure>
<p>因为语句是从上往下执行，非函数内取得dom对象时可能对象还未创建，要想在外部取得，一般置于window.onload = function(){}中。</p>
<h2 id="正则表达式对文本的验证"><a href="#正则表达式对文本的验证" class="headerlink" title="正则表达式对文本的验证"></a>正则表达式对文本的验证</h2><p><a href="https://390991450.github.io/2021/11/29/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/#more">正则表达的规则</a><br>正则表达式判断用户名是否合法案例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;html lang=&quot;zh_CN&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;标题&lt;/title&gt;</span><br><span class="line">    &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">        function onclickFun()&#123;</span><br><span class="line">            var usernameObj = document.getElementById(&quot;username&quot;);</span><br><span class="line">            var userText = usernameObj.value;</span><br><span class="line">            var patt = /^\w&#123;5,12&#125;$/;</span><br><span class="line">            var spanObj = document.getElementById(&quot;tips&quot;);</span><br><span class="line">            if (patt.test(userText))&#123;</span><br><span class="line">                spanObj.innerHTML = &quot;输入正确&quot;</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                spanObj.innerHTML = &quot;请输入正确的用户名&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    用户名：&lt;input type=&quot;text&quot; id=&quot;username&quot;/&gt;</span><br><span class="line">&lt;!--这个属于静态注册--&gt;</span><br><span class="line">    &lt;span id=&quot;tips&quot; style=&quot;color: red;&quot;&gt;&lt;/span&gt;</span><br><span class="line">&lt;!--    这个属于动态注册--&gt;</span><br><span class="line">    &lt;button onclick=&quot;onclickFun()&quot;&gt;校验&lt;/button&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<h2 id="节点的常用方法或属性"><a href="#节点的常用方法或属性" class="headerlink" title="节点的常用方法或属性"></a>节点的常用方法或属性</h2><table>
<thead>
<tr>
<th>方法或属性</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>getElementsByTagName()</td>
<td>获取当前节点指定标签类型的子节点</td>
</tr>
<tr>
<td>appendChild(字节点)</td>
<td>添加一个字节点</td>
</tr>
<tr>
<td>childNodes</td>
<td>获取当前节点的所有子节点</td>
</tr>
<tr>
<td>firstChild</td>
<td>取得第一个字节点</td>
</tr>
<tr>
<td>lastChile</td>
<td>取得最后一个子节点</td>
</tr>
<tr>
<td>parentNode</td>
<td>取得当前父节点</td>
</tr>
<tr>
<td>nextSibling</td>
<td>取得下一个节点</td>
</tr>
<tr>
<td>previousSibling</td>
<td>取得上一个节点</td>
</tr>
<tr>
<td>className</td>
<td>获取或设置标签的class属性</td>
</tr>
<tr>
<td>innerHTML</td>
<td>获取或设置起始标签到结束标签的内容(可以有其他标签)</td>
</tr>
<tr>
<td>innerText</td>
<td>获取或设置起始标签到结束标签的文本</td>
</tr>
</tbody></table>
<h1 id="“jQuery”"><a href="#“jQuery”" class="headerlink" title="“jQuery”"></a>“jQuery”</h1><p>jQuery是一个框架，对js进行了封装，方便使用。</p>
<h2 id="核心函数"><a href="#核心函数" class="headerlink" title="核心函数"></a>核心函数</h2><p>1.传入参数为函数时：表示页面加载完成之后。相当于window.onload = function(){}<br>2.传入参数为HTML字符串时：会帮我们创建这些HTML标签插入到指定位置。$().appendto(标签);<br>3.传入参数为选择器字符串时：根据选择器样式用对应方法查询dom对象。(也可以填入组合选择器”,”表示或”.”表示且。结果顺序为页面中的顺序)<br>4.传入参数为dom时：会把这个对象转化为”jQuery”对象</p>
<h2 id="“jQuery”对象及方法"><a href="#“jQuery”对象及方法" class="headerlink" title="“jQuery”对象及方法"></a>“jQuery”对象及方法</h2><p>“jQuery”对象本质是dom对象的数组，同时封装了一系列函数。所有dom对象经由”jQuery”获得时都会被封装为”jQuery”对象，取得时使用index取得。<br>使用”jQuery”对象注册事件时不再需要使用动态或静态注册，而是通过调用”jQuery”所带的事件方法实现对象注册。</p>
<h3 id="属性获取"><a href="#属性获取" class="headerlink" title="属性获取"></a>属性获取</h3><table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>$(function(){})</td>
<td>页面加载完成事件</td>
</tr>
<tr>
<td>.val()</td>
<td>获取，修改“表单项”的value</td>
</tr>
<tr>
<td>.val([“value”])</td>
<td>指定表单项被选中的项(单复选框，下拉列表)</td>
</tr>
<tr>
<td>.html()</td>
<td>设置和获取所有dom的innerHTML</td>
</tr>
<tr>
<td>.text()</td>
<td>设置和获取所有dom的text</td>
</tr>
<tr>
<td>.attr()</td>
<td>设置和获取指定属性值(一个参数为获取，两个参数为设置，可以设置未定义属性)</td>
</tr>
<tr>
<td>.prop()</td>
<td>设置和获取指定属性值(可处理checked等会出现undefined情况的属性)</td>
</tr>
<tr>
<td>.each()</td>
<td>遍历dom对象,用this取得</td>
</tr>
</tbody></table>
<h3 id="增删改"><a href="#增删改" class="headerlink" title="增删改"></a>增删改</h3><table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>a.appendTo(b)</td>
<td>把a插入到b的子元素，成为最后一个子元素</td>
</tr>
<tr>
<td>a.prependTo(b)</td>
<td>把a插入到b的子元素，成为第一个子元素</td>
</tr>
<tr>
<td>a.insertAfter(b)</td>
<td>-</td>
</tr>
<tr>
<td>a.insertBefore</td>
<td>-</td>
</tr>
<tr>
<td>a.replaceWith(b)</td>
<td>用b替换a</td>
</tr>
<tr>
<td>a.replaceAll(b)</td>
<td>用a替换b</td>
</tr>
<tr>
<td>a.remove()</td>
<td>删除a</td>
</tr>
<tr>
<td>a.empty()</td>
<td>清空a内容</td>
</tr>
</tbody></table>
<h3 id="css样式"><a href="#css样式" class="headerlink" title="css样式"></a>css样式</h3><table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>.css(“key”,”value”…)</td>
<td>为当前”jQuery”中对象设置样式</td>
</tr>
<tr>
<td>.addClass()</td>
<td>添加样式</td>
</tr>
<tr>
<td>.removeClass()</td>
<td>移除样式</td>
</tr>
<tr>
<td>.toggleClass()</td>
<td>有就删除，没有就添加样式</td>
</tr>
<tr>
<td>.offset()</td>
<td>返回坐标(左上角作为坐标)</td>
</tr>
</tbody></table>
<h3 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h3><p>第一个参数为时间，第二个为回调函数(动画结束后调用的函数)。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>.show()</td>
<td>将隐藏显示</td>
</tr>
<tr>
<td>.hide()</td>
<td>-</td>
</tr>
<tr>
<td>.toggle()</td>
<td>-</td>
</tr>
<tr>
<td>.fadeIn()</td>
<td>淡入</td>
</tr>
<tr>
<td>.fadeOut()</td>
<td>-</td>
</tr>
<tr>
<td>.fadeTo()</td>
<td>指定时间内到指定透明度</td>
</tr>
</tbody></table>
<h3 id="事件-1"><a href="#事件-1" class="headerlink" title="事件"></a>事件</h3><table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>.click(function(){})</td>
<td>有函数为绑定单击事件，无函数为触发事件</td>
</tr>
<tr>
<td>.blur(function(){})</td>
<td>失去焦点事件</td>
</tr>
<tr>
<td>.load(function(){})</td>
<td>加载事件</td>
</tr>
<tr>
<td>.change(function(){})</td>
<td>内容改变事件</td>
</tr>
<tr>
<td>.submit(function(){})</td>
<td>提交事件</td>
</tr>
<tr>
<td>.mouseover(function(){})</td>
<td>鼠标移入事件</td>
</tr>
<tr>
<td>.mouseout(function(){})</td>
<td>鼠标移出事件</td>
</tr>
<tr>
<td>.bind(‘一个或多个事件’,function(){})</td>
<td>绑定事件，多个时用空格隔开</td>
</tr>
<tr>
<td>.one()</td>
<td>与bind使用方法相同，但每个事件只能响应一次</td>
</tr>
<tr>
<td>.unbind()</td>
<td>与bind相反，解除事件绑定</td>
</tr>
<tr>
<td>.live()</td>
<td>用于绑定事件，特点是即使这个元素是后面发生修改或才动态创建出来的也能绑定</td>
</tr>
</tbody></table>
<p>事件的冒泡<br>当子元素与父元素同时绑定一个事件时，当子元素触发事件时，会导致父元素也触发事件。<br>在子元素事件函数体内添加return false就可以防止事件的传递。<br>事件对象<br>每次事件触发时会生成一个保存信息的对象，通过在function()括号中写入变量名获取。</p>
<h3 id="选择器-1"><a href="#选择器-1" class="headerlink" title="选择器"></a>选择器</h3><table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>层级选择器</td>
<td></td>
</tr>
<tr>
<td>$(“基本选择器1 基本选择器2”)</td>
<td>获取所有在标签1中的所有标签2</td>
</tr>
<tr>
<td>$(“基本选择器1 基本选择器2”)</td>
<td>获取父标签是标签1的所有标签2</td>
</tr>
<tr>
<td>$(“基本选择器1 + 基本选择器2”)</td>
<td>获取上一个兄弟标签是标签1的所有标签2</td>
</tr>
<tr>
<td>$(“基本选择器1 ~ 基本选择器2”)</td>
<td>获取标签1后的所有同级的标签2</td>
</tr>
<tr>
<td>基本过滤选择器</td>
<td></td>
</tr>
<tr>
<td>$(“基本选择器1:first”)</td>
<td>获取第一个标签1</td>
</tr>
<tr>
<td>$(“基本选择器1:last”)</td>
<td>获取最后一个标签1</td>
</tr>
<tr>
<td>$(“基本选择器1:even”)</td>
<td>获取所有index为偶数的标签1</td>
</tr>
<tr>
<td>$(“基本选择器1:odd”)</td>
<td>-</td>
</tr>
<tr>
<td>$(“基本选择器1:eq(index)”)</td>
<td>-</td>
</tr>
<tr>
<td>$(“基本选择器1:gt(index)”)</td>
<td>获取所有index大于这个index的标签1</td>
</tr>
<tr>
<td>$(“基本选择器1:lt(index)”)</td>
<td>获取所有index小于这个index的标签1</td>
</tr>
<tr>
<td>$(“:header”)</td>
<td>获取所有标题元素</td>
</tr>
<tr>
<td>$(“:animated”)</td>
<td>获取所有在执行动画的标签</td>
</tr>
<tr>
<td>$(“基本选择器1:not(…)”)</td>
<td>相当于上面操作的取反</td>
</tr>
<tr>
<td>内容过滤选择器</td>
<td></td>
</tr>
<tr>
<td>$(“基本选择器:contains(‘str’)”)</td>
<td>获取文本内容包含str的标签</td>
</tr>
<tr>
<td>$(“基本选择器:empty”)</td>
<td>获取文本内容为空的标签</td>
</tr>
<tr>
<td>$(“基本选择器:parent”)</td>
<td>获取文本内容不为空或者有子元素的标签</td>
</tr>
<tr>
<td>$(“基本选择器1:has(选择器2)”)</td>
<td>获取子元素有标签2的所有标签1</td>
</tr>
<tr>
<td>属性过滤选择器</td>
<td></td>
</tr>
<tr>
<td>$(“基本选择器[属性名]”)</td>
<td>获取包含这个属性的标签</td>
</tr>
<tr>
<td>$(“基本选择器[属性名=’value’]”)</td>
<td>-</td>
</tr>
<tr>
<td>$(“基本选择器[属性名!=’value’]”)</td>
<td>获取不含有这属性和有这个属性但值不匹配的标签</td>
</tr>
<tr>
<td>$(“基本选择器[属性名^=’value’]”)</td>
<td>获取有这个属性，且属性值以此开始的标签</td>
</tr>
<tr>
<td>$(“基本选择器[属性名*=’value’]”)</td>
<td>获取有这个属性，且包含属性值的标签</td>
</tr>
<tr>
<td>$(“基本选择器[][]…”)</td>
<td>多重选择</td>
</tr>
<tr>
<td>表单过滤选择器</td>
<td></td>
</tr>
<tr>
<td>$(“:type类型”)</td>
<td>选择type类型符合的标签</td>
</tr>
<tr>
<td>$(“:enabled”)</td>
<td>选择可用的标签</td>
</tr>
<tr>
<td>$(“:disabled”)</td>
<td>选择不可用的标签</td>
</tr>
<tr>
<td>$(“:checked”)</td>
<td>选择所有选择的标签(单选复选框)</td>
</tr>
<tr>
<td>$(“:selected”)</td>
<td>匹配所有选择的option元素</td>
</tr>
<tr>
<td>元素筛选</td>
<td></td>
</tr>
<tr>
<td>.eq()</td>
<td>-</td>
</tr>
<tr>
<td>.first()</td>
<td>-</td>
</tr>
<tr>
<td>.last()</td>
<td>-</td>
</tr>
<tr>
<td>.filter(exp)</td>
<td>再次过滤</td>
</tr>
<tr>
<td>.is(exp)</td>
<td>判断是否满足这个选择器,一个为真即为真</td>
</tr>
<tr>
<td>.has(exp)</td>
<td>返回子元素满足选择器的元素</td>
</tr>
<tr>
<td>.not(exp)</td>
<td>删除满足选择器的元素</td>
</tr>
<tr>
<td>.children(exp)</td>
<td>返回此元素中满足此选择器的子元素</td>
</tr>
<tr>
<td>.find(exp)</td>
<td>返回此元素中满足此选择器的后代元素</td>
</tr>
<tr>
<td>.next()</td>
<td>-</td>
</tr>
<tr>
<td>.nextAll()</td>
<td>-</td>
</tr>
<tr>
<td>.nextUntil()</td>
<td>-</td>
</tr>
<tr>
<td>.parent()</td>
<td>-</td>
</tr>
<tr>
<td>.prev(exp)</td>
<td>-</td>
</tr>
<tr>
<td>.prevAll()</td>
<td>-</td>
</tr>
<tr>
<td>.prevUntil()</td>
<td>-</td>
</tr>
<tr>
<td>.siblings(exp)</td>
<td>-</td>
</tr>
<tr>
<td>.add(exp)</td>
<td>向当前”jQuery”加入满足选择器的元素</td>
</tr>
</tbody></table>
<h1 id="xml"><a href="#xml" class="headerlink" title="xml"></a>xml</h1><h2 id="dom4j解析技术"><a href="#dom4j解析技术" class="headerlink" title="dom4j解析技术"></a>dom4j解析技术</h2><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">new SAXReader();</span><br><span class="line">Document document = saxReader.read(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"><span class="regexp">//</span>取得根元素</span><br><span class="line">Element rootelement = document.getRootElement();</span><br><span class="line"><span class="regexp">//</span>取得标签对象</span><br><span class="line">List&lt;Element&gt;books = rootElement.elements(<span class="string">&quot;标签名&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(Element book:books)&#123;</span><br><span class="line">    <span class="regexp">//</span>asXML()方法可以把标签对象转化为标签字符串</span><br><span class="line">    <span class="regexp">//</span>依然可以通过element和elements方法取得子元素</span><br><span class="line">    <span class="regexp">//g</span>etText()用于获取标签中的文本内容</span><br><span class="line">    <span class="regexp">//</span>elementText(标签名)用于获取指定子标签的文本内容</span><br><span class="line">    <span class="regexp">//</span>attributeValue(属性名)用于获取指定属性的值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="servlet"><a href="#servlet" class="headerlink" title="servlet"></a>servlet</h1><h2 id="servlet程序的创建"><a href="#servlet程序的创建" class="headerlink" title="servlet程序的创建"></a>servlet程序的创建</h2><p>一般是直接继承其子类HttpSerlet，对doGet与doPost方法进行重写。也可以直接实现servlet接口，实现其中的方法。<br>servlet程序创建完成后，要在web.xml中配置对应的servlet标签以及在servlet-mapping标签配置资源路径。<br>还可以使用idea直接创建servlet程序。这种创建方式会自动在web.xml中配置servlet标签，但仍需要手动配置servlet-mapping标签。<br>除此之外，还可以在servlet标签中自行使用init-param标签，设置初始化参数。</p>
<h2 id="servlet程序的访问过程"><a href="#servlet程序的访问过程" class="headerlink" title="servlet程序的访问过程"></a>servlet程序的访问过程</h2><p>ip-&gt;端口-&gt;具体工程-&gt;通过web.xml文件查询资源路径<br>查询servlet-mapping标签找到资源路径对应的程序名称，再通过servlet标签定位对应类的具体位置。</p>
<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>构造器与初始化在第一次访问时会调用，服务方法会在每次访问时调用，销毁方法在工程停止时调用。</p>
<h2 id="form-get与form-post"><a href="#form-get与form-post" class="headerlink" title="form:get与form:post"></a>form:get与form:post</h2><p>这两种请求分发处理，需要通过HttpServletRequest的get.method方法获取。<br>区别：<br>get请求会把数据追加到url中发送，适合小数据量，不需要安全性的数据提交。<br>post与get相反。且post请求会发送两个包，当第一个请求发送包被回复了才发送第二个数据包。</p>
<h2 id="ServletCofig"><a href="#ServletCofig" class="headerlink" title="ServletCofig"></a>ServletCofig</h2><p>servlet与servletconfig都是由tomcat创建。servlet是第一次访问时创建，servletconfig是每个servlet创建时创建。<br>调用：可以在初始化函数中直接调用，也可以通过getServletConfig()方法获取。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>getServletName()</td>
<td>获取当前Servlet程序别名</td>
</tr>
<tr>
<td>getInitParameter(“参数名”)</td>
<td>取得需要的初始化参数</td>
</tr>
<tr>
<td>getServletContext()</td>
<td>取得ServletContext对象(整个工程的域对象)</td>
</tr>
</tbody></table>
<p>注意：当在HttpSerlet中重写init方法时要使用super.init(config)调用父类的init方法，因为getServletConfig()方法需要从HttpSerlet的父类GenericServlet中取得config对象，而这个config对象是由init方法保存的，如果只重写子类而不执行父类的这个方法，这个config对象就无法被保存。</p>
<h2 id="ServletContext"><a href="#ServletContext" class="headerlink" title="ServletContext"></a>ServletContext</h2><p>一个工程只有一个ServletContext。<br>上下文参数由web.xml中的context-param标签设置。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>getInitParameter(“参数名”)</td>
<td>取得需要的上下文参数</td>
</tr>
<tr>
<td>getContextPath()</td>
<td>取得当前工程路径</td>
</tr>
<tr>
<td>getRealPath(“/“)</td>
<td>取得真实路径</td>
</tr>
<tr>
<td>setAttribute(key,value)</td>
<td>这三个方法用于域内的传递数据</td>
</tr>
<tr>
<td>getAttribute(key)</td>
<td></td>
</tr>
<tr>
<td>removeAttribute(key)</td>
<td></td>
</tr>
</tbody></table>
<h2 id="HttpServletRequest"><a href="#HttpServletRequest" class="headerlink" title="HttpServletRequest"></a>HttpServletRequest</h2><p>表示请求信息，每次只要有请求进入tomcat，tomcat就会把请求封装到Request对象中，交给service(doGet或doPost)方法。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>getRequestURI()</td>
<td>获取统一资源标志符(资源路径)</td>
</tr>
<tr>
<td>getRequestURL()</td>
<td>获取统一资源定位符(绝对路径)，URL是URI的子集</td>
</tr>
<tr>
<td>getRemoteHost()</td>
<td>获取客户端ip</td>
</tr>
<tr>
<td>getHeader()</td>
<td>获取请求头</td>
</tr>
<tr>
<td>getScheme()</td>
<td>获取当前链接使用的协议</td>
</tr>
<tr>
<td>getServerName()</td>
<td>获取服务器ip</td>
</tr>
<tr>
<td>getServerPort()</td>
<td>获取端口号</td>
</tr>
<tr>
<td>getContextPath()</td>
<td>获取工程路径</td>
</tr>
<tr>
<td>getParameter()</td>
<td>获取请求参数(括号中写参数的name)</td>
</tr>
<tr>
<td>getParameterValue()</td>
<td>获取请求参数(用于多选数据，多个值时使用)</td>
</tr>
<tr>
<td>getMethod()</td>
<td>获取请求方式</td>
</tr>
<tr>
<td>setAttribute()</td>
<td>设置request域数据</td>
</tr>
<tr>
<td>getAttribute(key)</td>
<td>设置request域数据的特定key的值</td>
</tr>
<tr>
<td>setCharacterEncoding()</td>
<td>设置编码方式(一般用于post接收汉语)</td>
</tr>
<tr>
<td>getRequestDispatcher(“资源路径”).forward()</td>
<td>获取请求转发对象</td>
</tr>
<tr>
<td>sendRedirect(“资源路径”)</td>
<td></td>
</tr>
</tbody></table>
<p>上面获取转发对象后，通过requestDispatcher.forward(request,response)方法传递。<br>通过转发可以把request交给web-inf内的文件(正常情况不允许访问)处理。<br>注意：当使用请求转发跳转到指定页面时，它的网址并不是资源路径。所以使用相对路径跳转时会发生错误，一般会在head标签中添加base标签，规定作为相对路径所参照的地址。</p>
<h2 id="HttpServletResponse"><a href="#HttpServletResponse" class="headerlink" title="HttpServletResponse"></a>HttpServletResponse</h2><p>表示响应信息，每次只要有请求进入tomcat，tomcat就会把请求封装到Response对象中，交给service(doGet或doPost)方法。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>getOutputStream()</td>
<td>取得字节流(常用于下载)</td>
</tr>
<tr>
<td>getWrite()</td>
<td>取得字符流(常用于回传字符串)</td>
</tr>
<tr>
<td>wirter.write(“str”)</td>
<td>回传字符串数据</td>
</tr>
<tr>
<td>setContentType(“text/html; charset=UTF-8”)</td>
<td>设置服务器和客户端都使用UTF-8字符集，还设置的响应头</td>
</tr>
</tbody></table>
<p>这两个流不能同时取得。<br>请求重定向：是指客户端给服务器发送请求，然后服务器返回客户端一个新地址让客户端访问。(无法跳入web-inf内，可以跳到当前工程外的网站)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//设置响应状态码302</span><br><span class="line">resp.setStatus(302);</span><br><span class="line">//设置响应头说明新地址</span><br><span class="line">resp.seyHeader(&quot;Location&quot;,&quot;新地址&quot;);</span><br><span class="line">//第二种方法(推荐)</span><br><span class="line">resp.sendRedirect(&quot;新地址&quot;);</span><br></pre></td></tr></table></figure>
<h1 id="Listener"><a href="#Listener" class="headerlink" title="Listener"></a>Listener</h1><p>监听某种事务的变化,通过回调函数做一些相应处理.</p>
<h2 id="ServletContextListener接口"><a href="#ServletContextListener接口" class="headerlink" title="ServletContextListener接口"></a>ServletContextListener接口</h2><p>通过继承后重写contextInitialilzed()和contextDestroyed()方法实现自己的目的.<br>在web.xml中配置<listener>标签.</p>
<h1 id="Filter过滤器"><a href="#Filter过滤器" class="headerlink" title="Filter过滤器"></a>Filter过滤器</h1><p>拦截请求,过滤响应.在每次由网页端向servlet发送请求前会先由继承了Filter的servlet先进行判断.</p>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法:"></a>使用方法:</h2><p>继承Filter接口,实现doFilter方法.然后配置web.xml文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123;</span><br><span class="line">        HttpServletRequest httpServletRequest = (HttpServletRequest) servletRequest;</span><br><span class="line"></span><br><span class="line">        Object user = httpServletRequest.getSession().getAttribute(&quot;user&quot;);</span><br><span class="line"></span><br><span class="line">        if (user == null) &#123;</span><br><span class="line">            //如果为空,则请求转发到登录页面</span><br><span class="line">            httpServletRequest.getRequestDispatcher(&quot;/pages/user/login.jsp&quot;).forward(servletRequest,servletResponse);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //让程序继续访问目标资源</span><br><span class="line">            filterChain.doFilter(servletRequest,servletResponse);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>ManagerFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>com.atguigu.filter.ManagerFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>ManagerFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 设定哪些路径进行拦截 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/pages/manager/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/manager/bookServlet<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="生命周期-1"><a href="#生命周期-1" class="headerlink" title="生命周期"></a>生命周期</h2><p>1.构造器<br>2.init初始化<br>这两步在web工程启动时执行<br>3.doFilter (访问设定的路径时执行)<br>4.destroy (停止web工程时)</p>
<h2 id="FilterConfig类"><a href="#FilterConfig类" class="headerlink" title="FilterConfig类"></a>FilterConfig类</h2><p>getFilterName();<br>getInitRarameter(“key”);<br>getServletContext();</p>
<h2 id="FilterChain类"><a href="#FilterChain类" class="headerlink" title="FilterChain类"></a>FilterChain类</h2><p>Filter在执行时,会由多个Filter加上目标资源形成的一个链,可以看作一个函数的多层调用,所以返回时也是一层一层返回,且可以添加前置代码与后置代码.如果有filterChain.doFilter()就会进行下一层的调用,没有的话会原路返回.<br>1.一个链中的Fileter默认执行在同一线程<br>2.一个链视为一个请求,使用一个req<br>3.过滤器只关心地址是否匹配,不关心资源是否存在.</p>
<h2 id="拦截路径"><a href="#拦截路径" class="headerlink" title="拦截路径"></a>拦截路径</h2><p>1.精确匹配<br>2.目录匹配</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">路径/*</span><br></pre></td></tr></table></figure>
<p>3.后缀名匹配</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*.后缀名</span><br></pre></td></tr></table></figure>
<h1 id="jsp"><a href="#jsp" class="headerlink" title="jsp"></a>jsp</h1><p>主要作用是代替Servlet传回html页面的数据，jsp页面本质是servlet程序。</p>
<h2 id="page指令的属性"><a href="#page指令的属性" class="headerlink" title="page指令的属性"></a>page指令的属性</h2><table>
<thead>
<tr>
<th>属性名</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>language</td>
<td>表示翻译后是什么语言文件</td>
</tr>
<tr>
<td>contentType</td>
<td>表示jsp返回数据的编码类型</td>
</tr>
<tr>
<td>pageEncoding</td>
<td>表示页面字符集编码类型</td>
</tr>
<tr>
<td>import</td>
<td>导包</td>
</tr>
<tr>
<td>autoFlush</td>
<td>设置当out输出流缓冲区满了后是否自动刷新，默认是true</td>
</tr>
<tr>
<td>buffer</td>
<td>设置out缓冲区大小，默认8kb</td>
</tr>
<tr>
<td>errorPage</td>
<td>设置当jsp页面运行出错时，自动跳转的页面</td>
</tr>
<tr>
<td>isError</td>
<td>设置当前jsp页面是否是错误信息页面,默认是false,如果是true可以获取异常信息</td>
</tr>
<tr>
<td>extends</td>
<td>设置jsp翻译出的java程序继承哪些类</td>
</tr>
</tbody></table>
<h2 id="jsp脚本"><a href="#jsp脚本" class="headerlink" title="jsp脚本"></a>jsp脚本</h2><h3 id="声明脚本-极少使用"><a href="#声明脚本-极少使用" class="headerlink" title="声明脚本(极少使用):"></a>声明脚本(极少使用):</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;%! 声明java代码 %&gt;</span><br></pre></td></tr></table></figure>
<p>可以给jsp翻译出来的java类定义属性和方法,甚至是代码块或内部类.</p>
<h3 id="表达式脚本-常用"><a href="#表达式脚本-常用" class="headerlink" title="表达式脚本(常用):"></a>表达式脚本(常用):</h3><figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line">&lt;<span class="meta">%</span> =表达式 <span class="meta">%</span>&gt;</span><br></pre></td></tr></table></figure>
<p>jsp页面输出的数据,可以调用jspService中的对象.注意:不能使用分号</p>
<h3 id="代码脚本"><a href="#代码脚本" class="headerlink" title="代码脚本"></a>代码脚本</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;% java语句 %&gt;</span><br></pre></td></tr></table></figure>
<p>代码脚本会被翻译到jspService()方法中.<br>可以调用jspService中的方法以对象,if方法以及for循环语句.<br>且因为是直接复制放入,甚至可以将一段代码拆分为几部分分别放入代码脚本中,翻译后就自然拼接起来了.也可以与表达式脚本和html语句进行拼接.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot;&gt;</span><br><span class="line">&lt;% </span><br><span class="line">    for(int j = 0; j&lt; 10;j++)&#123;</span><br><span class="line">%&gt;</span><br><span class="line">    &lt;tr&gt;</span><br><span class="line">        &lt;td&gt;第&lt;%=j+1%&gt;行&lt;/td&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">&lt;%</span><br><span class="line">    &#125;</span><br><span class="line">%&gt;</span><br><span class="line">&lt;/table&gt;</span><br></pre></td></tr></table></figure>
<h2 id="内置对象"><a href="#内置对象" class="headerlink" title="内置对象"></a>内置对象</h2><table>
<thead>
<tr>
<th>-</th>
<th>-</th>
</tr>
</thead>
<tbody><tr>
<td>request</td>
<td>请求对象</td>
</tr>
<tr>
<td>response</td>
<td>响应对象</td>
</tr>
<tr>
<td>pageContext</td>
<td>jsp上下文对象</td>
</tr>
<tr>
<td>session</td>
<td>会话对象</td>
</tr>
<tr>
<td>application</td>
<td>ServletContext对象</td>
</tr>
<tr>
<td>config</td>
<td>ServletConfig对象</td>
</tr>
<tr>
<td>out</td>
<td>jsp输出流对象</td>
</tr>
<tr>
<td>page</td>
<td>指向当前jsp的对象</td>
</tr>
<tr>
<td>exception</td>
<td>异常对象</td>
</tr>
</tbody></table>
<p>其中有四个是域对象,它们的作用范围各不相同<br>域对象|作用范围<br>-|-<br>pageContext(PageContextImpl类)|当前jsp页面范围内有效<br>request(HttpServletRequest类)|一次请求内有效<br>session(HttpSession类)|一个会话范围内有效(打开浏览器,直到关闭浏览器)<br>application(ServletContext类)|整个web工程内</p>
<h2 id="out与response的区别"><a href="#out与response的区别" class="headerlink" title="out与response的区别"></a>out与response的区别</h2><p>out与response分别有自己的缓冲区,当out刷新时会把内容送入到response中,当response刷新时会把全部数据给客户端.<br>out.print:不管输入任何内容,在输出时都会转化成字符串.<br>out.write:不会专门进行字符串的转化,像int传入后会使用ascii码转成字符.</p>
<h2 id="常用标签"><a href="#常用标签" class="headerlink" title="常用标签"></a>常用标签</h2><h3 id="jsp静态包含-常用"><a href="#jsp静态包含-常用" class="headerlink" title="jsp静态包含(常用)"></a>jsp静态包含(常用)</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;%@ include file=&quot;路径&quot;%&gt;</span><br></pre></td></tr></table></figure>
<p>静态包含是把被包含的内容在解析时直接复制过来,两部分内容本质在一个文件中,公用所有参数.</p>
<h3 id="动态包含"><a href="#动态包含" class="headerlink" title="动态包含"></a>动态包含</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;jsp:include page=&quot;路径&quot;&gt;</span><br><span class="line">    &lt;jsp:param name=&quot;username&quot; value=&quot;jj&quot;/&gt;</span><br><span class="line">&lt;/jsp:include&gt;</span><br></pre></td></tr></table></figure>
<p>动态包含会把被包含的内容再独立创建一个文件,这个文件的内置对象是主文件对象的指针,本质还是共用内置对象.</p>
<h3 id="请求转发"><a href="#请求转发" class="headerlink" title="请求转发"></a>请求转发</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;jsp:forward page=&quot;路径&quot;&gt;&lt;/jsp:forward&gt;</span><br></pre></td></tr></table></figure>
<p>这里就是jsp的主要作用,当客户端要检索内容时,客户端的请求会发送给servlet由servlet执行对数据库的操作,当servlet获取到检索的内容时会把它放到request中转发给jsp,最终由jsp实现数据的回传.</p>
<h2 id="JSTL核心标签库"><a href="#JSTL核心标签库" class="headerlink" title="JSTL核心标签库"></a>JSTL核心标签库</h2><p>1.导入jstl标签库的jar包<br>2.引入标签库(使用时会自动导入)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot;%&gt;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>标签</th>
<th>使用方法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>&lt;c:set /&gt;</td>
<td>scop=”域”  var=”key”  value=”value”</td>
<td>可以往域中保存数据</td>
</tr>
<tr>
<td>&lt;c:if&gt;</c:if></td>
<td>test=”EL判断表达式”,成立执行中间的内容</td>
<td>做if判断</td>
</tr>
<tr>
<td>&lt;c:choose&gt;&lt;c:when&gt;&lt;c:otherwise&gt;</td>
<td>在when中填写test属性,且when一定要在choose标签中</td>
<td>跟switch…case…default类似,不需要break</td>
</tr>
<tr>
<td>&lt;c:forEach/&gt;</td>
<td>begin=”起始索引” end=”结束” var=”i” step=”步长”</td>
<td>数字遍历循环,i表示当前数字</td>
</tr>
<tr>
<td>&lt;c:forEach/&gt;</td>
<td>items=”数组” var=”i” varStatus=””</td>
<td>数组,集合遍历循环,i表示当前数据,可以添加起始,结束索引以及步长</td>
</tr>
</tbody></table>
<h1 id="EL表达式"><a href="#EL表达式" class="headerlink" title="EL表达式"></a>EL表达式</h1><p>主要是代替jsp页面中的表达式脚本,主要用于输出域对象数据,填入key输出value.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$&#123;表达式&#125;</span><br><span class="line">//也可以写对象以及其中的属性,会直接调用其对应的get方法进而会调用其toString方法,</span><br><span class="line">//如果没有get方法则会报错</span><br><span class="line">//调用map的具体key-value时在map后加.key即可</span><br></pre></td></tr></table></figure>
<p>比jsp表达式脚本更简洁,且null会直接输出为空串.<br>当四个域都有相同key时,会优先使用更小范围的key.</p>
<h2 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h2><p>此外EL表达式也支持java的各种运算.比java还多了以下这些运算:</p>
<table>
<thead>
<tr>
<th>表达式</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>${empty 表达式}</td>
<td>判断是否为空</td>
</tr>
<tr>
<td>.运算</td>
<td>输出Bean对象的某个属性的值</td>
</tr>
<tr>
<td>[]运算</td>
<td>输出有序集合中某个元素的值</td>
</tr>
<tr>
<td>map[a.a.a]</td>
<td>输出map的一些有特殊符号的key</td>
</tr>
</tbody></table>
<h2 id="隐含对象"><a href="#隐含对象" class="headerlink" title="隐含对象"></a>隐含对象</h2><table>
<thead>
<tr>
<th>变量</th>
<th>类型</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>pageContext</td>
<td>PageContextImpl</td>
<td>它可以获取jsp中的九大内置对象</td>
</tr>
<tr>
<td>pageScope</td>
<td>Map&lt;String,Object&gt;</td>
<td>它可以获取pageContext域中的数据</td>
</tr>
<tr>
<td>requestScope</td>
<td>Map&lt;String,Object&gt;</td>
<td>它可以获取Request域中的数据</td>
</tr>
<tr>
<td>sessionScope</td>
<td>Map&lt;String,Object&gt;</td>
<td>它可以获取Session域中的数据</td>
</tr>
<tr>
<td>applicationScope</td>
<td>Map&lt;String,Object&gt;</td>
<td>它可以获取Application域中的数据</td>
</tr>
<tr>
<td>param</td>
<td>Map&lt;String,String&gt;</td>
<td>它可以获取请求参数的值</td>
</tr>
<tr>
<td>paramValues</td>
<td>Map&lt;String,String[]&gt;</td>
<td>它可以获取请求参数的值(多个值时)</td>
</tr>
<tr>
<td>header</td>
<td>Map&lt;String,String&gt;</td>
<td>可以获取请求头的信息</td>
</tr>
<tr>
<td>headerValues</td>
<td>Map&lt;String,String[]&gt;</td>
<td>它可以获取请求头的值(多个值时)</td>
</tr>
<tr>
<td>cookie</td>
<td>Map&lt;String,Cookie&gt;</td>
<td>它可以获取当前请求的Cookie信息</td>
</tr>
<tr>
<td>initParam</td>
<td>Map&lt;String,String&gt;</td>
<td>它可以获取在web.xml中配置的<context-param>上下文参数</td>
</tr>
</tbody></table>
<h1 id="文件的上传"><a href="#文件的上传" class="headerlink" title="文件的上传"></a>文件的上传</h1><p>1.有from标签,method=post,encType=multipart/from-data(表示数据以多段(每个表单项为一段)的形式进行拼接,然后以二进制流的形式发送给服务器)<br>2.有input标签,type=file.<br>3.编写服务器代码接收(servlet那边以二进制流的形式接收,解析.解析要使用commons jar包)</p>
<h2 id="fileupload常用方法-类"><a href="#fileupload常用方法-类" class="headerlink" title="fileupload常用方法,类"></a>fileupload常用方法,类</h2><table>
<thead>
<tr>
<th>方法或类</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>ServletFileUpload类</td>
<td>用于解析上传数据</td>
</tr>
<tr>
<td>boolean ServletFileload.isMultipartContent(req)</td>
<td>判断接收到的数据是否为多段格式</td>
</tr>
<tr>
<td>public List<FileItem> parseRequest(req)</td>
<td>分段解析上传的数据</td>
</tr>
<tr>
<td>boolean FileItem.isFormField()</td>
<td>判断是否是普通表单项</td>
</tr>
<tr>
<td>String FileItem.getFileName()</td>
<td>获取表单项的名</td>
</tr>
<tr>
<td>String FileItem.getString(“UTF-8”)</td>
<td>获取当前表单项的值</td>
</tr>
<tr>
<td>String FileItem.getName()</td>
<td>获取上传的文件名</td>
</tr>
<tr>
<td>void FileItem.write(new File(path))</td>
<td>输出到指定磁盘位置</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//判断格式</span><br><span class="line">if(ServletFileload.isMultipartContent(req))&#123;</span><br><span class="line">    //创建FileItemFactory工厂实现类</span><br><span class="line">    FileItemFactory fileItemFactory = new DiskFileItemFactory();</span><br><span class="line">    //创建用于解析上传数据的工具类ServletFileUpload类</span><br><span class="line">    ServletFileUpload servletFileUpload = new ServletFileUpload(fileItemFactory);</span><br><span class="line">    //解析上传的数据,得到每个的表单项FileItem</span><br><span class="line">    List&lt;FileItem&gt; list = servletFileUpload.parseRequest(req);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="文件的下载"><a href="#文件的下载" class="headerlink" title="文件的下载"></a>文件的下载</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">doGet()&#123;</span><br><span class="line">    //取得文件名</span><br><span class="line">    String downloadName =</span><br><span class="line">    //设置取得文件的文件夹路径</span><br><span class="line">    String filePath = &quot;/file/&quot;;</span><br><span class="line">    //获取要下载的文件类型</span><br><span class="line">    ServletContext servletContext = getServletContext;</span><br><span class="line">    String mimeType = servletContext.getMimeType(filePath+downloadFileName);</span><br><span class="line">    //设置响应头告诉客户端返回的数据类型</span><br><span class="line">    resp.setContextType(mimeType);</span><br><span class="line">    //设置响应头告诉客户端这是用于下载的(不设置会直接显示),这里的编码方式是对应谷歌,ie浏览器</span><br><span class="line">    resp.setHeader(&quot;Content-Disposition&quot;,&quot;attachment;filename=&quot;+URLEncoder.encode(&quot;有汉字的字符串&quot;,&quot;UTF-8&quot;));</span><br><span class="line">    //取得要下载的文件内容</span><br><span class="line">    InputStream resourceAsStream = servletContext.getResourceAsStream(filePath+downloadFileName);</span><br><span class="line">    //获取输出流</span><br><span class="line">    OutputStream outputStream = resp.getOutputStream();</span><br><span class="line">    //使用commons包工具类导出</span><br><span class="line">    IOUtils.copy(resourceAsStream,outputStream);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h1><h2 id="创建-修改"><a href="#创建-修改" class="headerlink" title="创建,修改"></a>创建,修改</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//创建cookie</span><br><span class="line">new Cookie();</span><br><span class="line">//通知客户端保存</span><br><span class="line">resp.addCookie(cookie);</span><br></pre></td></tr></table></figure>
<h2 id="获取"><a href="#获取" class="headerlink" title="获取"></a>获取</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">req.getCookies();</span><br></pre></td></tr></table></figure>
<h2 id="修改生命周期-删除"><a href="#修改生命周期-删除" class="headerlink" title="修改生命周期,删除"></a>修改生命周期,删除</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//负数:关闭浏览器删除(默认) 0:立即删除 正数:保存多少秒</span><br><span class="line">cookie.setMaxAge();</span><br></pre></td></tr></table></figure>
<h2 id="path属性"><a href="#path属性" class="headerlink" title="path属性"></a>path属性</h2><p>为cookie设置path属性,方便界定哪些cookie发送哪些不发</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cookie.setPath(req.getContextPath()+...);</span><br></pre></td></tr></table></figure>
<h1 id="session会话"><a href="#session会话" class="headerlink" title="session会话"></a>session会话</h1><p>每个客户端都有自己的一个Session会话,这个session具有一个不会重复的id,我们经常用来保存用户登录后的信息.session是由服务器保存的.</p>
<h2 id="创建和获取"><a href="#创建和获取" class="headerlink" title="创建和获取"></a>创建和获取</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//第一次创建,之后获取</span><br><span class="line">request.getSession();</span><br><span class="line">//判断是否是第一次创建</span><br><span class="line">isNew();</span><br><span class="line">//获取id</span><br><span class="line">getId();</span><br></pre></td></tr></table></figure>
<h2 id="生命周期-2"><a href="#生命周期-2" class="headerlink" title="生命周期"></a>生命周期</h2><p>session的生命周期是指间客户端未向服务器发送请求的最大间隔.只要期间发送请求,计时器会刷新.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//设置生命周期,默认1800,负数表示永不超时</span><br><span class="line">session.setMaxInactiveInterval()</span><br><span class="line">//立即销毁</span><br><span class="line">session.invalidate()</span><br><span class="line">//也可以在web.xml中配置,单位是分钟</span><br><span class="line">&lt;session-config&gt;</span><br><span class="line">    &lt;session-timeout&gt;30&lt;/session-timeout&gt;</span><br><span class="line">&lt;/session-config&gt;</span><br></pre></td></tr></table></figure>
<h2 id="客户端和服务器Session的传递"><a href="#客户端和服务器Session的传递" class="headerlink" title="客户端和服务器Session的传递"></a>客户端和服务器Session的传递</h2><p>Session对于客户端是一个生命周期为session(关闭浏览器就删除)的cookie.它像一把钥匙,第一次由服务器交给客户端,之后每次使用都用这把钥匙从客户端获取session中的信息,关闭浏览器时,会把这把钥匙扔掉.再次访问时服务器再发.如果长时间间没有用这把钥匙,服务出于节省内存的考虑,会删掉session.</p>
<h1 id="表单重复提交"><a href="#表单重复提交" class="headerlink" title="表单重复提交"></a>表单重复提交</h1><p>1.表单提交后使用请求转发进入页面后,刷新会导致表单重复提交.要使用重定向.<br>2.网络状况不好,跳转页面延迟,多次点击提交.使用验证码解决.<br>3.使用浏览器回退功能进入提交页面进行重复提交.使用验证码解决.</p>
<h1 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h1><p>解决多线程数据安全问题.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">new ThreadLoacl&lt;&gt;();</span><br><span class="line">threadLocal.set();</span><br><span class="line">threadLocal.get();</span><br></pre></td></tr></table></figure>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>1.TreadLoal可以对当前线程关联一个数据.(key为当前线程)<br>2.一个TreadLoal对象只能为当前线程关联一个数据.<br>3.一般是Static类型<br>4.线程销毁后由jvm自动释放</p>
<h1 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义:"></a>定义:</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var jsonObj = &#123;</span><br><span class="line">                &quot;key1&quot;:12,</span><br><span class="line">                &quot;key2&quot;:&quot;abc&quot;,</span><br><span class="line">                &quot;key3&quot;:true,</span><br><span class="line">                &quot;key4&quot;:[11,&quot;arr&quot;,false],</span><br><span class="line">                &quot;key5&quot;:&#123;</span><br><span class="line">                    &quot;key5_1&quot; : 551,</span><br><span class="line">                    &quot;key5_2&quot; : &quot;key5_2_value&quot;</span><br><span class="line">                &#125;,</span><br><span class="line">                &quot;key6&quot;:[&#123;</span><br><span class="line">                    &quot;key6_1_1&quot;:6611,</span><br><span class="line">                    &quot;key6_1_2&quot;:&quot;key6_1_2_value&quot;</span><br><span class="line">                &#125;,&#123;</span><br><span class="line">                    &quot;key6_2_1&quot;:6621,</span><br><span class="line">                    &quot;key6_2_2&quot;:&quot;key6_2_2_value&quot;</span><br><span class="line">                &#125;]</span><br><span class="line">            &#125;;</span><br></pre></td></tr></table></figure>
<h2 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alert(typeof(jsonObj));// object  json就是一个对象</span><br><span class="line">alert(jsonObj.key1); //12</span><br><span class="line">alert(jsonObj.key2); // abc</span><br><span class="line">alert(jsonObj.key3); // true</span><br><span class="line">alert(jsonObj.key4);// 得到数组[11,&quot;arr&quot;,false]</span><br><span class="line"> // json 中 数组值的遍历</span><br><span class="line">for(var i = 0; i &lt; jsonObj.key4.length; i++) &#123;</span><br><span class="line"> alert(jsonObj.key4[i]);</span><br><span class="line">&#125;</span><br><span class="line">alert(jsonObj.key5.key5_1);//551</span><br><span class="line">alert(jsonObj.key5.key5_2);//key5_2_value</span><br><span class="line">alert( jsonObj.key6 );// 得到json数组</span><br></pre></td></tr></table></figure>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>JSON.stringify():把json对象转为字符串<br>JSON.parse():把json字符串转为对象</p>
<h2 id="java中的使用"><a href="#java中的使用" class="headerlink" title="java中的使用"></a>java中的使用</h2><p>导入jar包</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="constructor">Gson()</span>;</span><br><span class="line"><span class="comment">//bean对象转json字符串</span></span><br><span class="line">gson.<span class="keyword">to</span><span class="constructor">Json(对象)</span>;</span><br><span class="line"><span class="comment">//把json字符串转bean对象</span></span><br><span class="line">gson.from<span class="constructor">Json(<span class="params">json</span>字符串,对象.<span class="params">class</span>)</span>;</span><br><span class="line"><span class="comment">//list转json字符串</span></span><br><span class="line">gson.<span class="keyword">to</span><span class="constructor">Json(<span class="params">list</span>)</span>;</span><br><span class="line"><span class="comment">//把json字符串转list</span></span><br><span class="line">gson.from<span class="constructor">Json(<span class="params">json</span>字符串,<span class="params">new</span> TypeToken&lt;List&lt;Integer,Person&gt;&gt;()</span>&#123;&#125;.get<span class="constructor">Type()</span>);</span><br><span class="line"><span class="comment">//map转json字符串</span></span><br><span class="line">gson.<span class="keyword">to</span><span class="constructor">Json(<span class="params">map</span>)</span>;</span><br><span class="line"><span class="comment">//把json字符串转map(使用匿名内部类)</span></span><br><span class="line">gson.from<span class="constructor">Json(<span class="params">personMapJsonString</span>, <span class="params">new</span> TypeToken&lt;HashMap&lt;Integer,Person&gt;&gt;()</span>&#123;&#125;.get<span class="constructor">Type()</span>);</span><br></pre></td></tr></table></figure>
<h1 id="AJAX请求"><a href="#AJAX请求" class="headerlink" title="AJAX请求"></a>AJAX请求</h1><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>是一种浏览器异步发起请求,局部更新页面的技术.<br>优点:<br>AJAX是运行在客户端的技术,能一定程度减轻服务器带宽压力.<br>可以在不刷新整个页面的情况下与服务器通讯<br>异步方式与服务器通讯,不打断用户操作<br>缺点:<br>因为不跳转页面,所以服务的back与history功能失效<br>破坏了程序的异常处理机制<br>一般搜索引擎搜索不到AJAX添加的页面<br>客户端肥大</p>
<p>一般不使用原生AJAX请求,使用框架中的AJAX请求.jQuery中的AJAX请求:</p>
<h2 id="ajax方法"><a href="#ajax方法" class="headerlink" title="$.ajax方法"></a>$.ajax方法</h2><table>
<thead>
<tr>
<th>属性</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>url</td>
<td>表示请求的地址</td>
</tr>
<tr>
<td>type</td>
<td>表示请求的类型(GTE,POST)</td>
</tr>
<tr>
<td>data</td>
<td>表示发送给服务器的数据</td>
</tr>
<tr>
<td>-</td>
<td>格式一:name=value1&amp;name=value2</td>
</tr>
<tr>
<td>-</td>
<td>格式二:{name:[“value1”,”value2”]}</td>
</tr>
<tr>
<td>success</td>
<td>请求成功响应的回调函数</td>
</tr>
<tr>
<td>dataType</td>
<td>响应的数据类型</td>
</tr>
<tr>
<td>-</td>
<td>常用的数据类型有:xml,text,json</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">        url:&quot;http://localhost:8080/16_json_ajax_i18n/ajaxServlet&quot;,</span><br><span class="line">        data:&#123;action:&quot;jQueryAjax&quot;&#125;,</span><br><span class="line">        type:&quot;GET&quot;,</span><br><span class="line">        //这里的msg是由服务器返回的一个变量,可以随意命名,但要知道其格式方便解析</span><br><span class="line">        //在写服务器端的AJAX请求时,返回值是使用resp.getWriter().write()返回的</span><br><span class="line">        success:function (msg) &#123;</span><br><span class="line">            // var jsonObj = JSON.parse(data);</span><br><span class="line">            $(&quot;#msg&quot;).html(&quot; ajax 编号：&quot; + data.id + &quot; , 姓名：&quot; + data.name);</span><br><span class="line">        &#125;,</span><br><span class="line">        dataType : &quot;json&quot;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<h2 id="get和post方法"><a href="#get和post方法" class="headerlink" title="get和post方法"></a>get和post方法</h2><p>是在$.ajax方法基础上进一步封装了一次,区分了get和post<br>$.get(url,data,success,dataType)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// ajax--get请求</span><br><span class="line">$(&quot;#getBtn&quot;).click(function()&#123;</span><br><span class="line"></span><br><span class="line">    $.get(&quot;http://localhost:8080/16_json_ajax_i18n/ajaxServlet&quot;,&quot;action=jQueryGet&quot;,function (data) &#123;</span><br><span class="line">        $(&quot;#msg&quot;).html(&quot; get 编号：&quot; + data.id + &quot; , 姓名：&quot; + data.name);</span><br><span class="line">    &#125;,&quot;json&quot;);</span><br><span class="line">    </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// ajax--post请求</span><br><span class="line">$(&quot;#postBtn&quot;).click(function()&#123;</span><br><span class="line">    // post请求</span><br><span class="line">    $.post(&quot;http://localhost:8080/16_json_ajax_i18n/ajaxServlet&quot;,&quot;action=jQueryPost&quot;,function (data) &#123;</span><br><span class="line">        $(&quot;#msg&quot;).html(&quot; post 编号：&quot; + data.id + &quot; , 姓名：&quot; + data.name);</span><br><span class="line">    &#125;,&quot;json&quot;);</span><br><span class="line">    </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="getJSON方法"><a href="#getJSON方法" class="headerlink" title="$.getJSON方法"></a>$.getJSON方法</h2><p>对上面又封装了一次,合并了get和post,且只使用JSON作为dataType.<br>$.getJSON(url,data,success)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$.getJSON(&quot;http://localhost:8080/16_json_ajax_i18n/ajaxServlet&quot;,&quot;action=jQueryGetJSON&quot;,function (data) &#123;</span><br><span class="line">    $(&quot;#msg&quot;).html(&quot; getJSON 编号：&quot; + data.id + &quot; , 姓名：&quot; + data.name);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="serialize-方法"><a href="#serialize-方法" class="headerlink" title="serialize()方法"></a>serialize()方法</h2><p>它可以获取表单的数据并转换为JSON.可以用于不刷新页面的表单提交.<br>注意看action的处理</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$.getJSON(&quot;http://localhost:8080/16_json_ajax_i18n/ajaxServlet&quot;,&quot;action=jQuerySerialize&amp;&quot; + $(&quot;#form01&quot;).serialize(),function (data) &#123;</span><br><span class="line">                        $(&quot;#msg&quot;).html(&quot; Serialize 编号：&quot; + data.id + &quot; , 姓名：&quot; + data.name);</span><br><span class="line">                    &#125;);</span><br></pre></td></tr></table></figure>
<h1 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h1><h2 id="阶段一"><a href="#阶段一" class="headerlink" title="阶段一"></a>阶段一</h2><h3 id="表单验证的实现"><a href="#表单验证的实现" class="headerlink" title="表单验证的实现"></a>表单验证的实现</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    $(function () &#123;</span><br><span class="line">        //给注册绑定事件</span><br><span class="line">        $(&quot;#sub_btn&quot;).click(function () &#123;</span><br><span class="line">            var username = $(&quot;#username&quot;).val()</span><br><span class="line">            var usernamePatt = /^\w&#123;5,12&#125;$/</span><br><span class="line">            //确认用户名</span><br><span class="line">            if (!usernamePatt.test(username))&#123;</span><br><span class="line">                //定位错误信息输出文本，并输出对应的文字</span><br><span class="line">                $(&quot;span.errorMsg&quot;).text(&quot;用户名不合法&quot;)</span><br><span class="line">                //防止页面跳转</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            //合法后要去处显示的信息</span><br><span class="line">            var password = $(&quot;#password&quot;).val();</span><br><span class="line">            var passwordPatt = /^\w&#123;5,12&#125;$/</span><br><span class="line">            $(&quot;span.errorMsg&quot;).text(&quot;&quot;);</span><br><span class="line">            //确认密码</span><br><span class="line">            if (!passwordPatt.test(password))&#123;</span><br><span class="line">                $(&quot;span.errorMsg&quot;).text(&quot;密码不合法&quot;)</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            $(&quot;span.errorMsg&quot;).text(&quot;&quot;);</span><br><span class="line">            var repwd = $(&quot;#repwd&quot;).val()</span><br><span class="line">            //确认确认的密码</span><br><span class="line">            if (repwd!=password)&#123;</span><br><span class="line">                $(&quot;span.errorMsg&quot;).text(&quot;两次密码不一致&quot;)</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            $(&quot;span.errorMsg&quot;).text(&quot;&quot;);</span><br><span class="line">            var email = $(&quot;#email&quot;).val()</span><br><span class="line">            var emailPatt = /\w*@\w*.com/</span><br><span class="line">            //确认邮箱</span><br><span class="line">            if (!emailPatt.test(email))&#123;</span><br><span class="line">                $(&quot;span.errorMsg&quot;).text(&quot;邮箱不合法&quot;)</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            $(&quot;span.errorMsg&quot;).text(&quot;&quot;);</span><br><span class="line">            var code = $(&quot;#code&quot;).val();</span><br><span class="line">            //确认验证码</span><br><span class="line">            if (code==null||code==&quot;&quot;)&#123;</span><br><span class="line">                $(&quot;span.errorMsg&quot;).text(&quot;输入正确的验证码&quot;)</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            $(&quot;span.errorMsg&quot;).text(&quot;&quot;);</span><br><span class="line"></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h2 id="阶段二"><a href="#阶段二" class="headerlink" title="阶段二"></a>阶段二</h2><h3 id="1-创建数据库与用户表"><a href="#1-创建数据库与用户表" class="headerlink" title="1.创建数据库与用户表"></a>1.创建数据库与用户表</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE DATABASE book</span><br><span class="line">USE book</span><br><span class="line">CREATE TABLE `user`(</span><br><span class="line">    `id` INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">    `usernam` VARCHAR(20) NOT NULL UNIQUE,</span><br><span class="line">    `password` VARCHAR(32) NOT NULL,</span><br><span class="line">    `email` VARCHAR(200)</span><br><span class="line">)</span><br><span class="line">ALTER TABLE `user` CHANGE `usernam`  `username` VARCHAR(20) NOT NULL UNIQUE</span><br><span class="line">INSERT INTO `user`(`username`,`password`,`email`)VALUES(&#x27;admin&#x27;,&#x27;admin&#x27;,NULL)</span><br></pre></td></tr></table></figure>
<h3 id="2-编写对应的javabean类"><a href="#2-编写对应的javabean类" class="headerlink" title="2.编写对应的javabean类"></a>2.编写对应的javabean类</h3><h3 id="3-编写Dao持久层-实现对数据库的各种操作"><a href="#3-编写Dao持久层-实现对数据库的各种操作" class="headerlink" title="3.编写Dao持久层(实现对数据库的各种操作)"></a>3.编写Dao持久层(实现对数据库的各种操作)</h3><pre><code>搭建常用工具类：导入DBUtils包，MySQL包，durid包。编写durid工具包，编写BasicDao，UserDao，UserDaoImpl。
</code></pre>
<p>为Dao层写接口的好处:<br>1.可以在尚未实现具体DAO的时候编写上层代码,如Service里对DAO的调用<br>2.可以为DAO进行多实现,例如有JDBCDAO实现,MyBatisDAO实现,而不需要更改上层代码,只需要简单的在Spring的IoC配置里修改一下注入的DAO实现</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class UserDaoImpl extends BasicDao&lt;User&gt; implements UserDao &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public User queryUserByUsername(String username) &#123;</span><br><span class="line">        String sql = &quot;select * from `user` where `username` = ?&quot;;</span><br><span class="line">        return querySingle(sql,User.class,username);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public User queryUserByUsernameAndPassword(String username, String password) &#123;</span><br><span class="line">        String sql = &quot;select * from `user` where `username` = ? and `password` = ?&quot;;</span><br><span class="line">        return querySingle(sql,User.class,username,password);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int saveUser(User user) &#123;</span><br><span class="line">        String sql = &quot;insert into `user`(username,password,email) values(?,?,?)&quot;;</span><br><span class="line"></span><br><span class="line">        return update(sql,user.getName(),user.getPassword(),user.getEmail());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-编写Service业务层-实现各种方法"><a href="#4-编写Service业务层-实现各种方法" class="headerlink" title="4.编写Service业务层(实现各种方法)"></a>4.编写Service业务层(实现各种方法)</h3><p>为Service层写接口的好处<br>1.可以在尚未实现具体Service情况下编写上层改代码,如Controller对Service的调用<br>2.Spring无论是AOP还是事务管理的实现都是基于动态代理的,而动态代理的实现依赖于接口,所以必须有接口的定义才能使用这些功能<br>3.可以对Service进行多实现</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class UserServiceImpl implements UserService &#123;</span><br><span class="line">    private UserDao userDao = new UserDaoImpl();</span><br><span class="line">    @Override</span><br><span class="line">    public void registUser(User user) &#123;</span><br><span class="line">        userDao.saveUser(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public User login(String username, String password) &#123;</span><br><span class="line">        return userDao.queryUserByUsernameAndPassword(username,password);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean canUseName(String username) &#123;</span><br><span class="line">        User user = userDao.queryUserByUsername(username);</span><br><span class="line">        if (user==null)&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-编写web层-将请求路径与工程进行绑定-将得到的请求进行解析-交给业务层实现-接收业务层的结果-处理后-输出给客户端"><a href="#5-编写web层-将请求路径与工程进行绑定-将得到的请求进行解析-交给业务层实现-接收业务层的结果-处理后-输出给客户端" class="headerlink" title="5.编写web层(将请求路径与工程进行绑定,将得到的请求进行解析,交给业务层实现,接收业务层的结果,处理后,输出给客户端)"></a>5.编写web层(将请求路径与工程进行绑定,将得到的请求进行解析,交给业务层实现,接收业务层的结果,处理后,输出给客户端)</h3><pre><code>导入servlet包。
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class RegistServlet extends HttpServlet &#123;</span><br><span class="line">    UserService userService = new UserServiceImpl();</span><br><span class="line">    @Override</span><br><span class="line">    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;</span><br><span class="line">        String username = req.getParameter(&quot;username&quot;);</span><br><span class="line">        String password = req.getParameter(&quot;password&quot;);</span><br><span class="line">        String email = req.getParameter(&quot;email&quot;);</span><br><span class="line">        String code = req.getParameter(&quot;code&quot;);</span><br><span class="line">        //验证验证码</span><br><span class="line">        if (userService.canUseName(username))&#123;</span><br><span class="line">            User user = new User(0,username, password, email);</span><br><span class="line">            userService.registUser(user);</span><br><span class="line">            req.getRequestDispatcher(&quot;pages/user/regist_success.html&quot;).forward(req,resp);</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            req.getRequestDispatcher(&quot;pages/user/regist.html&quot;).forward(req,resp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="阶段三"><a href="#阶段三" class="headerlink" title="阶段三"></a>阶段三</h2><h3 id="1-jsp动态化"><a href="#1-jsp动态化" class="headerlink" title="1.jsp动态化"></a>1.jsp动态化</h3><h3 id="2-抽取公共部分进行静态包含"><a href="#2-抽取公共部分进行静态包含" class="headerlink" title="2.抽取公共部分进行静态包含"></a>2.抽取公共部分进行静态包含</h3><h3 id="3-使用req的一系列方法构建动态base标签"><a href="#3-使用req的一系列方法构建动态base标签" class="headerlink" title="3.使用req的一系列方法构建动态base标签"></a>3.使用req的一系列方法构建动态base标签</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;%</span><br><span class="line">    String basePath = request.getScheme()</span><br><span class="line">            + &quot;://&quot;</span><br><span class="line">            + request.getServerName()</span><br><span class="line">            + &quot;:&quot;</span><br><span class="line">            + request.getServerPort()</span><br><span class="line">            + request.getContextPath()</span><br><span class="line">            + &quot;/&quot;;</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure>
<h3 id="4-表单错误提交回显功能实现"><a href="#4-表单错误提交回显功能实现" class="headerlink" title="4.表单错误提交回显功能实现"></a>4.表单错误提交回显功能实现</h3><p>通过把要回显的内容放到域对象中,在页面上再调用域对象使用EL表达式进行显示</p>
<h3 id="5-将登录与注册合并为一个UserServlet"><a href="#5-将登录与注册合并为一个UserServlet" class="headerlink" title="5.将登录与注册合并为一个UserServlet"></a>5.将登录与注册合并为一个UserServlet</h3><p>在登录页面以及注册页面添加隐藏提交使得servlet能判断执行哪个操作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;hidden&quot; name=&quot;action&quot; value=&quot;&quot;&gt;</span><br></pre></td></tr></table></figure>
<p>servlet:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">doPost()&#123;</span><br><span class="line">    String action = req.getParameter(&quot;action&quot;);</span><br><span class="line">    if(action.equals(?))&#123;</span><br><span class="line">        //登录业务</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            //注册业务</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-对上面的代码进一步的优化"><a href="#6-对上面的代码进一步的优化" class="headerlink" title="6.对上面的代码进一步的优化"></a>6.对上面的代码进一步的优化</h3><p>让value值等于要实现的各种方法的方法名,利用反射机制取得,省去大量的else if.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Method method = this.class.getDeclaredMethod(action,参数);</span><br></pre></td></tr></table></figure>
<h3 id="7-制作BaseServlet程序"><a href="#7-制作BaseServlet程序" class="headerlink" title="7.制作BaseServlet程序"></a>7.制作BaseServlet程序</h3><p>再对这部分代码进行抽取作为BaseServlet程序,使所有模块继承它,base中只存放doget与dopost方法,而每个模块中存放其要实现的方法,这样当请求发送给各个模块时,因为会自动调用doget或dopost方法,而它们自身又没有这两个方法会去父类中调用,而这里的this又是他们自己,就可以成功的调用到本模块中的各种方法.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public abstract class BaseServlet extends HttpServlet &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;</span><br><span class="line">        doPost(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;</span><br><span class="line">        // 解决post请求中文乱码问题</span><br><span class="line">        // 一定要在获取请求参数之前调用才有效</span><br><span class="line">        req.setCharacterEncoding(&quot;UTF-8&quot;);</span><br><span class="line"></span><br><span class="line">        String action = req.getParameter(&quot;action&quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">            // 获取action业务鉴别字符串，获取相应的业务 方法反射对象</span><br><span class="line">            Method method = this.getClass().getDeclaredMethod(action, HttpServletRequest.class, HttpServletResponse.class);</span><br><span class="line">//            System.out.println(method);</span><br><span class="line">            // 调用目标业务 方法</span><br><span class="line">            method.invoke(this, req, resp);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            throw new RuntimeException(e);// 把异常抛给Filter过滤器</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="8-使用beanUtils工具类"><a href="#8-使用beanUtils工具类" class="headerlink" title="8.使用beanUtils工具类"></a>8.使用beanUtils工具类</h3><p>导入jar包,创建webUtils工具,实现信息注入.<br>底层原理,使用反射机制从类对象那里取得set方法,实现注入. </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//直接把信息注入到User类中</span><br><span class="line">//这里传入map是为了不止在web层使用这个工具,耦合度更低</span><br><span class="line">public static &lt;T&gt; T copyParamToBean( Map value , T bean )&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(&quot;注入之前：&quot; + bean);</span><br><span class="line">            /**</span><br><span class="line">             * 把所有请求的参数都注入到user对象中</span><br><span class="line">             */</span><br><span class="line">            BeanUtils.populate(bean, value);</span><br><span class="line">            System.out.println(&quot;注入之后：&quot; + bean);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return bean;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="阶段四"><a href="#阶段四" class="headerlink" title="阶段四"></a>阶段四</h2><p>编写图书模块.<br>到service层与用户模块实现过程基本相同,不再贴重复代码.</p>
<h3 id="图书列表功能的实现"><a href="#图书列表功能的实现" class="headerlink" title="图书列表功能的实现"></a>图书列表功能的实现</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//在进入图书列表的连接中插入这个Servlet,获取books交给图书列表页面显示</span><br><span class="line">protected void list()&#123;</span><br><span class="line">    List&lt;book&gt; books = bookService.queryBooks();</span><br><span class="line">    req.setAttribute(&quot;books&quot;,books);</span><br><span class="line">    req.getRequestDispatcher(&quot;图书列表页面&quot;).forward(req,resp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="添加图书和删除图书功能的实现"><a href="#添加图书和删除图书功能的实现" class="headerlink" title="添加图书和删除图书功能的实现"></a>添加图书和删除图书功能的实现</h3><p>这里没有什么好写的,但要注意,这里要使用重定向回到图书列表页面,因为重定向是两次请求,当刷新页面时也只会刷新第二次请求.</p>
<h3 id="实现分页功能"><a href="#实现分页功能" class="headerlink" title="实现分页功能"></a>实现分页功能</h3><p>思路,构造一个page对象包含需要的信息,把这个对象交给dao持久层,让dbutils可以发送分页的sql语句</p>
<h2 id="阶段五"><a href="#阶段五" class="headerlink" title="阶段五"></a>阶段五</h2><h3 id="使用session保存用户信息"><a href="#使用session保存用户信息" class="headerlink" title="使用session保存用户信息"></a>使用session保存用户信息</h3><p>在使用servlet login时把用户信息保存到session中,直到注销时销毁session.</p>
<h3 id="使用验证码-防止重复提交表单"><a href="#使用验证码-防止重复提交表单" class="headerlink" title="使用验证码,防止重复提交表单"></a>使用验证码,防止重复提交表单</h3><p>在客户端与服务交互时只在访问表单页提供一个验证码存放于session中,一旦服务器接收就销毁这个验证码,当客户端再进行提交时,因为此时已经没有验证码,所以无法重复提交.<br>要使用谷歌kaptcha的jar包进行验证码的生成.<br>这个包有一个servlet,当被访问时就会生成一个验证码图片,同时把这个验证码存放到session中.我们可以使用img标签进行显示.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//xml配置,要把地址改为.jpg形式</span><br><span class="line">&lt;servlet&gt;</span><br><span class="line">    &lt;servlet-name&gt;KaptchaServlet&lt;/servlet-name&gt;</span><br><span class="line">    &lt;servlet-class&gt;com.google.code.kaptcha.servlet.KaptchaServlet&lt;/servlet-class&gt;</span><br><span class="line">&lt;/servlet&gt;</span><br><span class="line">&lt;servlet-mapping&gt;</span><br><span class="line">    &lt;servlet-name&gt;KaptchaServlet&lt;/servlet-name&gt;</span><br><span class="line">    &lt;url-pattern&gt;/kaptcha.jpg&lt;/url-pattern&gt;</span><br><span class="line">&lt;/servlet-mapping&gt;</span><br><span class="line">//在页面中使用img标签显示它,并绑定单机事件,只要单机就重新加载验证码</span><br><span class="line">//但需要注意的是,因为浏览器的缓存机制,我们要在每次请求的地址后加一个随机的参数</span><br><span class="line">//否则,浏览器会识别为同一请求而不再进行请求的发送,而是直接调用缓存</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//在接收提交的servlet页面进行处理</span><br><span class="line">String token = (String) req.getSession().getAttribute(KAPTCHA_SESSION_KEY);</span><br><span class="line">// 删除 Session中的验证码</span><br><span class="line">req.getSession().removeAttribute(KAPTCHA_SESSION_KEY);</span><br><span class="line">String code = req.getParameter(&quot;code&quot;);</span><br><span class="line">if (token != null &amp;&amp; token.equalsIgnoreCase(code))&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="阶段六"><a href="#阶段六" class="headerlink" title="阶段六"></a>阶段六</h2><h3 id="对后台网页添加网页检查"><a href="#对后台网页添加网页检查" class="headerlink" title="对后台网页添加网页检查"></a>对后台网页添加网页检查</h3><p>使用Filter过滤器对所有后台网页进行网页检查.注意:不止要拦截前端的网页,也要对后台的部分servlet进行拦截.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123;</span><br><span class="line">        HttpServletRequest httpServletRequest = (HttpServletRequest) servletRequest;</span><br><span class="line"></span><br><span class="line">        Object user = httpServletRequest.getSession().getAttribute(&quot;user&quot;);</span><br><span class="line"></span><br><span class="line">        if (user == null) &#123;</span><br><span class="line">            httpServletRequest.getRequestDispatcher(&quot;/pages/user/login.jsp&quot;).forward(servletRequest,servletResponse);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            filterChain.doFilter(servletRequest,servletResponse);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;filter&gt;</span><br><span class="line">    &lt;filter-name&gt;ManagerFilter&lt;/filter-name&gt;</span><br><span class="line">    &lt;filter-class&gt;com.atguigu.filter.ManagerFilter&lt;/filter-class&gt;</span><br><span class="line">&lt;/filter&gt;</span><br><span class="line">&lt;filter-mapping&gt;</span><br><span class="line">    &lt;filter-name&gt;ManagerFilter&lt;/filter-name&gt;</span><br><span class="line">    &lt;url-pattern&gt;/pages/manager/*&lt;/url-pattern&gt;</span><br><span class="line">    &lt;url-pattern&gt;/manager/bookServlet&lt;/url-pattern&gt;</span><br><span class="line">&lt;/filter-mapping&gt;</span><br></pre></td></tr></table></figure>
<h3 id="实现事务功能"><a href="#实现事务功能" class="headerlink" title="实现事务功能"></a>实现事务功能</h3><p>为了实现数据库的事务我们需要保证同一事务下的所有操作都取得的是同一连接.我们需要使用ThreadLocal在获取connection时将其保存,此后同一事务的所有操作都使用get方法获取同一个connection.</p>
<h4 id="对JDBCUtilsByDruid进行修改"><a href="#对JDBCUtilsByDruid进行修改" class="headerlink" title="对JDBCUtilsByDruid进行修改"></a>对JDBCUtilsByDruid进行修改</h4><p>当线程索要connection时检查是否持有一个connection,如果有就直接返回这个线程,没由再从线程池获取.再添加回滚和关闭事务的方法,在这两个方法中关闭连接.再删除关闭连接的方法.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//获得ThreadLocal</span><br><span class="line">private static ThreadLocal&lt;Connection&gt; conns = new ThreadLocal&lt;Connection&gt;();</span><br><span class="line">public static Connection getConnection()&#123;</span><br><span class="line">        Connection conn = conns.get();</span><br><span class="line">        if (conn == null) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                conn = dataSource.getConnection();//从数据库连接池中获取连接</span><br><span class="line">                conns.set(conn); // 保存到ThreadLocal对象中，供后面的jdbc操作使用</span><br><span class="line">                conn.setAutoCommit(false); // 设置为手动管理事务</span><br><span class="line">            &#125; catch (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return conn;</span><br><span class="line">    &#125;</span><br><span class="line">/**</span><br><span class="line"> * 提交事务，并关闭释放连接</span><br><span class="line"> */</span><br><span class="line">public static void commitAndClose()&#123;</span><br><span class="line">    Connection connection = conns.get();</span><br><span class="line">    if (connection != null) &#123; // 如果不等于null，说明 之前使用过连接，操作过数据库</span><br><span class="line">        try &#123;</span><br><span class="line">            connection.commit(); // 提交 事务</span><br><span class="line">        &#125; catch (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                connection.close(); // 关闭连接，资源资源</span><br><span class="line">            &#125; catch (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 一定要执行remove操作，否则就会出错。（因为Tomcat服务器底层使用了线程池技术）</span><br><span class="line">    conns.remove();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 回滚事务，并关闭释放连接</span><br><span class="line"> */</span><br><span class="line">public static void rollbackAndClose()&#123;</span><br><span class="line">    Connection connection = conns.get();</span><br><span class="line">    if (connection != null) &#123; // 如果不等于null，说明 之前使用过连接，操作过数据库</span><br><span class="line">        try &#123;</span><br><span class="line">            connection.rollback();//回滚事务</span><br><span class="line">        &#125; catch (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                connection.close(); // 关闭连接，资源资源</span><br><span class="line">            &#125; catch (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 一定要执行remove操作，否则就会出错。（因为Tomcat服务器底层使用了线程池技术）</span><br><span class="line">    conns.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="对BasicDao进行修改"><a href="#对BasicDao进行修改" class="headerlink" title="对BasicDao进行修改"></a>对BasicDao进行修改</h4><p>BasicDao的之前所有方法不再关闭连接,且为了能够回滚事务,可以捕获异常,但必须将异常抛出.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class BasicDao&lt;T&gt;&#123;</span><br><span class="line">    private QueryRunner qr = new QueryRunner();</span><br><span class="line">    //开发通用的dml方法，针对任意的表</span><br><span class="line">    public int update(String sql,Object...parameters)&#123;</span><br><span class="line">        //因为建立连接需要在try—catch-finally操作中，为了在finally关闭</span><br><span class="line">        //在外面先建立connection</span><br><span class="line">        Connection connection = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            connection = JDBCUtilsByDruid.getConnection();</span><br><span class="line">            int affectedRow = qr.update(connection,sql,parameters);</span><br><span class="line">            return affectedRow;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            throw new RuntimeException(e);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    //返回多行数据，针对任意的表</span><br><span class="line">    public List&lt;T&gt; queryMultiply(String sql,Class&lt;T&gt; clazz,Object... parameters)&#123;</span><br><span class="line">        Connection connection = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            connection = JDBCUtilsByDruid.getConnection();</span><br><span class="line">            List&lt;T&gt; list =</span><br><span class="line">                    qr.query(connection,sql,new BeanListHandler&lt;T&gt;(clazz),parameters);</span><br><span class="line">            return list;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            throw new RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //返回单行数据</span><br><span class="line">    public T querySingle(String sql,Class&lt;T&gt; clazz,Object... parameters)&#123;</span><br><span class="line">        Connection connection = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            connection = JDBCUtilsByDruid.getConnection();</span><br><span class="line">            return qr.query(connection,sql,new BeanHandler&lt;T&gt;(clazz),parameters);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            throw new RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //返回单个数据</span><br><span class="line">    public Object queryScalar(String sql,Object... parameters)&#123;</span><br><span class="line">        Connection connection = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            connection = JDBCUtilsByDruid.getConnection();</span><br><span class="line">            return qr.query(connection,sql,new ScalarHandler(),parameters);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            throw new RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用Filter过滤器-为所有service添加事务"><a href="#使用Filter过滤器-为所有service添加事务" class="headerlink" title="使用Filter过滤器,为所有service添加事务"></a>使用Filter过滤器,为所有service添加事务</h4><p>记得在web.xml中配置<br>注意:为了能让过滤器捕获到异常,所有途经的程序都需要抛出异常,包括Service和Servlet</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class TransactionFilter implements Filter &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void init(FilterConfig filterConfig) throws ServletException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            filterChain.doFilter(servletRequest,servletResponse);</span><br><span class="line">            JDBCUtilsByDruid.commitAndClose();// 提交事务</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            JDBCUtilsByDruid.rollbackAndClose();//回滚事务</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            throw new RuntimeException(e);//把异常抛给Tomcat管理展示友好的错误页面</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void destroy() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="配置错误页面"><a href="#配置错误页面" class="headerlink" title="配置错误页面"></a>配置错误页面</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--error-page标签配置，服务器出错之后，自动跳转的页面--&gt;</span><br><span class="line">&lt;error-page&gt;</span><br><span class="line">    &lt;!--error-code是错误类型--&gt;</span><br><span class="line">    &lt;error-code&gt;500&lt;/error-code&gt;</span><br><span class="line">    &lt;!--location标签表示。要跳转去的页面路径--&gt;</span><br><span class="line">    &lt;location&gt;/pages/error/error500.jsp&lt;/location&gt;</span><br><span class="line">&lt;/error-page&gt;</span><br></pre></td></tr></table></figure>
<p>要保证所有异常能抛到tomcat服务器</p>
<h2 id="阶段七"><a href="#阶段七" class="headerlink" title="阶段七"></a>阶段七</h2><h3 id="使用AJAX为用户名验证绑定失去焦点事件"><a href="#使用AJAX为用户名验证绑定失去焦点事件" class="headerlink" title="使用AJAX为用户名验证绑定失去焦点事件"></a>使用AJAX为用户名验证绑定失去焦点事件</h3><p>1.在用户名栏绑定失去焦点事件,当鼠标离开用户名栏时发送AJAX请求.<br>2.AJAX程序再调用验证用户名的servlet即可</p>
<h3 id="使用AJAX重写加入购物车操作"><a href="#使用AJAX重写加入购物车操作" class="headerlink" title="使用AJAX重写加入购物车操作"></a>使用AJAX重写加入购物车操作</h3><p>这样使得不用每次添加商品时都刷新页面.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected void ajaxAddItem(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;</span><br><span class="line">    // 获取请求的参数 商品编号</span><br><span class="line">    int id = WebUtils.parseInt(req.getParameter(&quot;id&quot;), 0);</span><br><span class="line">    // 调用bookService.queryBookById(id):Book得到图书的信息</span><br><span class="line">    Book book = bookService.queryBookById(id);</span><br><span class="line">    // 把图书信息，转换成为CartItem商品项</span><br><span class="line">    CartItem cartItem = new CartItem(book.getId(),book.getName(),1,book.getPrice(),book.getPrice());</span><br><span class="line">    // 调用Cart.addItem(CartItem);添加商品项</span><br><span class="line">    Cart cart = (Cart) req.getSession().getAttribute(&quot;cart&quot;);</span><br><span class="line">    if (cart == null) &#123;</span><br><span class="line">        cart = new Cart();</span><br><span class="line">        req.getSession().setAttribute(&quot;cart&quot;,cart);</span><br><span class="line">    &#125;</span><br><span class="line">    cart.addItem(cartItem);</span><br><span class="line"></span><br><span class="line">    System.out.println(cart);</span><br><span class="line">    // 最后一个添加的商品名称</span><br><span class="line">    req.getSession().setAttribute(&quot;lastName&quot;, cartItem.getName());</span><br><span class="line"></span><br><span class="line">    //6、返回购物车总的商品数量和最后一个添加的商品名称</span><br><span class="line">    Map&lt;String,Object&gt; resultMap = new HashMap&lt;String,Object&gt;();</span><br><span class="line"></span><br><span class="line">    resultMap.put(&quot;totalCount&quot;, cart.getTotalCount());</span><br><span class="line">    resultMap.put(&quot;lastName&quot;,cartItem.getName());</span><br><span class="line"></span><br><span class="line">    Gson gson = new Gson();</span><br><span class="line">    String resultMapJsonString = gson.toJson(resultMap);</span><br><span class="line"></span><br><span class="line">    resp.getWriter().write(resultMapJsonString);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="javaweb工程架构图"><a href="#javaweb工程架构图" class="headerlink" title="javaweb工程架构图"></a>javaweb工程架构图</h1><p><img src="/images/06B57041BB5B0725C0217A30979DBCAA.png" alt="06B57041BB5B0725C0217A30979DBCAA.png"></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title>设计原则</title>
    <url>/2021/12/28/%E7%AC%94%E8%AE%B0/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</url>
    <content><![CDATA[<h1 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h1><p>一个类或者模块只负责完成一个职责, 不要承担过多的任务.<br>这样操作可以使类或者方法颗粒度更细, 当需要针对特定功能进行修改时, 会影响的范围会变小.<br>并且, 颗粒度更细, 更方便方法进行代码的复用.</p>
<span id="more"></span>
<h1 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h1><p>软件实体(模块,类,方法等)应该对扩展开放, 对修改关闭. 这是因为已经实现的方法是经过时间验证的, 我们不能为了添加功能而对已经构建好的代码添加风险, 所以要尽量使用扩展, 而不是修改.<br>之所以说尽量是因为完全基于开闭原则开放成本及复杂度会升高, 所以要针对情况权衡.</p>
<h1 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h1><p>子类对象能够替换父类对象出现的任何地方, 并且要保证原来程序的逻辑行为不变及正确性不被破坏.<br>这就要求我们不能依靠属性的相似度进行父类的继承, 而是应该根据行为进行父类的继承.<br>子类的前置条件要比父类弱, 这样子类就能用于父类的任何地方, 子类的功能要比父类强, 这样才能在奥卡姆剃刀原则下使用子类.</p>
<h1 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h1><p>不能强制客户依赖他不需要的方法, 奥卡姆剃刀原则的一种体现.<br>这要求我们对方法使用接口, 当需要时就去实现特定的接口组合即可, 这样就能松耦合易重构.</p>
<h1 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h1><p>高层模块不应该依赖底层模块，他们都应该依赖抽象。抽象不应该依赖于细节，细节应该依赖于抽象。<br>前半句具体表现就是不再需要底层模块构建完毕才构建高层模块, 使用接口表示底层的依赖, 直接进行高层的构建. 同时这种操作还可以提高高层或者底层的重用性.<br>后半句指的则是面向接口编程.</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title>mySQL笔记</title>
    <url>/2021/12/03/%E7%AC%94%E8%AE%B0/mySQL%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="前提知识"><a href="#前提知识" class="headerlink" title="前提知识"></a>前提知识</h1><p>MySQL 在 Windows 下不区分大小写，但在 Linux 下默认是区分大小写。因此，数据库名、 表名、字段名，都不允许出现任何大写字母，避免节外生枝。</p>
<span id="more"></span>
<h1 id="数据库指令"><a href="#数据库指令" class="headerlink" title="数据库指令"></a>数据库指令</h1><h2 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h2><table>
<thead>
<tr>
<th>指令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>create database 库名</td>
<td>创建数据库，默认utf8字符集，utf8_general_ci校对</td>
</tr>
<tr>
<td>use database 库名</td>
<td>切换数据库</td>
</tr>
<tr>
<td>character set …</td>
<td>设定字符集</td>
</tr>
<tr>
<td>collate …</td>
<td>设定校对规则 utf8_general_ci(不区分大小写)，utf8_bin(区分)</td>
</tr>
<tr>
<td>show databases</td>
<td>查看当前数据库服务器中所有数据库</td>
</tr>
<tr>
<td>show create database</td>
<td>查看前面创建的数据库信息</td>
</tr>
<tr>
<td>drop database</td>
<td>删库跑路</td>
</tr>
<tr>
<td>mysqldump -u 用户名 -p -B 数据库 &gt; 文件名.sql</td>
<td>(dos)备份数据库</td>
</tr>
<tr>
<td>source 文件名.sql</td>
<td>(mysql命令行)恢复数据库</td>
</tr>
</tbody></table>
<h2 id="表操作、列操作"><a href="#表操作、列操作" class="headerlink" title="表操作、列操作"></a>表操作、列操作</h2><table>
<thead>
<tr>
<th>指令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>desc</td>
<td>查看表结构</td>
</tr>
<tr>
<td>create table 表名(列名，数据格式)</td>
<td>创建表，可以设置字符集，校对规则和引擎</td>
</tr>
<tr>
<td>alter table 表名 add(列名，数据格式)</td>
<td>为表添加列</td>
</tr>
<tr>
<td>alter table 表名 modify(列名，数据格式)</td>
<td>修改列</td>
</tr>
<tr>
<td>alter table 表名 drop(列名)</td>
<td>删列</td>
</tr>
<tr>
<td>not null default ‘内容’</td>
<td>不允许为空，替换为’’内的内容</td>
</tr>
<tr>
<td>delete from 表名</td>
<td>删除数据</td>
</tr>
</tbody></table>
<h2 id="行操作"><a href="#行操作" class="headerlink" title="行操作"></a>行操作</h2><p>select整体语句结构：<br>select…from…group by…having…order by…limit…</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>insert into 表名 (列名) values (值)</td>
<td>插入数据，values后面用多个括号可以添加多条数据，不写列名视为给所有字段添加信息</td>
</tr>
<tr>
<td>update 表名 set 列名=值</td>
<td>修改数据</td>
</tr>
<tr>
<td>where</td>
<td>限定操作执行的范围</td>
</tr>
<tr>
<td>select</td>
<td></td>
</tr>
<tr>
<td>select distinct *或列名 from 表</td>
<td>查表，distinct用于去重</td>
</tr>
<tr>
<td>select 运算 as 别名 from</td>
<td>进行规定的运算并以别名显示</td>
</tr>
<tr>
<td>order by …(desc)</td>
<td>升序(降序)排序</td>
</tr>
</tbody></table>
<h2 id="where子句常用运算符"><a href="#where子句常用运算符" class="headerlink" title="where子句常用运算符"></a>where子句常用运算符</h2><table>
<thead>
<tr>
<th>符号</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>between…and…</td>
<td>-</td>
</tr>
<tr>
<td>in(set)</td>
<td>显示在in列表中的值</td>
</tr>
<tr>
<td>like ‘’</td>
<td>模糊查询(需要配合%使用)</td>
</tr>
<tr>
<td>not like ‘’</td>
<td>模糊查询</td>
</tr>
<tr>
<td>is null</td>
<td>为空</td>
</tr>
</tbody></table>
<h2 id="统计函数"><a href="#统计函数" class="headerlink" title="统计函数"></a>统计函数</h2><table>
<thead>
<tr>
<th>指令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>select count(*)或count(列名)</td>
<td>查询数据的数量</td>
</tr>
<tr>
<td>select sum(列名,列名…) from tablename</td>
<td>对数据求和</td>
</tr>
<tr>
<td>select avg(列名,列名…) from tablename</td>
<td></td>
</tr>
<tr>
<td>select max(列名,列名…) from tablename</td>
<td></td>
</tr>
<tr>
<td>select min(列名,列名…) from tablename</td>
<td></td>
</tr>
<tr>
<td>select …. group by column (having…)</td>
<td>以某列数据为分组进行统计查询，使用having对查询结果进一步过滤</td>
</tr>
</tbody></table>
<h2 id="字符串相关函数"><a href="#字符串相关函数" class="headerlink" title="字符串相关函数"></a>字符串相关函数</h2><table>
<thead>
<tr>
<th>指令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>charset(column)</td>
<td>返回字符串使用的字符集</td>
</tr>
<tr>
<td>concat(column,s2…)</td>
<td>连接字符串，将同行数据拼接后显示</td>
</tr>
<tr>
<td>ucase(column)</td>
<td>转大写显示行</td>
</tr>
<tr>
<td>lcase(column)</td>
<td>转小写</td>
</tr>
<tr>
<td>length(column)</td>
<td>按字符串长度显示(按字节返回)</td>
</tr>
<tr>
<td>replace(column,search_str,replace_str)</td>
<td>查询某列，如果有search_str就替换为replace_str</td>
</tr>
<tr>
<td>substring(column,n1,n2)</td>
<td>截取某列部分字符串(这里字符串计数从1开始)</td>
</tr>
</tbody></table>
<h2 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a>数学函数</h2><table>
<thead>
<tr>
<th>指令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>abc(c)</td>
<td>绝对值</td>
</tr>
<tr>
<td>ceiling(c)</td>
<td>向上取整</td>
</tr>
<tr>
<td>floor(c)</td>
<td>向下取整</td>
</tr>
<tr>
<td>format(c,num)</td>
<td>保留要求的小数位数</td>
</tr>
<tr>
<td>rand(seed)</td>
<td>随机生成数，有seed可以保证随机数不变</td>
</tr>
</tbody></table>
<h2 id="时间函数"><a href="#时间函数" class="headerlink" title="时间函数"></a>时间函数</h2><table>
<thead>
<tr>
<th>指令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>current_date()</td>
<td>当前日期</td>
</tr>
<tr>
<td>current_time()</td>
<td>当前时间</td>
</tr>
<tr>
<td>current_timestamp()</td>
<td>当前时间戳</td>
</tr>
<tr>
<td>date(datetime)</td>
<td>返回datetime的日期部分</td>
</tr>
<tr>
<td>date_add(date,interval 时间)</td>
<td>在date中加上时间或日期</td>
</tr>
<tr>
<td>date_sub(date,interval 时间)</td>
<td>在date中减去时间或日期</td>
</tr>
<tr>
<td>datediff(date1,date2)</td>
<td>返回两个日期差</td>
</tr>
<tr>
<td>now()</td>
<td>当前日期时间</td>
</tr>
<tr>
<td>unix_timestamp</td>
<td>从1970到现在的秒数</td>
</tr>
<tr>
<td>from_unixtime(秒数,’%y-%m-%d’)</td>
<td>秒转日期</td>
</tr>
</tbody></table>
<p>在这些时间前使用year,month,date可以只返回这部分时间</p>
<h2 id="加密和系统函数"><a href="#加密和系统函数" class="headerlink" title="加密和系统函数"></a>加密和系统函数</h2><table>
<thead>
<tr>
<th>指令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>user()</td>
<td>查询用户</td>
</tr>
<tr>
<td>datebase()</td>
<td>数据库名称</td>
</tr>
<tr>
<td>MD5(str)</td>
<td>为字符串算出一个加密字符串</td>
</tr>
</tbody></table>
<h2 id="流程控制函数"><a href="#流程控制函数" class="headerlink" title="流程控制函数"></a>流程控制函数</h2><table>
<thead>
<tr>
<th>指令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>if(expr1,expr2,expr3)</td>
<td>如果expr1为true则返回expr2，如果2也为true返回3</td>
</tr>
<tr>
<td>ifnull(expr1,exp2)</td>
<td>如果expr1不为空则返回expr1，否则返回expr2</td>
</tr>
<tr>
<td>select case when expr1 then expr2 else expr3</td>
<td>如果满足expr1则返回expr2，否则返回expr3</td>
</tr>
</tbody></table>
<h1 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from 表名 limit startIndex,pageSize</span><br></pre></td></tr></table></figure>
<h1 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h1><p>多表查询可以同时生成多表的笛卡尔集以及复用单表的笛卡尔集。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select student.id,student.name,teacher.name from student left join teacher on tid=teacher.id</span><br></pre></td></tr></table></figure>

<h1 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h1><p>select语句可以放入where语句中进行子查询。也可以放入from语句作为临时表进行子查询。<br>可以使用all和any对子select语句进行约束，进行查询。<br>多列子查询：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from emp</span><br><span class="line">	where(deptno,job) = (</span><br><span class="line">			select deptno,job</span><br><span class="line">			from emp</span><br><span class="line">			where ename = &#x27;SMITH&#x27;</span><br><span class="line">			)</span><br></pre></td></tr></table></figure>
<h1 id="表复制"><a href="#表复制" class="headerlink" title="表复制"></a>表复制</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//一个表到另一个表</span><br><span class="line">insert into my_tab01</span><br><span class="line">	(id ,name ,sal ,job ,deptno)</span><br><span class="line">	select empno,ename,sal,job,detno from emp;</span><br><span class="line">//自我复制</span><br><span class="line">insert into my_tab01</span><br><span class="line">	select * from my_tab01;</span><br><span class="line">//复制表结构</span><br><span class="line">create table my_tab02 like my_tab01</span><br></pre></td></tr></table></figure>
<h1 id="去重"><a href="#去重" class="headerlink" title="去重"></a>去重</h1><p>1.创建一张与原表结构相同的临时表<br>2.把原表内容使用select distinct * from把原表复制到另一个表。<br>3.再删除掉原表数据<br>4.把临时表数据复制给原表，删除临时表</p>
<h1 id="合并查询"><a href="#合并查询" class="headerlink" title="合并查询"></a>合并查询</h1><p>可以使用union all 连接两个select语句进行合并查询(不会去重)，union可以去重。</p>
<h1 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h1><p>引入：当使用多表查询对员工与部门表进行查询时，无法显示出没有员工的部门。<br>左外连接：左侧表完全显示。<br>from 表1 left join 表2 on 条件。<br>右外连接：右侧表完全显示。<br>from 表1 right join 表2 on 条件。</p>
<h1 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h1><p>not null，unique，primary key，foreign key，check。</p>
<h2 id="主键primary-key"><a href="#主键primary-key" class="headerlink" title="主键primary key"></a>主键primary key</h2><p>用于唯一的标识表行数据，主键约束后该列不能重复且不能为空。</p>
<h2 id="外键foreign-key"><a href="#外键foreign-key" class="headerlink" title="外键foreign key"></a>外键foreign key</h2><p>当主表与副表有一共有列，且要求副表列中出现的元素属于主表中时，可以使用外键对副表进行约束。<br>foreign key (副表列名) references 主表表名(列名)</p>
<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p>提高数据库性能。<br>索引类型：<br>1.主键索引：主键自动为索引<br>2.唯一索引：unique修饰自动为索引<br>3.普通索引：手动指定<br>4.全文索引：开发中一般不用，使用全文搜索Solr和ElasticSearch</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//创建索引(会占用空间),只对这列查询提速</span><br><span class="line">create (unique)index 索引名 on 表名(列名)</span><br><span class="line">//添加主键(索引)</span><br><span class="line">alert table 表名 add index 索引名 (列名)</span><br><span class="line">//删除索引</span><br><span class="line">drop index 索引名 on 表名</span><br><span class="line">//删除主键索引</span><br><span class="line">alert table 表名 primary key</span><br><span class="line">//查询索引</span><br><span class="line">show index from 表名</span><br><span class="line">show keys from 表名</span><br><span class="line">desc 表名</span><br></pre></td></tr></table></figure>
<h2 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h2><p>1.最左前缀法则：如果建立的是复合索引，索引的顺序要按照建立的顺序，即从左到右。<br>    这是因为复合索引是多个字段作为索引存放在b+树中，且存放顺序是左边字段的优先级要高于右边的字段，一旦跳过左边字段直接查找右边字段，右边的字段是乱序的。<br>2.不要对索引进行计算，函数以及转型，会导致索引失效。<br>3.不可以在范围查找语句右边使用索引，会导致索引失效。<br>    因为b+树的叶节点是是一个有序链表，当进行范围查找时会会把整段链表直接取出等待下一步查找，这种情况下，除非取出的这整一段的范围查找的字段都相等，否则下一个字段一定是乱序的。<br>4.减少select* 的使用，尽量进行覆盖索引，即select查询字段与where中索引字段一致。<br>    而且在使用order by时要进量使用覆盖索引，因为不使用覆盖索引进行排序会发生文件内排序。或者在java中进行排序。<br>5.不要在使用like查找索引字段时在字段前面加%。<br>    这是因为字符串在b+树里存储的时候，是按照ascii码的大小存储的，此时，这个结构与复合索引结构是一样的，当为字符串增加前缀时，违反了最左前缀法则。</p>
<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><table>
<thead>
<tr>
<th>指令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>set autocommit = 0</td>
<td>设为手动提交事务</td>
</tr>
<tr>
<td>start transaction</td>
<td>开始事务</td>
</tr>
<tr>
<td>savepoint 点名</td>
<td>设置保存点</td>
</tr>
<tr>
<td>rollback to 点名</td>
<td>回滚</td>
</tr>
<tr>
<td>rollback</td>
<td>回滚至开始</td>
</tr>
<tr>
<td>commit</td>
<td>提交事务</td>
</tr>
</tbody></table>
<h2 id="四种隔离级别"><a href="#四种隔离级别" class="headerlink" title="四种隔离级别"></a>四种隔离级别</h2><p>脏读:一个事务读到了另一个事务未提交的的修改。<br>不可重复读:一个事务多次查询，由于其他事务的修改和删除导致每次读取内容不同。<br>幻读:一个事务多次查询，由于其他事务的插入操作导致每次读取内容不同。<br>不可重复读可以通过对数据的加锁解决，但幻读需要在数据间加间隙锁才能解决。</p>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
<th>加锁</th>
</tr>
</thead>
<tbody><tr>
<td>read uncommitted：可以读到未提交的其他事务</td>
<td>V</td>
<td>V</td>
<td>V</td>
<td>X</td>
</tr>
<tr>
<td>read committed：可以读到已经提交的其他事务</td>
<td>X</td>
<td>V</td>
<td>V</td>
<td>X</td>
</tr>
<tr>
<td>repeatable read：只能读到开启事务前的数据</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
</tr>
<tr>
<td>serializable:可串行化</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>V</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>指令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>set session transaction isolation level 隔离级别</td>
<td>设置隔离级别</td>
</tr>
<tr>
<td>set global transaction isolation level 隔离级别</td>
<td>设置系统隔离级别</td>
</tr>
<tr>
<td>select @@tx_isolation</td>
<td>查看当前会话隔离级别</td>
</tr>
<tr>
<td>select @@global.tx_isolation</td>
<td></td>
</tr>
</tbody></table>
<h1 id="引擎"><a href="#引擎" class="headerlink" title="引擎"></a>引擎</h1><table>
<thead>
<tr>
<th>特点</th>
<th>myisam</th>
<th>innodb</th>
<th>memory</th>
</tr>
</thead>
<tbody><tr>
<td>批量插入速度</td>
<td>高</td>
<td>低</td>
<td>高(内存存储)</td>
</tr>
<tr>
<td>事务安全</td>
<td></td>
<td>支持</td>
<td></td>
</tr>
<tr>
<td>全文索引</td>
<td>支持</td>
<td></td>
<td></td>
</tr>
<tr>
<td>锁机制</td>
<td>表锁</td>
<td>行锁</td>
<td>表锁</td>
</tr>
<tr>
<td>存储限制</td>
<td>无</td>
<td>64TB</td>
<td>有</td>
</tr>
</tbody></table>
<p>1.myisam不支持事务，也不支持外键，但其访问速度快，对事务完整性没要求。<br>2.innodb为事务安全型引擎。但是比起myisam，innodb写的效率会差，且要占用空间保留索引。<br>3.memory引擎基于hash存储在内存中，访问速度快，但一旦服务关闭，数据就会丢失，表的结构还在。</p>
<p>当innodb的索引失效时，这时没有索引导致无法再使用行锁，会自动升级为表锁，大大降低并发度。<br>行锁：锁力度小，开销大，上锁速度慢，会出现死锁，并发高。<br>表锁：锁力度大，开销小，上锁速度快，不会出现死锁，并发低。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title>设计模式</title>
    <url>/2021/12/14/%E7%AC%94%E8%AE%B0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="创建型"><a href="#创建型" class="headerlink" title="创建型"></a>创建型</h1><h2 id="单例模式-Singleton"><a href="#单例模式-Singleton" class="headerlink" title="单例模式(Singleton)"></a>单例模式(Singleton)</h2><p>推荐使用饿汉式单例模式, 懒汉式即使使用双重锁也会因为指令重排的原因有可能产生多余的实例.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Singleton&#123;</span><br><span class="line">	//这个实例对象会在类加载的时候创建,即调用getInstance方法时</span><br><span class="line">	private static Singleton singleton = new Singleton();</span><br><span class="line">	//必须私有化构造器防止被其他程序调用</span><br><span class="line">	private Single() &#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	//用于外部获取实例</span><br><span class="line">	public static Singleton getInstance()&#123;</span><br><span class="line">		return singleton;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="工厂模式-Factory-Method"><a href="#工厂模式-Factory-Method" class="headerlink" title="工厂模式(Factory Method)"></a>工厂模式(Factory Method)</h2><p>将模板模式应用于生成实例,就演变成了工厂模式.<br>定义一个抽象的产品类, 再定义一些抽象的方法. 接着定义一个抽象的工厂类, 这个工厂只规定用于生产这个抽象的产品类, 剩下的只定义抽象的生产方法.<br>此时就像一个空的工厂, 我们只知道这个工厂能生产具有某些方法的产品, 可以有哪些方法用于生产产品.<br>接着出现一个施工队, 他们的产品有这个工厂产品的方法, 他们的生产产品的流程也符合工厂的要求, 那么他们就可以带着产品功能图和生产设计图进驻这个工厂, 用这个工厂生产他们的产品.<br>当出现其他与这个施工队类似的施工队, 也可以进驻这个工厂生产产品.</p>
<p>这种方法中, 框架不需要用new关键字来生产实例, 而是调用实例专用的方法生成实例, 实现了父类与具体类的解耦.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//framework包</span><br><span class="line">public abstract class Product &#123;</span><br><span class="line">    public abstract void use();</span><br><span class="line">&#125;</span><br><span class="line">public abstract class Factory &#123;</span><br><span class="line">    //生产流程是写死的,但生产方法并不写死</span><br><span class="line">    public final Product create (String owner) &#123;</span><br><span class="line">        Product p = createProduct(owner);</span><br><span class="line">        registerProduct(p);</span><br><span class="line">        return p;</span><br><span class="line">    &#125;</span><br><span class="line">    protected abstract Product createProduct (String owner);</span><br><span class="line">    protected abstract void registerProduct (Product product);</span><br><span class="line">&#125;</span><br><span class="line">//产品包</span><br><span class="line">public class IDCard extends Product&#123;</span><br><span class="line">    private String owner;</span><br><span class="line">    private int id;</span><br><span class="line">    IDCard(String owner) &#123;</span><br><span class="line">        System.out.println(&quot;制作了&quot;+owner+&quot;的IDCard&quot;);</span><br><span class="line">        this.owner = owner;</span><br><span class="line">        Random random = new Random();</span><br><span class="line">        id = random.nextInt(1000000);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void use() &#123;</span><br><span class="line">        System.out.println(&quot;使用&quot;+owner+&quot;IDCard&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getOwner() &#123;</span><br><span class="line">        return owner;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getId() &#123;</span><br><span class="line">        return id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class IDCardFactory extends Factory&#123;</span><br><span class="line">    private Map owners = new HashMap();</span><br><span class="line">    @Override</span><br><span class="line">    protected Product createProduct(String owner) &#123;</span><br><span class="line">        return new IDCard(owner);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void registerProduct(Product product) &#123;</span><br><span class="line">        owners.put(((IDCard)product).getId(),((IDCard)product).getOwner());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Map getOwners() &#123;</span><br><span class="line">        return owners;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//main函数</span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Factory factory = new IDCardFactory();</span><br><span class="line">        Product product1 = factory.create(&quot;小明&quot;);</span><br><span class="line">        Product product2 = factory.create(&quot;小黑&quot;);</span><br><span class="line">        Product product3 = factory.create(&quot;小红&quot;);</span><br><span class="line">        product1.use();</span><br><span class="line">        product2.use();</span><br><span class="line">        product3.use();</span><br><span class="line">        System.out.println(((IDCardFactory)factory).getOwners());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="建造者模式-Builder"><a href="#建造者模式-Builder" class="headerlink" title="建造者模式(Builder)"></a>建造者模式(Builder)</h2><p>建造者模式与工厂模式的区别:工厂模式是使用factory提供的一系列方法组装成对象, 它像流水线, 更注重对象的生成. 而建造者模式有builder与director, builder只抽象化要生成对象的各种方法并由子类实现, 而对象的组装在director, 那我们就能使用不同的director生成不同结构的对象. 而factory因为是一体的无法随意更改组装的顺序.<br>建造者模式更适合创建复杂的对象, 更注重构建的过程.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public abstract class Builder&#123;</span><br><span class="line">	public abstract void BuildPart1();</span><br><span class="line">	public abstract void BuildPart2();</span><br><span class="line">	public abstract void BuildPart3();</span><br><span class="line">&#125;</span><br><span class="line">public class ABuilder extend Builder&#123;</span><br><span class="line">	//实现方法</span><br><span class="line">&#125;</span><br><span class="line">public class Director&#123;</span><br><span class="line">	//组装步骤</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="结构型"><a href="#结构型" class="headerlink" title="结构型"></a>结构型</h1><h2 id="适配器模式-Adapter"><a href="#适配器模式-Adapter" class="headerlink" title="适配器模式(Adapter)"></a>适配器模式(Adapter)</h2><p>我们手上有一个220v的电源, 电脑需要12v的电源, 这个220v的电源具备可以转换为12v的能力, 我们就可以在他们之间添加一个适配器(我们不能期望给水龙头添加一个适配器让它给电脑提供12v的电压).<br>这样处理我们就能在不修改220v电源的情况下产生12v的电源, 这个220v的电源有其他需求时仍可以使用.</p>
<h3 id="什么时候使用"><a href="#什么时候使用" class="headerlink" title="什么时候使用"></a>什么时候使用</h3><p>当我们已经有了一些充分测试过的类, 我们更愿意重复的利用他们. 利用他们可以更方便的生成新方法, 当出现bug时, 也只需要排查适配器的类即可.<br>实际上我们在让现有类实现新接口时, 总是想着稍微修改一点现有代码即可, 但这意味着必须重新对这整段代码进行测试.<br>这个模式也方便我们进行版本的升级.</p>
<h3 id="使用继承的适配器"><a href="#使用继承的适配器" class="headerlink" title="使用继承的适配器"></a>使用继承的适配器</h3><p>需求:要给字符串加(“”)和”()”两种修饰模式, 且这个需求是接口.<br>持有:可以给字符串加””和()两个方法<br>适配器:继承持有的两个方法,用于实现需求</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Banner &#123;</span><br><span class="line">    String string;</span><br><span class="line">    public Banner(String string) &#123;</span><br><span class="line">        this.string = string;</span><br><span class="line">    &#125;</span><br><span class="line">    public void showWithParen()&#123;</span><br><span class="line">        string = &quot;(&quot;+string+&quot;)&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    public void showWithQuotainMark()&#123;</span><br><span class="line">        string = &quot;\&quot;&quot;+string+&quot;\&quot;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public interface Print &#123;</span><br><span class="line">    public abstract void printType1();</span><br><span class="line">    public abstract void printType2();</span><br><span class="line">&#125;</span><br><span class="line">public class PrintBanner extends Banner implements Print&#123;</span><br><span class="line">    //因为父类没有无参构造器,所以必须写一个构造器</span><br><span class="line">    public PrintBanner(String string) &#123;</span><br><span class="line">        super(string);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void printType1() &#123;</span><br><span class="line">        showWithParen();</span><br><span class="line">        showWithQuotainMark();</span><br><span class="line">        System.out.println(string);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void printType2() &#123;</span><br><span class="line">        showWithQuotainMark();</span><br><span class="line">        showWithParen();</span><br><span class="line">        System.out.println(string);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">    	//这样操作我们就无需在main中修改其他内容</span><br><span class="line">        Print print = new PrintBanner(&quot;hello&quot;);</span><br><span class="line">        print.printType1();</span><br><span class="line">        print = new PrintBanner(&quot;hello&quot;);</span><br><span class="line">        print.printType2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用委托的适配器"><a href="#使用委托的适配器" class="headerlink" title="使用委托的适配器"></a>使用委托的适配器</h3><p>但当上面那种情况出现的需求不是接口又该怎么办呢?<br>这时我们应该采用委托的方式,不再由PrintBanner实现需求, 而是把需求委托给Banner.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Banner &#123;</span><br><span class="line">    String string;</span><br><span class="line">    public Banner(String string) &#123;</span><br><span class="line">        this.string = string;</span><br><span class="line">    &#125;</span><br><span class="line">    public void showWithParen()&#123;</span><br><span class="line">        string = &quot;(&quot;+string+&quot;)&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    public void showWithQuotainMark()&#123;</span><br><span class="line">        string = &quot;\&quot;&quot;+string+&quot;\&quot;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public abstract class Print &#123;</span><br><span class="line">    public abstract void printType1();</span><br><span class="line">    public abstract void printType2();</span><br><span class="line">&#125;</span><br><span class="line">public class PrintBanner extends Print&#123;</span><br><span class="line">    private Banner banner;</span><br><span class="line">    //我们使用PrintBanner的构造器对Banner的构造器进行初始化</span><br><span class="line">    public PrintBanner(String string) &#123;</span><br><span class="line">        this.banner = new Banner(string);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void printType1() &#123;</span><br><span class="line">        banner.showWithParen();</span><br><span class="line">        banner.showWithQuotainMark();</span><br><span class="line">        System.out.println(banner.string);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void printType2() &#123;</span><br><span class="line">        banner.showWithQuotainMark();</span><br><span class="line">        banner.showWithParen();</span><br><span class="line">        System.out.println(banner.string);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Print print = new PrintBanner(&quot;hello&quot;);</span><br><span class="line">        print.printType1();</span><br><span class="line">        print = new PrintBanner(&quot;hello&quot;);</span><br><span class="line">        print.printType2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="装饰模式-Decorator"><a href="#装饰模式-Decorator" class="headerlink" title="装饰模式(Decorator)"></a>装饰模式(Decorator)</h2><p>定义一个抽象的被装饰对象, 定义个抽象的装饰方法类和几个具体的被装饰的类去继承这个抽象类, 这使得装饰品与被装饰品具有了同样的方法, 形成了一致性. 再让装饰品的抽象父类持有一个被装饰品的抽象对象, 通过构造器中放入不同的被装饰品就能取得它们的属性,方便进行装饰.</p>
<h2 id="代理模式-Proxy"><a href="#代理模式-Proxy" class="headerlink" title="代理模式(Proxy)"></a>代理模式(Proxy)</h2><p>实现方法,让代理对象与被代理对象继承同一个接口, 当不需要被代理对象出面时, 调用代理对象的方法会直接返回需要的内容, 当这个方法需要代理对象出面时, 判断是否创建了被代理对象, 如果没创建则创建一个被代理的对象并保存它, 然后再让被代理对象出面.</p>
<h1 id="行为型"><a href="#行为型" class="headerlink" title="行为型"></a>行为型</h1><h2 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h2><h2 id="模板模式-Template-Method"><a href="#模板模式-Template-Method" class="headerlink" title="模板模式(Template Method)"></a>模板模式(Template Method)</h2><p>模板模式是一种体现多态的设计模式, 平时使用也很常见.<br>定义抽象父类, 由不同子类实现这些方法, 我们可以统一编译父类, 由不同子类运行. 这样无论在父类型的变量中保存哪个子类的实例, 程序都可以正常工作(LSP原则).<br>它的优点在于可以复用父类的一些方法, 对代码的修改也更简单.</p>
<h2 id="策略模式-Strategy"><a href="#策略模式-Strategy" class="headerlink" title="策略模式(Strategy)"></a>策略模式(Strategy)</h2><p>将一些可以替换的算法作为同一strategy抽象类的不同抽象方法去实现. 在外部使用策略时通过导入不同的子类对象实现, 方便的算法的替换.</p>
<h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><h2 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h2>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title>leetcode测试框架搭建</title>
    <url>/2021/12/15/%E9%A1%B9%E7%9B%AE/leetcode%E8%A7%A3%E9%A2%98%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<p>为了方便leetcode的数据在idea中使用, 决定搭建一个测试框架.<br>要求:调用一个方法, 在方法参数中写入要调用的方法以及其需要的参数可以直接进行方法的调用.<br>所有输入为字符串, 要求可以通过要调用的方法判断参数需要转换的类型.</p>
<span id="more"></span>
<p>创建一个solution方法, 这里用于接收调用的函数名称以及其参数并将其实现.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void solution(String methodStr,String...parameters) throws NoSuchMethodException, InvocationTargetException, IllegalAccessException, ClassNotFoundException &#123;</span><br><span class="line">        //我们要把method传给一个方法,让它用拿到的method取得方法库中的方法</span><br><span class="line">        Methods methods = new Methods();</span><br><span class="line">        Class cls = methods.getClass();</span><br><span class="line">        Object[] objects = new Object[parameters.length];</span><br><span class="line">        Method[] methodsArray = cls.getMethods();</span><br><span class="line">        Method method = null;</span><br><span class="line">        for (Method m:methodsArray)&#123;</span><br><span class="line">            if (m.getName().equals(methodStr))&#123;</span><br><span class="line">                method = m;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();</span><br><span class="line">        int i = 0;</span><br><span class="line">        for (String parameter:parameters)&#123;</span><br><span class="line">            //在这里调用一个方法,这个方法要拿到str以及一个class对象</span><br><span class="line">            //并将这个str转换为这个class对象</span><br><span class="line">            Class clazz = parameterTypes[i];</span><br><span class="line">            InvokParameter a = new InvokParameter();</span><br><span class="line">            objects[i] = a.invokParameter(parameter,clazz);</span><br><span class="line">        &#125;</span><br><span class="line">        Object answer = method.invoke(methods,objects);</span><br><span class="line">        //在这里要写一个方法,能够根据返回类型做出不同输出</span><br><span class="line">        Print print = new Print();</span><br><span class="line">        print.InvokePrint(answer,method.getReturnType());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>创建一个方法库, 里面存放各种需要被调用的方法, 等待被调用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Methods &#123;</span><br><span class="line">    public char firstUniqChar(String s) &#123;</span><br><span class="line">        char[] chars = s.toCharArray();</span><br><span class="line">        ArrayList&lt;Character&gt; answerList = new ArrayList&lt;&gt;();</span><br><span class="line">        ArrayList&lt;Character&gt; trashList = new ArrayList&lt;&gt;();</span><br><span class="line">        for (char o:chars)&#123;</span><br><span class="line">            if (!answerList.contains(o)&amp;&amp;!trashList.contains(o))&#123;</span><br><span class="line">                answerList.add(o);</span><br><span class="line">            &#125;else if (answerList.contains(o))&#123;</span><br><span class="line">                answerList.remove(Character.valueOf(o));</span><br><span class="line">                trashList.add(o);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (answerList.size()==0)&#123;</span><br><span class="line">            return &#x27; &#x27;;</span><br><span class="line">        &#125;</span><br><span class="line">        char answer = answerList.get(0);</span><br><span class="line">        return answer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建一个InvokeParameter类, 它要提供一个可以实现参数注入的方法, 以及各种参数注入的具体方法.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class InvokParameter &#123;</span><br><span class="line">    public Object invokParameter(String str, Class clazz) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException &#123;</span><br><span class="line">        String clazzName = clazz.getName();</span><br><span class="line">        //在这里处理一下类名</span><br><span class="line">        String[] split = clazzName.split(&quot;\\.&quot;);</span><br><span class="line">        String plus = &quot;ChangeTo&quot;;</span><br><span class="line">        String methodName = plus+split[split.length-1];</span><br><span class="line">        Method method = this.getClass().getMethod(methodName,String.class);</span><br><span class="line">        return method.invoke(this,str);</span><br><span class="line">    &#125;</span><br><span class="line">    public Object ChangeToString(String str)&#123;</span><br><span class="line">        return str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建一个Print类,用于输出各种格式的数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*这个类存放各种数据的打印方法*/</span><br><span class="line">public class Print &#123;</span><br><span class="line">    public void InvokePrint(Object obj,Class clazz) throws NoSuchMethodException, InvocationTargetException, IllegalAccessException &#123;</span><br><span class="line">        String methodName = TrimClassName.TrimClassName(clazz,&quot;Print&quot;);</span><br><span class="line">        Method method = this.getClass().getMethod(methodName, Object.class);</span><br><span class="line">        method.invoke(this,obj);</span><br><span class="line">    &#125;</span><br><span class="line">    //输出int[]</span><br><span class="line">    public void PrintI(Object obj)&#123;</span><br><span class="line">        int[] ints = (int[]) obj;</span><br><span class="line">        StringBuffer str = new StringBuffer(&quot;[&quot;);</span><br><span class="line">        for (int o:ints)&#123;</span><br><span class="line">            str.append(o);</span><br><span class="line">            str.append(&#x27;,&#x27;);</span><br><span class="line">        &#125;</span><br><span class="line">        str.deleteCharAt(str.length()-1);</span><br><span class="line">        str.append(&#x27;]&#x27;);</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程基础</title>
    <url>/2021/11/27/%E7%AC%94%E8%AE%B0/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h1><p>1.进程要分配一大部分的内存，而线程只需要分配一部分栈就可以了.<br>2.一个程序至少有一个进程,一个进程至少有一个线程.<br>3.进程是资源分配的最小单位，线程是程序执行的最小单位。<br>4.一个线程可以创建和撤销另一个线程，同一个进程中的多个线程之间可以并发执行</p>
<span id="more"></span>    
<p>线程栈：<br>1.方便函数调用，当调用子函数时，可以把当前函数的信息压入栈中，<br>再在栈的顶端压入返回地址，当子函数调用结束后再弹栈即可。<br>2.多任务支持，当有必要进行任务切换时，对当前信息存储，再读入<br>另一个任务的信息即可。</p>
<h1 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h1><p>并发：单一cpu交替执行多任务，宏观表现同时进行的情况称为并发。<br>并行：多个cpu同时执行多个任务，宏观表现与微观均为同时进行。</p>
<h1 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h1><p>1.继承Thread类，重写run方法<br>2.实现Runnabel接口，重写run方法<br>实现Runnabel接口的启动：重写完run方法后，在主方法中创建对象，再把这个对象<br>交给Thread进行静态代理，再启动对应的thread。</p>
<h1 id="停止线程"><a href="#停止线程" class="headerlink" title="停止线程"></a>停止线程</h1><p>1.线程执行完毕自动停止<br>2.在run方法中使用一个变量控制线程，想要停止时改变run方法中的这个变量。</p>
<h1 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h1><p>1.setName<br>2.getName<br>3.start<br>4.run<br>5.setPriority<br>6.getPriority<br>7.sleep<br>8.interrupt//一般用于中断休眠<br>9.yield//尝试性礼让<br>10.join//插队</p>
<h1 id="释放锁的情况"><a href="#释放锁的情况" class="headerlink" title="释放锁的情况"></a>释放锁的情况</h1><p>1.线程结束 2.线程异常 3.线程中断 4.wait()<br>sleep，yield，suspend不会释放锁。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title>框架</title>
    <url>/2021/12/30/%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90/%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<h1 id="什么是IOC"><a href="#什么是IOC" class="headerlink" title="什么是IOC"></a>什么是IOC</h1><p>ioc就是控制反转, 它是一种思想, 不再自己主动创建依赖对象, 而是把创建和查找依赖对象的权限交给容器.</p>
<h1 id="IOC与DI"><a href="#IOC与DI" class="headerlink" title="IOC与DI"></a>IOC与DI</h1><p>DI是IOC的一种实现方式, 它指的是在ioc容器运行期间, 利用依赖关系进行注入, 从而实现解耦.</p>
<h1 id="什么是DI"><a href="#什么是DI" class="headerlink" title="什么是DI"></a>什么是DI</h1><p>DI即依赖注入, 它是接口编程的一种特殊表现, 在注入时不关注细节, 而是依赖于抽象, 从而实现解耦.</p>
<h1 id="什么是AOP"><a href="#什么是AOP" class="headerlink" title="什么是AOP"></a>什么是AOP</h1><p>AOP即面向切面编程,利用AOP可以对业务逻辑的各个部分进行隔离,降低耦合度.<br>OOP使代码被划分到了一个个类中, 降低了代码的复杂度, 使类可复用, 但这样划分会使得代码重复度增高.  因此产生了AOP, 它是一种在运行时, 动态的将代码切入到指定类的指定方法的指定位置上的一种编程思想.<br>这种编程思想也很好的符合了开闭原则, 对扩展开放, 对修改关闭.</p>
]]></content>
      <categories>
        <category>知识点解析</category>
      </categories>
  </entry>
  <entry>
    <title>项目架构</title>
    <url>/2021/12/30/%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90/%E9%A1%B9%E7%9B%AE%E6%9E%B6%E6%9E%84/</url>
    <content><![CDATA[<h1 id="什么叫高内聚低耦合"><a href="#什么叫高内聚低耦合" class="headerlink" title="什么叫高内聚低耦合"></a>什么叫高内聚低耦合</h1><p>低耦合是要让各个模块间尽可能相互独立, 当一个模块出现问题时, 耦合度越低, 影响的范围也就越低.<br>高内聚是尽可能的让模块的单一性更高, 这样它所需要的大部分内容都依赖于自身, 对外的耦合度也可以降低.</p>
]]></content>
      <categories>
        <category>知识点解析</category>
      </categories>
  </entry>
  <entry>
    <title>二叉树最近公共祖先</title>
    <url>/2021/12/30/leetcode%E9%A2%98%E8%A7%A3/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>
<span id="more"></span>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>如何是公共祖先, 两种情况, 一个是另一个子树, 或者是一个节点的左右子树各有一个目标节点.<br>使用递归,再进行合理的剪枝.如何进行剪枝? 当两个节点都找到时就直接返回, 实现剪枝.</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;TreeNode&gt; list1;</span><br><span class="line">ArrayList&lt;TreeNode&gt; list2;</span><br><span class="line">TreeNode res;</span><br><span class="line">public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;</span><br><span class="line">    SearchNode(root, p.val, q.val);</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line">public int SearchNode(TreeNode node,int target1,int target2)&#123;</span><br><span class="line">    //对树进行遍历,找到目标值时返回1</span><br><span class="line">    if (node==null)&#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;else if (node.val==target1||node.val==target2)&#123;</span><br><span class="line">        int num1 = SearchNode(node.left,target1,target2);</span><br><span class="line">        if (num1&gt;0)&#123;</span><br><span class="line">            //说明是父子关系</span><br><span class="line">            res = node;</span><br><span class="line">            return 2;</span><br><span class="line">        &#125;</span><br><span class="line">        int num2 =SearchNode(node.right,target1,target2);</span><br><span class="line">        if (num2&gt;0)&#123;</span><br><span class="line">            //说明是父子关系</span><br><span class="line">            res = node;</span><br><span class="line">            return 2;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        int num1 = SearchNode(node.left,target1,target2);</span><br><span class="line">        //剪枝返回</span><br><span class="line">        if (num1==2)&#123;</span><br><span class="line">            return 2;</span><br><span class="line">        &#125;</span><br><span class="line">        int num2 =SearchNode(node.right,target1,target2);</span><br><span class="line">        //剪枝返回</span><br><span class="line">        if (num2==2)&#123;</span><br><span class="line">            return 2;</span><br><span class="line">        &#125;</span><br><span class="line">        if (num1+num2&gt;1)&#123;</span><br><span class="line">            res = node;</span><br><span class="line">            return 2;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            return num1+num2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode解析</category>
        <category>最优</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>不用加减乘除做加法</title>
    <url>/2021/12/31/leetcode%E9%A2%98%E8%A7%A3/%E4%B8%8D%E7%94%A8%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E5%81%9A%E5%8A%A0%E6%B3%95/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>写一个函数，求两个整数之和，要求在函数体内不得使用 “+”、“-”、“*”、“/” 四则运算符号。</p>
<span id="more"></span>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>两个数字的加和, 可以分为进位以及非进位两个数字的加和. 把这种情况转换到二进制的情况, 非进位计算就是位的异或运算, 而进位可以转化为位与运算且左移一位. 进行递归, 直到不需要进位为止.</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int add(int a, int b) &#123;</span><br><span class="line">    //设a是被</span><br><span class="line">    int c = a^b;</span><br><span class="line">    int d = (a&amp;b)&lt;&lt;1;</span><br><span class="line">    if (d==0)&#123;</span><br><span class="line">        return c;</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        return add(c,d);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode解析</category>
        <category>中等</category>
      </categories>
      <tags>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉搜索树的后序遍历序列</title>
    <url>/2021/12/31/leetcode%E9%A2%98%E8%A7%A3/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 true，否则返回 false。假设输入的数组的任意两个数字都互不相同</p>
<span id="more"></span>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>后序遍历的结构是左子树,右子树,根,所以最好是倒序进行遍历.<br>采用递归思想, 以根节点为依据查找左右子树, 把左右子树再交给下一级的递归.</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int[] postorder;</span><br><span class="line">public boolean verifyPostorder(int[] postorder) &#123;</span><br><span class="line">    //后续遍历是左右根顺序</span><br><span class="line">    //从根判断比较简单,所以倒序遍历</span><br><span class="line">    this.postorder = postorder;</span><br><span class="line">  </span><br><span class="line">    return checkTree(postorder.length-1,0);</span><br><span class="line">&#125;</span><br><span class="line">public boolean checkTree(int start,int end)&#123;</span><br><span class="line">    //是否判断结束</span><br><span class="line">    if (start-end&lt;=0)&#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        //划分出左右子树</span><br><span class="line">        for (int i = start-1;i&gt;=end;i--)&#123;</span><br><span class="line">            if (postorder[i]&lt;postorder[start])&#123;</span><br><span class="line">                //此时end到i都应该是左子树,应该都小于目标数</span><br><span class="line">                for (int j = i;j&gt;=end;j--)&#123;</span><br><span class="line">                    if (postorder[j]&gt;postorder[start])&#123;</span><br><span class="line">                        return false;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                return checkTree(i,end)&amp;&amp;checkTree(start-1,i+1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //到这里说明剩下的都是右子树</span><br><span class="line">        return checkTree(start-1,end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode解析</category>
        <category>中等</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>数组中数字出现的数字2</title>
    <url>/2022/01/01/leetcode%E9%A2%98%E8%A7%A3/%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E7%9A%84%E6%95%B0%E5%AD%972/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>在一个数组 nums 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。</p>
<span id="more"></span>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>我们要做的是去除所有出现三次的数字, 保留只出现一次的数字. 可以考虑构建一个自动机, 让这个自动机在接收第三个相同的数字后消失. 所以可以制造一个下面的自动机.<br><img src="/images/0C666D0E71EFBBBAA1AD1AFB64160452.png" alt="自动机图片"><br>最原始的办法就是用一个32位的3进制数字进行状态转换. 所以可以使用二进制对上面的自动机进行改进, 就有了下面的状态转换表, 计算后得到对应得状态转换方程.<br><img src="/images/Inked0C666D0E71EFBBBAA1AD1AFB64160457.png" alt="状态转换表"><br>知道了状态转换方程就很好做了.<br>如何拿x,y得出最后得答案呢? 因为只有一次出现,b即为答案.</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int singleNumber(int[] nums) &#123;</span><br><span class="line">    int a = 0;</span><br><span class="line">    int b = 0;</span><br><span class="line">    for(int i :nums)&#123;</span><br><span class="line">        int d = ~a&amp;(i^b);</span><br><span class="line">        int c = (~i&amp;a&amp;~b)|(i&amp;~a&amp;b);</span><br><span class="line">        a = c;</span><br><span class="line">        b = d;</span><br><span class="line">    &#125;</span><br><span class="line">    return b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode解析</category>
        <category>最优</category>
      </categories>
      <tags>
        <tag>位运算</tag>
        <tag>自动机</tag>
      </tags>
  </entry>
  <entry>
    <title>数组中数字出现的次数1</title>
    <url>/2021/12/31/leetcode%E9%A2%98%E8%A7%A3/%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B01/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。</p>
<span id="more"></span>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>首先要知道两个相同的数字对一个数字进行异或后这个数字是不会变化的. 如果这道题只有一个单数字就可以直接通过异或运算取得. 但是这道题有两个, 有两个的话这两个数字至少有一位不相同.<br>如何寻找这两个数字的第一个不同的数? 通过它们的异或结果可以取得.<br>如单独将这个数字提取出来? 一个数字与其负数的二进制关系是按位取反加一, 我们要找到这个数字的与其相反数进行按位与运算就可以得到二进制中只有那一位为1的数字.<br>我们使用得到的这个数字再与数组进行或运算, 就能成功实现分组. 这里也只有或运算会仅影响指定的位.</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int[] singleNumbers(int[] nums) &#123;</span><br><span class="line">    int num = 0;</span><br><span class="line">    //取得两个数的异或运算结果</span><br><span class="line">    for (int i:nums)&#123;</span><br><span class="line">        num ^= i;</span><br><span class="line">    &#125;</span><br><span class="line">    //生成分组数字</span><br><span class="line">    int target = num&amp;(-num);</span><br><span class="line">    int[] res = new int[2];</span><br><span class="line">    for (int i:nums)&#123;</span><br><span class="line">        if ((i|target)==i)&#123;</span><br><span class="line">            res[0] ^= i;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            res[1] ^= i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode解析</category>
        <category>最优</category>
      </categories>
      <tags>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>校园卡项目</title>
    <url>/2021/12/31/%E9%A1%B9%E7%9B%AE/%E6%A0%A1%E5%9B%AD%E5%8D%A1%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<h1 id="项目架构"><a href="#项目架构" class="headerlink" title="项目架构"></a>项目架构</h1><h2 id="学生端"><a href="#学生端" class="headerlink" title="学生端"></a>学生端</h2><h3 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h3><p>使用身份证和账号密码登录.</p>
<h3 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h3><p>使用姓名,身份证,密码,手机进行注册.-&gt;前往缴费端进行激活</p>
<h3 id="挂失"><a href="#挂失" class="headerlink" title="挂失"></a>挂失</h3><p>登陆后提交挂失申请, 在数据库中修改对应的学生卡状状态, 冻结学生卡.</p>
<h3 id="查询余额"><a href="#查询余额" class="headerlink" title="查询余额"></a>查询余额</h3><p>从数据库拉取余额.</p>
<h3 id="明细"><a href="#明细" class="headerlink" title="明细"></a>明细</h3><p>使用当前账号的身份证号查询交易明细数据库并导出数据</p>
<h3 id="月报"><a href="#月报" class="headerlink" title="月报"></a>月报</h3><p>食堂, 打水, 超市, 洗澡消费占比,金额<br>最高充值金额<br>消费次数<br>总计消费金额<br>餐厅就餐天数<br>挂失次数<br>图书馆学习时间<br>图书馆最长学习时间<br>洗澡次数<br>打水喝水总量</p>
<h3 id="年报"><a href="#年报" class="headerlink" title="年报"></a>年报</h3><h2 id="图书馆出入"><a href="#图书馆出入" class="headerlink" title="图书馆出入"></a>图书馆出入</h2><p>图书馆出入登记</p>
<h2 id="图书馆借书"><a href="#图书馆借书" class="headerlink" title="图书馆借书"></a>图书馆借书</h2><p>通过书籍id进行图书馆的借书还书操作<br>判断借书是否逾期, 借书上限</p>
<h2 id="收费端"><a href="#收费端" class="headerlink" title="收费端"></a>收费端</h2><p>依据服务种类为收费端分配不同的前缀id<br>输入金额, 扣费</p>
<h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><p>所有数据都需要经过学生数据库将芯片编号转换为学生身份证</p>
<h3 id="芯片编号映射表"><a href="#芯片编号映射表" class="headerlink" title="芯片编号映射表"></a>芯片编号映射表</h3><p>芯片编号, 学生身份证</p>
<h3 id="学生数据库student"><a href="#学生数据库student" class="headerlink" title="学生数据库student"></a>学生数据库student</h3><p>学生身份证, 学生姓名,  账号密码, 学生手机, 学生邮箱, 学生卡状态(0为未激活,1为激活,2为挂失), 余额</p>
<h3 id="交易明细数据库transaction-details"><a href="#交易明细数据库transaction-details" class="headerlink" title="交易明细数据库transaction_details"></a>交易明细数据库transaction_details</h3><p>学生身份证,  消费端id, 消费类型, 消费金额(可正可负), 消费时间</p>
<h3 id="图书馆进出数据库-考虑停电情况-library-records"><a href="#图书馆进出数据库-考虑停电情况-library-records" class="headerlink" title="图书馆进出数据库(考虑停电情况)library_records"></a>图书馆进出数据库(考虑停电情况)library_records</h3><p>学生身份证, 开始时间, 结束时间</p>
<h3 id="图书馆借书记录数据库-关联图书馆系统取得书籍名称-borrow-records"><a href="#图书馆借书记录数据库-关联图书馆系统取得书籍名称-borrow-records" class="headerlink" title="图书馆借书记录数据库(关联图书馆系统取得书籍名称)borrow_records"></a>图书馆借书记录数据库(关联图书馆系统取得书籍名称)borrow_records</h3><p>学生身份证, 书籍名, 书籍id, 借入时间, 约定归还时间, 归还时间</p>
<h3 id="书籍id映射表"><a href="#书籍id映射表" class="headerlink" title="书籍id映射表"></a>书籍id映射表</h3><p>书籍id, 书籍名</p>
<h3 id="收费端数据库"><a href="#收费端数据库" class="headerlink" title="收费端数据库"></a>收费端数据库</h3><p>id, 收入, 时间</p>
<h3 id="月报数据库"><a href="#月报数据库" class="headerlink" title="月报数据库"></a>月报数据库</h3><h3 id="年报数据库"><a href="#年报数据库" class="headerlink" title="年报数据库"></a>年报数据库</h3><h1 id="项目优化内容"><a href="#项目优化内容" class="headerlink" title="项目优化内容"></a>项目优化内容</h1><h2 id="使用覆盖索引"><a href="#使用覆盖索引" class="headerlink" title="使用覆盖索引."></a>使用覆盖索引.</h2><p>采用join on语句进行自关联查询查询, 使用覆盖索引先获取对应的key再用于整体的查询, 可以极大优化分页查询速度</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT t1.* FROM transaction_details t1</span><br><span class="line">        JOIN (SELECT `key` from transaction_details WHERE id=#&#123;id&#125;</span><br><span class="line">        AND `time` between #&#123;start&#125; and #&#123;end&#125; limit #&#123;index&#125;,10) t2</span><br><span class="line">        ON t1.key = t2.key</span><br></pre></td></tr></table></figure>

<h2 id="使用aop实现mapping的自动注入"><a href="#使用aop实现mapping的自动注入" class="headerlink" title="使用aop实现mapping的自动注入"></a>使用aop实现mapping的自动注入</h2><p>因为磁卡书籍条形码都与身份证或书籍名称存在映射, 每次查询时都需要调用对应的映射, 所以采用aop进行目标属性的自动注入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">@Aspect</span><br><span class="line">public class GetId &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    LibraryMapper libraryMapper;</span><br><span class="line"></span><br><span class="line">    //设置全服务层方法切入点</span><br><span class="line">    @Pointcut(&quot;execution(* com.mtid.student.service.*.*(..))&quot;)</span><br><span class="line">    public void servicePoint()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    //设置admin类方法切入点</span><br><span class="line">    @Pointcut(&quot;execution(* com.mtid.student.service.AdminService.*(..))&quot;)</span><br><span class="line">    public void adminServicePoint()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    //设置student类方法切入点</span><br><span class="line">    @Pointcut(&quot;execution(* com.mtid.student.service.StudentService.*(..))&quot;)</span><br><span class="line">    public void studentServicePoint()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    @Around(value = &quot;servicePoint()&amp;&amp;!(studentServicePoint()||adminServicePoint())&quot; )</span><br><span class="line">    public Object getId(ProceedingJoinPoint joinPoint) throws Throwable &#123;</span><br><span class="line">        Signature signature = joinPoint.getSignature();</span><br><span class="line">        MethodSignature methodSignature = (MethodSignature)signature;</span><br><span class="line">        //取得参数名, 寻找chipNumber</span><br><span class="line">        String[] parameterNames = methodSignature.getParameterNames();</span><br><span class="line">        Object[] args = joinPoint.getArgs();</span><br><span class="line">        String chipNumber = new String();</span><br><span class="line">        for (int i = 0;i&lt;args.length;i++)&#123;</span><br><span class="line">            if (parameterNames[i].equals(&quot;chipNumber&quot;))&#123;</span><br><span class="line">                chipNumber = (String) args[i];</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (chipNumber!=null)&#123;</span><br><span class="line">            String id = libraryMapper.getId(chipNumber);</span><br><span class="line">            for (int i = 0;i&lt;args.length;i++)&#123;</span><br><span class="line">                if (parameterNames[i].equals(&quot;id&quot;))&#123;</span><br><span class="line">                    args[i] = id;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return (Object) joinPoint.proceed(args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="具体功能实现"><a href="#具体功能实现" class="headerlink" title="具体功能实现"></a>具体功能实现</h1><p>版本1使用boot加mybatis实现.</p>
<h2 id="数据库分析"><a href="#数据库分析" class="headerlink" title="数据库分析"></a>数据库分析</h2><p>原本是想将id与芯片编号都存储在学生表中, 但考虑到二者在查询时可能都会使用, 为了应对索引失效, 创建单独的一张映射表.</p>
<p>芯片编号映射表以及学生表具有唯一性, 使用主键索引.</p>
<p>交易明细数据库使用联合索引, 最主要的是时间与id查询, 为了降低b+树在插入时的变动程度, 把时间设置为第一索引, 同时为了优化查询速度, 将时间设为主键, 实现聚簇索引, 同时因为时间为主键与联合索引的第一索引, 即使单独查询id也不会导致联合索引失效.</p>
<p>图书馆进出记录表需要两个时间戳, 但是TIMESTAMP只能设置一个, 所以另一个只能使用datetime.</p>
<p>借书数据库需要与图书馆自己的书籍id映射表关联.</p>
<h3 id="数据库优化"><a href="#数据库优化" class="headerlink" title="数据库优化"></a>数据库优化</h3><p>不再使用char类型存储身份证, 改用long型存储身份证号, 特殊处理X即可, 刚好19位. 这么处理后在创建b+树的时候单个节点存储内容更大, b+树深度低.</p>
<p>尽量使用覆盖索引.</p>
<p>对交易明细表进行优化, 使分页查询可以利用索引: 分页查询优化需要主键, 交易明细表所有内容均不唯一, 所以要自定义一个自增主键key(一定程度上顶替时间), 接着对sql语句进行优化 为了不使联合索引失效, id定为一级索引, time定位二级索引.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT t1.* FROM transaction_details t1</span><br><span class="line">        JOIN (SELECT `key` from transaction_details WHERE id=#&#123;id&#125;</span><br><span class="line">        AND `time` between #&#123;start&#125; and #&#123;end&#125; limit #&#123;index&#125;,10) t2</span><br><span class="line">        ON t1.key = t2.key</span><br></pre></td></tr></table></figure>
<h2 id="学生端服务层"><a href="#学生端服务层" class="headerlink" title="学生端服务层"></a>学生端服务层</h2><p>注册<br>要求id, 邮箱, 手机号不可重复, 为了方便检查绑定失去焦点事件, 为邮箱和手机号创建索引, 且直接查询自身, 实现覆盖索引.</p>
<p>登录<br>使用邮箱或者手机号都可以登录</p>
<p>修改密码<br>写入旧密码, 写入新密码进行更改. 旧密码由controller进行验证.</p>
<p>交易明细<br>这里第一次出现了时区问题, 要统一数据库与java的时区<br>交易明细, 使用分页查询一次查10条. 在此进行分页查询优化. 输入查询开始时间,结束时间进行查询.<br>交易明细要再添加一个方法, 用于返回当前时间段数据总数, 使用覆盖查询, 为了降低数据库访问次数, 第一次查询后将总数据数放入域对象中.</p>
<p>查询余额<br>使用域对象的id直接查询余额即可</p>
<h2 id="学生端控制层"><a href="#学生端控制层" class="headerlink" title="学生端控制层"></a>学生端控制层</h2><p>登录<br>主要进行是否取得student对象的判断, 选择进入登录页面还是主页<br>拦截器, 对所有需要student域对象的网页进行过滤, 如果发现没有student域对象, 返回登录页面</p>
<p>退出登录<br>直接删除session中的student对象</p>
<p>注册<br>注册完成后跳转登录页面实现自动登录, 注册失败返回注册页面<br>为id, 手机号, 邮箱绑定失去焦点事件, 快速检查是否重复</p>
<p>修改密码<br>使用域对象比对输入的旧密码, 成功后添加新密码, 修改完成后删除域对象, 跳转至登录页面</p>
<p>查询余额</p>
<p>存储金额</p>
<p>交易明细<br>输入开始时间, 结束时间, 获取数据, 第一查询返回总页数.</p>
<p>挂失服务<br>==================学生端暂时结束,年报月报功能等待其他端构建完成后构建</p>
<h2 id="管理端"><a href="#管理端" class="headerlink" title="管理端"></a>管理端</h2><p>位管理员层配置管理员过滤器, 出于方便就不单独再为管理员建库, 分配前1000id为管理员权限, 第一次访问过滤器时判断session中id, 判断成功后将这个session对象转为administration<br>激活<br>将磁卡id与用户身份证进行绑定, 同时更改student数据库中的state<br>因为是使用身份证进行绑定, 绑定前要进行是否在student中注册的确认以及是否身份证已经绑定的判断<br>改绑新卡<br>与激活类似, 只是去掉激活中是否身份证已经绑定的判断<br>================================</p>
<h2 id="图书馆"><a href="#图书馆" class="headerlink" title="图书馆"></a>图书馆</h2><p>图书馆进出登记<br>timestamp在update的时候会自动更新,所以要把end时间设为timestamp类型, 也可以手动设置<br>这里开始后所有的操作都需要将磁卡id转换为身份证, 所以使用aop将获取身份证的方法切入, 实现用磁卡id为身份证的自动注入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">@Aspect</span><br><span class="line">public class GetId &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    LibraryMapper libraryMapper;</span><br><span class="line"></span><br><span class="line">    //设置全服务层方法切入点</span><br><span class="line">    @Pointcut(&quot;execution(* com.mtid.student.service.*.*(..))&quot;)</span><br><span class="line">    public void servicePoint()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    //设置admin类方法切入点</span><br><span class="line">    @Pointcut(&quot;execution(* com.mtid.student.service.AdminService.*(..))&quot;)</span><br><span class="line">    public void adminServicePoint()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    //设置student类方法切入点</span><br><span class="line">    @Pointcut(&quot;execution(* com.mtid.student.service.StudentService.*(..))&quot;)</span><br><span class="line">    public void studentServicePoint()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    @Around(value = &quot;servicePoint()&amp;&amp;!(studentServicePoint()||adminServicePoint())&quot; )</span><br><span class="line">    public Object getId(ProceedingJoinPoint joinPoint) throws Throwable &#123;</span><br><span class="line">        Signature signature = joinPoint.getSignature();</span><br><span class="line">        MethodSignature methodSignature = (MethodSignature)signature;</span><br><span class="line">        //取得参数名, 寻找chipNumber</span><br><span class="line">        String[] parameterNames = methodSignature.getParameterNames();</span><br><span class="line">        Object[] args = joinPoint.getArgs();</span><br><span class="line">        String chipNumber = new String();</span><br><span class="line">        for (int i = 0;i&lt;args.length;i++)&#123;</span><br><span class="line">            if (parameterNames[i].equals(&quot;chipNumber&quot;))&#123;</span><br><span class="line">                chipNumber = (String) args[i];</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (chipNumber!=null)&#123;</span><br><span class="line">            String id = libraryMapper.getId(chipNumber);</span><br><span class="line">            for (int i = 0;i&lt;args.length;i++)&#123;</span><br><span class="line">                if (parameterNames[i].equals(&quot;id&quot;))&#123;</span><br><span class="line">                    args[i] = id;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return (Object) joinPoint.proceed(args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>图书馆借书登记<br>创建书籍条形码与书籍名称的映射, 使用aop为图书馆类的方法添加映射<br>实现获取书籍条形码与学生磁卡id在数据库生成对应的学生身份证以及书籍名称<br>借书登记<br>借书前进行已借书籍判断, 查看是超过借书上限或者有书籍逾期<br>还书登记<br>将书籍id设为键, 直接查询选择最后一条进行更新, 同时判断是否逾期<br>=====================================</p>
<h2 id="收费端-1"><a href="#收费端-1" class="headerlink" title="收费端"></a>收费端</h2><p>=====================================</p>
<h2 id="月报功能实现"><a href="#月报功能实现" class="headerlink" title="月报功能实现"></a>月报功能实现</h2><p>食堂, 打水, 超市, 洗澡消费占比,金额<br>最高充值金额<br>消费次数<br>总计消费金额<br>餐厅就餐天数<br>挂失次数<br>图书馆学习时间<br>图书馆最长学习时间</p>
]]></content>
      <categories>
        <category>项目</category>
      </categories>
  </entry>
  <entry>
    <title>常用文档链接</title>
    <url>/2022/01/03/%E5%B8%B8%E7%94%A8%E6%96%87%E6%A1%A3%E9%93%BE%E6%8E%A5/</url>
    <content><![CDATA[<p><a href="https://docs.spring.io/spring-boot/docs/current/reference/html/">SpringBoot</a><br><a href="https://github.com/alibaba/druid/wiki/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98">Druid</a><br><a href="https://mybatis.net.cn/">MyBatis</a></p>
]]></content>
      <categories>
        <category>常用文档链接</category>
      </categories>
  </entry>
  <entry>
    <title>java8</title>
    <url>/2022/01/04/%E7%AC%94%E8%AE%B0/java8/</url>
    <content><![CDATA[<h1 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h1><p>函数式接口的实例(只支持一个抽象方法)<br>1.无参无返回值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">() -&gt; &#123;方法体&#125;</span><br></pre></td></tr></table></figure>
<p>2.有一个参数无返回值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">o1 -&gt; &#123;方法体&#125;</span><br></pre></td></tr></table></figure>
<p>3.有参数无返回值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(o1,o1) -&gt; &#123;方法体&#125;</span><br></pre></td></tr></table></figure>
<p>4.只有return的方法体(或者单句无返回方法体)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(o1,o1) -&gt; 方法体</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h1 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h1><p>如果一个接口只声明一个抽象方法, 就称此接口为函数式接口<br>四大内置核心函数式接口</p>
<table>
<thead>
<tr>
<th>函数式接口</th>
<th>参数类型</th>
<th>返回类型</th>
</tr>
</thead>
<tbody><tr>
<td>Consumer<T></td>
<td>T</td>
<td>void</td>
</tr>
<tr>
<td>Supplier<T></td>
<td>无</td>
<td>T</td>
</tr>
<tr>
<td>Function&lt;T,R&gt;</td>
<td>T</td>
<td>R</td>
</tr>
<tr>
<td>Predicate<T></td>
<td>T</td>
<td>boolean</td>
</tr>
</tbody></table>
<h1 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h1><p>当要传递给lambda表单式的方法体已经有实现了, 就可以用方法引用.<br>1.对象::非静态方法<br>2.类::静态方法<br>3.类::非静态方法<br>o1.compareTo(o2)用于替换 compare(o1,o2)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//需要提供泛型的地方必须提供泛型,否则无法进行类型推断</span><br><span class="line">//可以这么使用是因为, 虽然o1.compareTo(o2)只有一个形参</span><br><span class="line">//但是在使用时会再使用this调用另一个形参, 所以可以进行替换注入</span><br><span class="line">Comparator&lt;String&gt; comparator = String::compareTo;</span><br></pre></td></tr></table></figure>
<p>Function的apply, 使用自定义类的getName替换.<br>只要知道上面的原理, 这里也可以理解, Function虽然需要一个参数来使用方法, getName虽然不需要参数, 但实际要用this获得.</p>
<h1 id="构造器引用"><a href="#构造器引用" class="headerlink" title="构造器引用"></a>构造器引用</h1><p>构造器(包括数组构造器)本质也是方法, 所以构造器引用本质也是方法引用, 而且是类的静态方法引用.</p>
<h1 id="StreamAPI"><a href="#StreamAPI" class="headerlink" title="StreamAPI"></a>StreamAPI</h1><p>1.Stream不会存储元素<br>2.Stream不会改变对象, 而是返回一个新对象<br>3.Stream操作是延迟的, 他会等到结束语句才一起执行所有操作</p>
<h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><p>1.通过集合</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//顺序流取数据</span><br><span class="line">list.stream();</span><br><span class="line">//并行流取数据</span><br><span class="line">list.parallelStream();</span><br></pre></td></tr></table></figure>
<p>2.通过数组</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Arrays.stream(array);</span><br></pre></td></tr></table></figure>
<p>3.Stream的of</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Stream.if(obj);</span><br></pre></td></tr></table></figure>
<h2 id="中间操作"><a href="#中间操作" class="headerlink" title="中间操作"></a>中间操作</h2><table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>filter(Predicate p)</td>
<td>取得满足过滤器的内容</td>
</tr>
<tr>
<td>limit(n)</td>
<td>截取前n个元素</td>
</tr>
<tr>
<td>skip(n)</td>
<td>跳过前n个元素</td>
</tr>
<tr>
<td>distinct()</td>
<td>去重</td>
</tr>
<tr>
<td>map(Function f)</td>
<td>接收元素使用function对元素进行映射转换</td>
</tr>
<tr>
<td>flatMap(Function f)</td>
<td>这里的function返回值需要是一个流, flatMap会对其合并</td>
</tr>
<tr>
<td>sorted()</td>
<td>进行自然排序</td>
</tr>
<tr>
<td>sorted(Comparator c)</td>
<td>使用比较器排序</td>
</tr>
</tbody></table>
<h2 id="终止操作"><a href="#终止操作" class="headerlink" title="终止操作"></a>终止操作</h2><table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>allMatch(Predicate p)</td>
<td>判断是否所有元素满足过滤器</td>
</tr>
<tr>
<td>anyMatch(Predicate p)</td>
<td>判断是否有元素满足过滤器</td>
</tr>
<tr>
<td>noneMatch(Predicate p)</td>
<td>判断是否没有元素满足过滤器</td>
</tr>
<tr>
<td>findFirst()</td>
<td>返回第一个元素</td>
</tr>
<tr>
<td>findAny()</td>
<td>任取一个元素</td>
</tr>
<tr>
<td>count()</td>
<td>返回元素总数</td>
</tr>
<tr>
<td>max(Comparator)</td>
<td>返回流中最大</td>
</tr>
<tr>
<td>min(Comparator)</td>
<td>返回流中最小</td>
</tr>
<tr>
<td>forEach(Consumer c)</td>
<td>对每个元素执行Consumer</td>
</tr>
<tr>
<td>reduce(T,BinaryOperator)</td>
<td>可以将流中元素反复结合得到一个值</td>
</tr>
<tr>
<td>reduce(BinaryOperator)</td>
<td>可以将流中元素反复结合得到一个值Optinal<T></td>
</tr>
<tr>
<td>collect(Collector c)</td>
<td>使用Collector方法将流中数据收集到集合中</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title>redis</title>
    <url>/2022/01/04/%E7%AC%94%E8%AE%B0/redis/</url>
    <content><![CDATA[<h1 id="NoSQL"><a href="#NoSQL" class="headerlink" title="NoSQL"></a>NoSQL</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>不依赖业务逻辑方式存储, 而是以简单的键值对存储.<br>不遵循SQL标准, 没有ACID特性, 性能远高于SQL</p>
<span id="more"></span>
<h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><p>对数据高并发的读写<br>海量数据的读写<br>对数据高可扩展性的</p>
<h2 id="不适应场景"><a href="#不适应场景" class="headerlink" title="不适应场景"></a>不适应场景</h2><p>需要事务<br>基于SQL的结构化查询, 处理复杂的关系 </p>
<h1 id="Redis目录"><a href="#Redis目录" class="headerlink" title="Redis目录"></a>Redis目录</h1><p>redis-benchmark: 性能测试<br>redis-check-aof: 修复有问题的aof<br>redis-check-dump: 修复有问题的dump.rdb文件<br>redis-sentinel: redis集群使用<br>redis-server: redis服务启动命令<br>redis-cli( -p 端口号): 客户端</p>
<h1 id="后台启动"><a href="#后台启动" class="headerlink" title="后台启动"></a>后台启动</h1><p>将配置文件移动到etc文件, 修改daemonize 为no.<br>redis-server /etc/redis.conf<br>redis-cli</p>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h2 id="Redis键"><a href="#Redis键" class="headerlink" title="Redis键"></a>Redis键</h2><p>keys* :查看当前库所有key<br>exist key :判断某个key是否存在<br>type key :查看key类型<br>del key :删除指定的key<br>unlink key :根据value选择非阻塞删除(仅将keys从keyspace元数据中删除, 真正的删除会在后续异步操作)<br>expire key 10 :为给定的key设置过期时间<br>ttl key :查看多少秒过期,-1为永久,-2为已过期<br>select :切换库<br>dbsize :查看当前库key数量<br>flushdb :清空当前库<br>flushall :清空全部库</p>
<h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p>二进制安全的,即可以包含任何数据. value最大512M.</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>set key value</td>
<td>添加键</td>
</tr>
<tr>
<td>get</td>
<td>取</td>
</tr>
<tr>
<td>append key value</td>
<td>将给定的value追加到value后</td>
</tr>
<tr>
<td>strlen key</td>
<td>获得value长度</td>
</tr>
<tr>
<td>setnx key value</td>
<td>当key不存在时设置为这个value</td>
</tr>
<tr>
<td>incr key</td>
<td>value如果是数字则其中数字加1</td>
</tr>
<tr>
<td>decr key</td>
<td>value如果是数字则其中数字减1</td>
</tr>
<tr>
<td>incrby/decrby key 步长:</td>
<td></td>
</tr>
<tr>
<td>mset</td>
<td>同时设置多个键值对</td>
</tr>
<tr>
<td>mget</td>
<td>同时获取多个键值对</td>
</tr>
<tr>
<td>msetnx</td>
<td>设置多个(只有所有key都不存在时才会设置成功)</td>
</tr>
<tr>
<td>getrange key 起始 结束</td>
<td>取出value.substring()</td>
</tr>
<tr>
<td>setrange key index 值</td>
<td>在value[index]位置插入</td>
</tr>
<tr>
<td>setex key time value</td>
<td>设置键值对同时设置时间</td>
</tr>
<tr>
<td>getset key value</td>
<td>取得旧值同时设置新值</td>
</tr>
</tbody></table>
<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>lpush/rpush k v v</td>
<td>从左边或右边加一个或多个value</td>
</tr>
<tr>
<td>lpop/rpop</td>
<td>从左边/右边弹出值, 一旦值为空销毁键</td>
</tr>
<tr>
<td>rpoplpush/lpoprpush</td>
<td>从一边弹栈另一边入栈</td>
</tr>
<tr>
<td>lrange key start stop</td>
<td>从一边数取得start到stop的元素(0到-1取所有)</td>
</tr>
<tr>
<td>lindex key index</td>
<td>取出第index个(左开头)</td>
</tr>
<tr>
<td>llen key</td>
<td>取得list.size</td>
</tr>
<tr>
<td>linsert key before/after value newvalue</td>
<td>插入value</td>
</tr>
<tr>
<td>lrem key n value</td>
<td>从左数前n个value删除</td>
</tr>
<tr>
<td>lset key index value</td>
<td>替换第index个value</td>
</tr>
</tbody></table>
<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>sadd k v v</td>
<td>set中加入多个value</td>
</tr>
<tr>
<td>smembers key</td>
<td>取出set</td>
</tr>
<tr>
<td>sismember kv</td>
<td>判断是否有value</td>
</tr>
<tr>
<td>scard key</td>
<td>返回该集合的元素个数</td>
</tr>
<tr>
<td>srem k v v</td>
<td>删除一个或多个元素</td>
</tr>
<tr>
<td>spop key</td>
<td>随机从集合中吐出一个值</td>
</tr>
<tr>
<td>srandmember k n</td>
<td>随机从集合取出n个值,不会从集合中删除</td>
</tr>
<tr>
<td>smove k1 k2 value</td>
<td>把k1中的value移动到k2</td>
</tr>
<tr>
<td>sinter k1 k2</td>
<td>返回交集</td>
</tr>
<tr>
<td>sunion k1 k2</td>
<td>返回并集</td>
</tr>
<tr>
<td>sdiff k1 k2</td>
<td>返回k1相对k2的差集</td>
</tr>
</tbody></table>
<h2 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h2><p>value是一个String类型的field和value的映射表, 适合存储对象.<br>类似Map&lt;String,Object&gt;,整体结构类似Map&lt;String,Map&gt;</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>hset key field value</td>
<td>添加指定key的键值对</td>
</tr>
<tr>
<td>heget key field</td>
<td>取出key指定的键值对</td>
</tr>
<tr>
<td>hmset key field value key field value</td>
<td>批量设置hash的值</td>
</tr>
<tr>
<td>hexists key field</td>
<td>查看是否存在</td>
</tr>
<tr>
<td>hvals key</td>
<td>列出values</td>
</tr>
<tr>
<td>hkeys key</td>
<td>列出keyset</td>
</tr>
<tr>
<td>hincrby key field increment</td>
<td>为对应的key 的field加一</td>
</tr>
<tr>
<td>hsetnx key field value</td>
<td>当这个key没有这个field时设置value</td>
</tr>
</tbody></table>
<h2 id="Zset"><a href="#Zset" class="headerlink" title="Zset"></a>Zset</h2><p>它是set的一个改进, 为每个set设置了优先级, 可以根据score或者position快速获得一个范围的元素</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>zadd key score value score value</td>
<td>加入一个或多个元素</td>
</tr>
<tr>
<td>zrange key start stop</td>
<td>返回score在规定区间的v</td>
</tr>
<tr>
<td>zrangebycore key minmax</td>
<td>从小到大排列显示</td>
</tr>
<tr>
<td>zrangebycore key maxmin</td>
<td>从大到小排列显示</td>
</tr>
<tr>
<td>zincrby key increment value</td>
<td>增大score</td>
</tr>
<tr>
<td>zcount key min max</td>
<td>统计区间元素个数</td>
</tr>
<tr>
<td>zrank key value</td>
<td>返回排名,0开始</td>
</tr>
</tbody></table>
<h2 id="Bitmaps"><a href="#Bitmaps" class="headerlink" title="Bitmaps"></a>Bitmaps</h2><p>这个bitmap可以看作是一个String表示的二进制数字, key就是位数, value就是0或1.<br>主要用于节省空间, 表示true和false.</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>setbit key offset value</td>
<td>为指定的bitmap设定指定的位的值</td>
</tr>
<tr>
<td>getbit key offset</td>
<td>取出指定bitmap的指定位的值</td>
</tr>
<tr>
<td>bitcount key</td>
<td>计算1的数量</td>
</tr>
<tr>
<td>bitop 位运算 key1 key2 key3</td>
<td>对k2, k3进行位运算存入k1, 同时返回count</td>
</tr>
</tbody></table>
<h2 id="HyperLoglog"><a href="#HyperLoglog" class="headerlink" title="HyperLoglog"></a>HyperLoglog</h2><p>这个数据结构不会存储添加的元素, 而是维护一个加入的不同元素的数量的值</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>pfadd key element</td>
<td>添加元素到数据类型中</td>
</tr>
<tr>
<td>pfcount key</td>
<td>统计数量</td>
</tr>
<tr>
<td>pfmerge key1 key2 key3</td>
<td>将key2,key3的元素合并到key1中</td>
</tr>
</tbody></table>
<h1 id="发布和订阅"><a href="#发布和订阅" class="headerlink" title="发布和订阅"></a>发布和订阅</h1><p>是一种消息的通信模式, 订阅到同一频道进行消息的发送和接收.</p>
<h1 id="Jedis使用"><a href="#Jedis使用" class="headerlink" title="Jedis使用"></a>Jedis使用</h1><p>服务防火墙外部配置redis端口<br>服务器内部打开redis端口<br>修改/etc/redis.conf文件的bind, 注释方便非本机访问.<br>将protected-mode 改为no<br>重启redis</p>
<h1 id="boot整合redis"><a href="#boot整合redis" class="headerlink" title="boot整合redis"></a>boot整合redis</h1><p>引入依赖</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">        &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- redis --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- spring2.X集成redis所需common-pool2--&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>
<p>创建配置文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  redis:</span><br><span class="line">    host: 101.200.131.200</span><br><span class="line">    port: 6379</span><br><span class="line">    password: lixin123</span><br><span class="line">    database: 0</span><br><span class="line">    timeout: 1000</span><br><span class="line">    jedis:</span><br><span class="line">      pool:</span><br><span class="line">        max-active: 20</span><br><span class="line">        max-wait: -1</span><br><span class="line">        max-idle: 5</span><br><span class="line">        min-idle: 0</span><br></pre></td></tr></table></figure>
<p>创建配置类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@EnableCaching</span><br><span class="line">@Configuration</span><br><span class="line">public class RedisConfig extends CachingConfigurerSupport &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory factory) &#123;</span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;&gt;();</span><br><span class="line">        RedisSerializer&lt;String&gt; redisSerializer = new StringRedisSerializer();</span><br><span class="line">        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class);</span><br><span class="line">        ObjectMapper om = new ObjectMapper();</span><br><span class="line">        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">        jackson2JsonRedisSerializer.setObjectMapper(om);</span><br><span class="line">        template.setConnectionFactory(factory);</span><br><span class="line">//key序列化方式</span><br><span class="line">        template.setKeySerializer(redisSerializer);</span><br><span class="line">//value序列化</span><br><span class="line">        template.setValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">//value hashmap序列化</span><br><span class="line">        template.setHashValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        return template;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public CacheManager cacheManager(RedisConnectionFactory factory) &#123;</span><br><span class="line">        RedisSerializer&lt;String&gt; redisSerializer = new StringRedisSerializer();</span><br><span class="line">        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class);</span><br><span class="line">//解决查询缓存转换异常的问题</span><br><span class="line">        ObjectMapper om = new ObjectMapper();</span><br><span class="line">        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">        jackson2JsonRedisSerializer.setObjectMapper(om);</span><br><span class="line">// 配置序列化（解决乱码的问题）,过期时间600秒</span><br><span class="line">        RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig()</span><br><span class="line">                .entryTtl(Duration.ofSeconds(600))</span><br><span class="line">                .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(redisSerializer))</span><br><span class="line">                .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(jackson2JsonRedisSerializer))</span><br><span class="line">                .disableCachingNullValues();</span><br><span class="line">        RedisCacheManager cacheManager = RedisCacheManager.builder(factory)</span><br><span class="line">                .cacheDefaults(config)</span><br><span class="line">                .build();</span><br><span class="line">        return cacheManager;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>
<h1 id="redis事务"><a href="#redis事务" class="headerlink" title="redis事务"></a>redis事务</h1><p>redis事务的命令会序列化后串联起来, 不会被其他客户端命令打断.</p>
<h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><p>multi表示开启队列, 此时命令可以进行排队准备执行.<br>exec表示开始执行, 将队列中的命令开始依次执行.<br>discard表示放弃组队, 清空事务队列.<br>当组队过程中出现错误, 使用执行操作时并不会执行.<br>当执行过程中出现错误, 只有错误的命令不会执行.</p>
<h2 id="事务冲突"><a href="#事务冲突" class="headerlink" title="事务冲突"></a>事务冲突</h2><p>悲观锁:适用多改操作<br>操作前进行上锁, 操作结束才归还锁.</p>
<p>乐观锁:适用多读操作,抢票高并发操作<br>为操作及数据库添加版本号, 每次操作都会更新版本号, 只有版本号一致才允许操作<br>乐观锁的使用:<br>使用watch key, 监视一个或多个key, 如果在事务执行之前这些key被更改, 则打断事务<br>##redis事务特性<br>所有事务都会序列化按序执行, 不会被打断.<br>不存在隔离级别.<br>如果有一条事务失败并不会回滚而是跳过.</p>
<h2 id="ab工具模拟并发"><a href="#ab工具模拟并发" class="headerlink" title="ab工具模拟并发"></a>ab工具模拟并发</h2><p>-n: 请求数量<br>-c: 请求并发数量<br>-p: post提交<br>-u: put提交<br>-T: 内容类型<br>示例:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ab -n 1000 -c 100 -p postfile -T contentType host</span><br></pre></td></tr></table></figure>
<h2 id="解决并发的连接超时问题"><a href="#解决并发的连接超时问题" class="headerlink" title="解决并发的连接超时问题"></a>解决并发的连接超时问题</h2><p>启用jedis连接池</p>
<h2 id="解决超卖问题"><a href="#解决超卖问题" class="headerlink" title="解决超卖问题"></a>解决超卖问题</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//监视库存</span><br><span class="line">jedis.watch(kckey);</span><br><span class="line">//开启事务</span><br><span class="line">Transaction multi = jedis.multi();</span><br><span class="line">//要执行的操作</span><br><span class="line"></span><br><span class="line">//执行</span><br><span class="line">List&lt;Object&gt; result = multi.exec();</span><br><span class="line">if(result == null||result.size()==0)&#123;</span><br><span class="line">    System.out.println(&quot;秒杀失败&quot;);</span><br><span class="line">    jedis.close;</span><br><span class="line">    return false;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="持久化-只做缓存不需要"><a href="#持久化-只做缓存不需要" class="headerlink" title="持久化(只做缓存不需要)"></a>持久化(只做缓存不需要)</h1><h2 id="RDB-默认"><a href="#RDB-默认" class="headerlink" title="RDB(默认)"></a>RDB(默认)</h2><p>每隔一段时间fork出一套临时文件, 再将持久化文件进行替换. 这是为了防止在持久化过程中出现意外, 导致现有内容未完全写完, 而原有内容又不完整的情况出现.<br>save: 手动保存<br>bgsave: 后台异步快照操作.</p>
<p>适合大规模的数据恢复, 对数据完整性和一致性要求不高的情况. 节省磁盘空间, 恢复速度快.<br>缺点是最后一次持久化数据可能会丢失.</p>
<h2 id="AOF-有bug-不推荐单独使用"><a href="#AOF-有bug-不推荐单独使用" class="headerlink" title="AOF(有bug, 不推荐单独使用)"></a>AOF(有bug, 不推荐单独使用)</h2><p>以日志形式记录所有增删改, 通过执行所有操作实现数据的还原.<br>将redis.config中的appendonly设为yes即可切换到aof持久化.<br>如果遇到aof文件损坏, 通过/usr/local/bin/reids-check-aof–fix appendonly.aof可以修复.<br>appendfsync always: 始终同步<br>appendfsync everysec: 每秒同步<br>appendfsync no: 只允许手动同步</p>
<p>rewrite<br>将多条重复度高的命令整合为一个长命令.<br>只有当aof文件是上次rewrite后大小的一倍(即aof变大一倍)且大于64M时才会触发.</p>
<p>备份文件机制更稳健, 日志形式, 可以处理误操作.<br>缺点是占用磁盘更多, 恢复速度慢, 同步频率高的话有性能压力.</p>
<h1 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h1><p>主服务器负责写, 写完后将内容复制给副服务器, 副服务器只进行读操作.</p>
<h2 id="搭建"><a href="#搭建" class="headerlink" title="搭建"></a>搭建</h2><p>创建新的conf文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//引入公共部分</span><br><span class="line">include /myredis/redis.conf</span><br><span class="line">//设置新锁</span><br><span class="line">pidfile /var/run/redis_6379.pid</span><br><span class="line">//设置新端口</span><br><span class="line">port 6379</span><br><span class="line">//设置持久化文件名称</span><br><span class="line">dbfilename dump6379.rdb</span><br><span class="line">//设置aof文件名称或关闭aof</span><br></pre></td></tr></table></figure>

<p>启动服务</p>
<p>info replication查看主从复制相关信息</p>
<p>在副服务器上执行:slaveof ip 端口 实现与主服务器的绑定<br>slaveof no one 解除与主服务器的绑定, 自身升级为主服务器, 将原本的主服务器和其他从服务器绑定到它下面</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>当从服务器挂掉后重启, 会变为主服务器, 需要再次绑定<br>基于主从服务区可以将多个服务器数据库进行树化, 方便管理</p>
<p>哨兵模式: 为服务器创建一个哨兵进行监听, 需要的时候将从服务器升级为主服务器.<br>使用配置文件启动<br>配置文件:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//设定监控的主机</span><br><span class="line">sentinel monitor mymaster ip 端口 需要哨兵同意的数量</span><br></pre></td></tr></table></figure>
<p>启动:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">redis-sentinel 配置文件路径</span><br></pre></td></tr></table></figure>
<p>选择条件<br>优先级: reids.conf中的replica-priority的值越小优先级越高<br>与主机同步高的<br>runid小的</p>
<h1 id="redis集群"><a href="#redis集群" class="headerlink" title="redis集群"></a>redis集群</h1><h2 id="组装"><a href="#组装" class="headerlink" title="组装"></a>组装</h2><p>配置文件:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//引入公共部分</span><br><span class="line">include /myredis/redis.conf</span><br><span class="line">//设置新锁</span><br><span class="line">pidfile /var/run/redis_6379.pid</span><br><span class="line">//设置新端口</span><br><span class="line">port 6379</span><br><span class="line">//设置持久化文件名称</span><br><span class="line">dbfilename dump6379.rdb</span><br><span class="line">//设置aof文件名称或关闭aof</span><br><span class="line">//开启集群</span><br><span class="line">cluster-enable yes</span><br><span class="line">//设置节点配置文件名称</span><br><span class="line">cluster-config 名称</span><br><span class="line">//设定失联时间, 超过这时间集群自动进行主从切换</span><br><span class="line">cluster-node-timeout 时间</span><br></pre></td></tr></table></figure>
<p>启动所有需要集群的服务.<br>使用redis/src下执行以下操作, 进行集群的自动组装<br>集群方式1:一主一从</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">redies-cli --cluster create --cluster-replicas 集群方式 &#123;ip 端口&#125;</span><br></pre></td></tr></table></figure>
<p>开启</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">redis-cli -c -p 端口</span><br></pre></td></tr></table></figure>
<p>在其中使用cluster nodes查看集群</p>
<h2 id="集群操作"><a href="#集群操作" class="headerlink" title="集群操作"></a>集群操作</h2><p>集群中有一个插槽概念, 根据key会生成一个插槽值, 每个服务器可以接收固定范围的一个插槽值. 当存入key时会自动将key存入对应的服务器并切换过去.<br>因此当批量存入key时无法同时为它们分派一个插槽值, 因此无法一次性存入多个key.<br>除非为这些key设定一个统一的生成插槽的key:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mest name&#123;user&#125; lucy age&#123;user&#125; 20</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//查询键的插槽</span><br><span class="line">cluster keyslot key</span><br><span class="line">//计算插槽存入的键的数量(必须在持有插槽的服务器进行查询)</span><br><span class="line">cluster countkeysinlot 插槽</span><br><span class="line">//获取插槽的第n个键</span><br><span class="line">cluster getkeysinslot 插槽 n</span><br></pre></td></tr></table></figure>

<p>配置文件:<br>cluster-require-full-coverage<br>如果为yes则当集群一部分功能停止时, 整个集群都停止.<br>如果为no, 则不会停止.</p>
<h1 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h1><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>大量请求的key不在缓存中, 也不在数据库, 因此也不会在缓存中进行缓存, 这会使得每次请求都要经过缓存然后再向数据库发送请求, 造成服务器压力增大或崩溃.</p>
<h2 id="表现"><a href="#表现" class="headerlink" title="表现"></a>表现</h2><p>应用服务器压力变大,redis服务器压力也会变大<br>redis命中率降低<br>一直查询数据库</p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>1.对空值进行缓存:如果查询返回值数据为空(不管数据库是否不存在), 仍将这个空结果进行缓存, 设置较短的过期时间(不超过五分钟).<br>2.设置可访问的白名单:名单id作为bitmap的偏移量, 每次访问和bitmap进行比较, 进行拦截.<br>3.采用布隆过滤器:bitmap方式的一种优化方案(空间和时间效率高, 但是命中率较低)<br>4.实时监控:当发现Redis的命中率开始急剧降低, 需要排查访问对象和访问数据, 设置黑名单.</p>
<h1 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h1><h2 id="原因-1"><a href="#原因-1" class="headerlink" title="原因"></a>原因</h2><p>redis中的某个key过期了, 同时又有大量访问使用这个key.</p>
<h2 id="表现-1"><a href="#表现-1" class="headerlink" title="表现"></a>表现</h2><p>数据库访问压力变大<br>redis没有出现大量过期<br>redis正常运行</p>
<h2 id="解决方法-1"><a href="#解决方法-1" class="headerlink" title="解决方法"></a>解决方法</h2><p>1.预先设置热门数据: 在redis高峰访问前, 把一些热门数据提前存入到redis中, 增加时长.<br>2.实时调整: 监控key的访问频率, 依据频率分配时长.<br>3.使用锁: 这种原因是大量对同一个key进行访问数据库导致, 所以可以为key添加互斥锁, 当在查询数据库时不再允许相同的查询.</p>
<h1 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h1><h2 id="原因-2"><a href="#原因-2" class="headerlink" title="原因"></a>原因</h2><p>极短时间内, 大量key同时过期.</p>
<h2 id="表现-2"><a href="#表现-2" class="headerlink" title="表现"></a>表现</h2><p>数据库压力变大服务器崩溃</p>
<h2 id="解决方法-2"><a href="#解决方法-2" class="headerlink" title="解决方法"></a>解决方法</h2><p>1.构建多级缓存: nginx+redis+其他<br>2.使用锁或者队列<br>3.设置过期标志更新缓存<br>4.将缓存失效时间分散</p>
<h1 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h1><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//上锁</span><br><span class="line">setnx k v</span><br><span class="line">//设置过期时间</span><br><span class="line">exprie k seconds</span><br><span class="line">//解锁</span><br><span class="line">del k</span><br></pre></td></tr></table></figure>
<p>为了防止上锁与设置过期时间之间出现意外, 可以合并操作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set k v nx ex seconds</span><br></pre></td></tr></table></figure>

<p>java代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@GetMapping(&quot;/test&quot;)</span><br><span class="line">    public void blockTest()&#123;</span><br><span class="line">        //生成uuid</span><br><span class="line">        String uuid = UUID.randomUUID().toString();</span><br><span class="line">        //获取锁</span><br><span class="line">        Boolean lock = redisTemplate.opsForValue().setIfAbsent(&quot;lock&quot;, uuid,3, TimeUnit.SECONDS);</span><br><span class="line">        //取到锁开始操作</span><br><span class="line">        if (lock)&#123;</span><br><span class="line">            //需要锁的操作</span><br><span class="line"></span><br><span class="line">            //如果uuid相等则解锁</span><br><span class="line">            if (redisTemplate.opsForValue().get(&quot;lock&quot;).equals(uuid))&#123;</span><br><span class="line">                this.redisTemplate.delete(&quot;lock&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">                //否则进行重试</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(100);</span><br><span class="line">                blockTest();</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="防止误删"><a href="#防止误删" class="headerlink" title="防止误删"></a>防止误删</h2><p>当一个服务器持有锁卡顿时, 锁被自动释放, 此时其他服务器会重新上锁, 但此时如果原本的卡顿服务器恢复则会将这个锁删除. 为了防止这种情况出现, 要为锁设置uuid(为同一个id设置不同的value实现)防止误删.</p>
<p>即使这样, 但因为uuid的判断与删除不为原子操作, 所以当在这个两个语句之间锁出现过期并被其他服务器使用也会导致误删.<br>因此需要使用lua脚本将这部分语句进行封装.</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title>不同的二叉搜索树2</title>
    <url>/2022/01/04/leetcode%E9%A2%98%E8%A7%A3/%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%912/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给你一个整数 n ，请你生成并返回所有由 n 个节点组成且节点值从 1 到 n 互不相同的不同 二叉搜索树 。可以按 任意顺序 返回答案。</p>
<span id="more"></span>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>首先分析二叉搜索树, 它是由左边的比根节点小的树加上右边的比根节点大的树构成的. 即围绕一个固定的根节点生成的树的左右子树的内容是相同的, 不同的是结构, 所以可以对左右子树进行排列组合.<br>由此可以从根部一直向上进行排列组合, 最后得到所有的情况.</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public List&lt;TreeNode&gt; generateTrees(int n) &#123;</span><br><span class="line">        if (n == 0) &#123;</span><br><span class="line">            return new LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        return generateTrees(1, n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public List&lt;TreeNode&gt; generateTrees(int start, int end) &#123;</span><br><span class="line">        ArrayList&lt;TreeNode&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">        //这里不可以start等于end判定, 因为这样无法返回空节点的情况</span><br><span class="line">        if (start&gt;end)&#123;</span><br><span class="line">            //这里需要添加null,否则无法排列组合</span><br><span class="line">            list.add(null);</span><br><span class="line">            return list;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            //从start到end中取一个节点作为根节点进行排列组合,最后再把它们返回给上一级</span><br><span class="line">            for (int i = start;i&lt;=end;i++)&#123;</span><br><span class="line">                //左子树排列</span><br><span class="line">                List&lt;TreeNode&gt; left = generateTrees(start,i-1);</span><br><span class="line">                //右子树排列</span><br><span class="line">                List&lt;TreeNode&gt; right = generateTrees(i+1,end);</span><br><span class="line">                //对根节点, 左右子树进行排列组合拼接</span><br><span class="line">                for (TreeNode leftTree:left)&#123;</span><br><span class="line">                    for (TreeNode rightTree:right)&#123;</span><br><span class="line">                        TreeNode node = new TreeNode(i);</span><br><span class="line">                        node.left=leftTree;</span><br><span class="line">                        node.right=rightTree;</span><br><span class="line">                        //加入到返回的list中</span><br><span class="line">                        list.add(node);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return list;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode解析</category>
        <category>最优</category>
      </categories>
      <tags>
        <tag>回溯</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>滑动窗口的最大值</title>
    <url>/2022/01/05/leetcode%E9%A2%98%E8%A7%A3/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定一个数组 nums 和滑动窗口的大小 k，请找出所有滑动窗口里的最大值。</p>
<span id="more"></span>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>可以维护一个最大值的键值对, 如果新加入的数字比这个键值对数值大就直接替换, 如果键值对过时则重新计算最大键值对.</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int[] max;</span><br><span class="line">    int[] nums;</span><br><span class="line">    public int[] maxSlidingWindow(int[] nums, int k) &#123;</span><br><span class="line">        if (k&lt;=1)&#123;</span><br><span class="line">            return nums;</span><br><span class="line">        &#125;</span><br><span class="line">        //存储最大数字的位置,以及值</span><br><span class="line">        //如果新加的数字比这个最大数字大就替换</span><br><span class="line">        //如果这个位置被淘汰则重新计算</span><br><span class="line">        this.nums = nums;</span><br><span class="line">        max = new int[2];</span><br><span class="line">        //0存数,1存位置</span><br><span class="line">        max[1] = -1;</span><br><span class="line">        int[] res = new int[nums.length-k+1];</span><br><span class="line">        getMax(0,k);</span><br><span class="line">        res[0] = max[0];</span><br><span class="line">        for (int i = 1;i&lt; nums.length-k+1;i++)&#123;</span><br><span class="line">            if (nums[i+k-1]&gt;=max[0])&#123;</span><br><span class="line">                max[1] = i+k-1;</span><br><span class="line">                max[0] = nums[i+k-1];</span><br><span class="line">            &#125;else if (i &gt; max[1])&#123;</span><br><span class="line">                getMax(i,k);</span><br><span class="line">            &#125;</span><br><span class="line">            res[i] = max[0];</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    void getMax(int start,int k)&#123;</span><br><span class="line">        max[0] = nums[start];</span><br><span class="line">        max[1] = start;</span><br><span class="line">        for (int i = start+1;i&lt; k+start;i++)&#123;</span><br><span class="line">            if (max[0]&lt;=nums[i])&#123;</span><br><span class="line">                max[1] = i;</span><br><span class="line">                max[0] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode解析</category>
        <category>困难</category>
      </categories>
      <tags>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库</title>
    <url>/2021/12/07/%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90/%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[<h1 id="InnoDB-和-MyIsam-引擎的区别？"><a href="#InnoDB-和-MyIsam-引擎的区别？" class="headerlink" title="InnoDB 和 MyIsam 引擎的区别？"></a>InnoDB 和 MyIsam 引擎的区别？</h1><span id="more"></span>
<p>1.InnoDB支持事务，MyIsam不支持事务。<br>2.InnoDB支持外键，MyIsam不支持。<br>3.InnoDB是聚簇索引，MyIsam是非聚簇索引。<br>4.InnoDB不支持全文索引但能拿插件实现且效果更好，MyIsam支持全文索引。<br>5.InnoDB最小锁粒度是行锁，MyIsam最小锁粒度是表锁。</p>
<h1 id="聚簇索引和非聚簇索引"><a href="#聚簇索引和非聚簇索引" class="headerlink" title="聚簇索引和非聚簇索引"></a>聚簇索引和非聚簇索引</h1><p>聚簇索引：数据与索引一体，表数据的顺序与索引顺序一致。<br>    聚簇索引默认是主键，如果表中没有主键，InnoDB会选择一个唯一非空索引代替。<br>    如果没有这样的索引InnoDB会在内部生成一个隐式索引。<br>非聚簇索引：数据与索引分开存放，表数据顺序与索引顺序无关, 普通索引就是非聚簇索引, 查询过程是通过普通索引的b+树查到对应的主键, 再拿着这个主键去主键的b+树进行查询. 如果使用普通索引查询主键, 则不需要回表.</p>
<h1 id="行锁与表锁的比较"><a href="#行锁与表锁的比较" class="headerlink" title="行锁与表锁的比较"></a>行锁与表锁的比较</h1><p>行锁：锁力度小，开销大，上锁速度慢，会出现死锁，并发高。<br>表锁：锁力度大，开销小，上锁速度快，不会出现死锁，并发低。</p>
<h1 id="mySQL索引的最左原则"><a href="#mySQL索引的最左原则" class="headerlink" title="mySQL索引的最左原则"></a>mySQL索引的最左原则</h1><p>当使用联合索引时，进行检索时，使用索引就像一个桥, 只有有前置索引后面的索引才可以生效(可以顺序不同, mysql会自动优化)，否则后面的索引就会失效。<br>这是因为在b+树中存储时，优先级是字段左到右的顺序，一旦不使用前面的字段，后面的字段就会无序。</p>
<h1 id="哪种清空可以在违反最左原则的情况下还不会索引失效"><a href="#哪种清空可以在违反最左原则的情况下还不会索引失效" class="headerlink" title="哪种清空可以在违反最左原则的情况下还不会索引失效"></a>哪种清空可以在违反最左原则的情况下还不会索引失效</h1><h1 id="索引的优化"><a href="#索引的优化" class="headerlink" title="索引的优化"></a>索引的优化</h1><p>1.最左前缀法则<br>2.不要对索引进行计算，函数以及转型，会导致索引失效。<br>3.不可以在范围查找语句右边使用索引，会导致索引失效。<br>4.减少select* 的使用，尽量进行覆盖索引，即select查询字段与where中索引字段一致。<br>5.不要在使用like查找索引字段时在字段前面加%。<br>6.使用内存占用更小数据类型作为索引, 这样在建立B+树的时候单个节点容量更大, B+树高度更低.<br>7.使用覆盖索引</p>
<h1 id="如何优化分页查询"><a href="#如何优化分页查询" class="headerlink" title="如何优化分页查询"></a>如何优化分页查询</h1><p>默认的分页查询是依序遍历整个表格, 当需要取出的数据是主键对应的一段连续数据的时候, 可以先使用索引对主键进行覆盖查询, 再拿找到的主键从数据中整段取出数据.<br>也可以对sql语句进行优化, 取出不连续的主键数据.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM tbl_works t1 </span><br><span class="line">JOIN (SELECT id from tbl_works WHERE status=1 </span><br><span class="line">limit 100000, 10) t2</span><br><span class="line">ON t1.id = t2.id </span><br></pre></td></tr></table></figure>
<h1 id="为什么范围查找会导致索引失效"><a href="#为什么范围查找会导致索引失效" class="headerlink" title="为什么范围查找会导致索引失效"></a>为什么范围查找会导致索引失效</h1><p>因为b+树的叶节点是是一个有序链表，当进行范围查找时会会把整段链表直接取出等待下一步查找，这种情况下，除非取出的这整一段的范围查找的字段都相等，否则下一个字段一定是乱序的。</p>
<h1 id="为什么在like中添加前缀会导致索引失效"><a href="#为什么在like中添加前缀会导致索引失效" class="headerlink" title="为什么在like中添加前缀会导致索引失效"></a>为什么在like中添加前缀会导致索引失效</h1><p>这是因为字符串在b+树里存储的时候，是按照ascii码的大小存储的，此时，这个结构与复合索引结构是一样的，当为字符串增加前缀时，违反了最左前缀法则。</p>
<h1 id="使用order-by查询时如何优化速度"><a href="#使用order-by查询时如何优化速度" class="headerlink" title="使用order by查询时如何优化速度"></a>使用order by查询时如何优化速度</h1><p>使用order by时要进量使用覆盖索引，因为不使用覆盖索引进行排序会发生文件内排序。或者在java中进行排序。</p>
<h1 id="什么是慢查询，如何定位"><a href="#什么是慢查询，如何定位" class="headerlink" title="什么是慢查询，如何定位"></a>什么是慢查询，如何定位</h1><p>记录所有执行时间超过一个限度的查询和不适用索引的查询到慢查询日志，以待分析处理。<br>根据SHOW VARIABLES LIKE ‘%query%’语句查询文件路径。</p>
<h1 id="行式数据库与列式数据库的优劣"><a href="#行式数据库与列式数据库的优劣" class="headerlink" title="行式数据库与列式数据库的优劣"></a>行式数据库与列式数据库的优劣</h1><p>行式存储更适合针对对象的查询, 列式存储更适合对综合数据的处理</p>
<h1 id="InnoDB底层"><a href="#InnoDB底层" class="headerlink" title="InnoDB底层"></a>InnoDB底层</h1>]]></content>
      <categories>
        <category>知识点解析</category>
      </categories>
  </entry>
  <entry>
    <title>最少交换次数来组合所有的1</title>
    <url>/2022/01/09/leetcode%E9%A2%98%E8%A7%A3/%E6%9C%80%E5%B0%91%E4%BA%A4%E6%8D%A2%E6%AC%A1%E6%95%B0%E6%9D%A5%E7%BB%84%E5%90%88%E6%89%80%E6%9C%89%E7%9A%841/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>交换定义为选中一个数组中的两个 互不相同 的位置并交换二者的值。<br>环形数组是一个数组，可以认为第一个元素和最后一个元素相邻 。<br>给你一个 二进制环形数组 nums，返回在任意位置将数组中的所有1聚集在一起需要的最少交换次数。</p>
<span id="more"></span>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>使用滑动窗口直接分析最终状态, 滑动窗口的大小为1的数量</p>
<h1 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int minSwaps(int[] nums) &#123;</span><br><span class="line">        //第一轮计算1的个数</span><br><span class="line">        int length = 0;</span><br><span class="line">        for (int i:nums)&#123;</span><br><span class="line">            if (i==1)&#123;</span><br><span class="line">                length++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int left = 0;</span><br><span class="line">        int right = length-1;</span><br><span class="line">        //计算最少的0的个数</span><br><span class="line">        int count = 0;</span><br><span class="line">        for (int i = left;i&lt;=right;i++)&#123;</span><br><span class="line">            if (nums[i]==0)&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int res = count;</span><br><span class="line">        left++;</span><br><span class="line">        right++;</span><br><span class="line">        for (;left&lt;nums.length;left++,right++)&#123;</span><br><span class="line">            if (right==nums.length)&#123;</span><br><span class="line">                right = 0;</span><br><span class="line">            &#125;</span><br><span class="line">            if (nums[left-1]==0&amp;&amp;nums[right]==1)&#123;</span><br><span class="line">                count--;</span><br><span class="line">            &#125;else if (nums[left-1]==1&amp;&amp;nums[right]==0)&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            res = Math.min(res,count);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode解析</category>
        <category>中等</category>
      </categories>
      <tags>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式</title>
    <url>/2022/01/12/%E7%AC%94%E8%AE%B0/%E5%88%86%E5%B8%83%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h1><p>高性能, 高并发, 可容错</p>
<span id="more"></span>
<h1 id="MapReduce"><a href="#MapReduce" class="headerlink" title="MapReduce"></a>MapReduce</h1><h2 id="编程模型"><a href="#编程模型" class="headerlink" title="编程模型"></a>编程模型</h2><p>该计算任务将一个键值对集合作为输入，并生成一个键值对集合作为输出。MapReduce这个库的用户将这种计算任务以两个函数进行表达，即Map和Reduce。</p>
<p>由用户所编写的Map函数接收输入，并生成一个中间键值对集合。MapReduce这个库会将所有共用一个键的值组合在一起，并将它们传递给Reduce函数。</p>
<p>Reduce函数也是由用户所编写。它接受一个中间键以及该键的值的集合作为输入。它会将这些值合并在一起，以此来生成一组更小的值的集合。通常每次调用Reduce函数所产生的值的结果只有0个或者1个。中间值通过一个迭代器来传递给用户所编写的Reduce函数。这使我们可以处理这些因为数据量太大而无法存放在内存中的存储值的list列表了</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h3><p>用户程序中的MapReduce库会先将输入文件切分为M个片段，通常每个片段的大小在16MB到64MB之间（具体大小可以由用户通过可选参数来进行指定）。接着，它会在集群中启动许多个程序副本。</p>
<p>有一个程序副本是比较特殊的，那就是master。剩下的副本都是worker，master会对这些worker进行任务分配。这里有M个Map任务以及R个Reduce任务要进行分配。master会给每个空闲的worker分配一个map任务或者一个reduce任务。</p>
<p>被分配了map任务的worker会读取相关的输入数据片段。它会从输入数据中解析出键值对，并将它们传入用户定义的Map函数中。Map函数所生成的中间键值对会被缓存在内存中（知秋注：用户自定义的map函数只是中间的一环而已，我们其实可以将这个map看作map(K,V,BiFunction&gt;) K是文件名，V是文件内容，BiFunction就是我们自己定义的map规则）。</p>
<p>每隔一段时间，被缓存的键值对会被写入到本地硬盘，并通过分区函数分到R个区域内。这些被缓存的键值对在本地磁盘的位置会被传回master。master负责将这些位置转发给执行reduce操作的worker。</p>
<p>当master将这些位置告诉了某个执行reduce的worker，该worker就会使用RPC的方式去从保存了这些缓存数据的map worker的本地磁盘中读取数据。当一个reduce worker读取完了所有的中间数据后，它就会根据中间键进行排序，这样使得具有相同键值的数据可以聚合在一起。之所以需要排序是因为通常许多不同的key会映射到同一个reduce任务中。如果中间数据的数量太过庞大而无法放在内存中，那就需要使用外部排序。</p>
<p>reduce worker会对排序后的中间数据进行遍历。然后，对于遇到的每个唯一的中间键，reduce worker会将该key和对应的中间value的集合传入用户所提供的Reduce函数中。Reduce函数生成的输出会被追加到这个reduce分区的输出文件中。<br>当所有的map任务和reduce任务完成后，master会唤醒用户程序。此时，用户程序会结束对MapReduce的调用。</p>
<p>在成功完成任务后，MapReduce的输出结果会存放在R个输出文件中（每个reduce任务都会生成对应的文件，文件名由用户指定）。一般情况下，用户无需将这些文件合并为一个文件。他们通常会将这些文件作为输入传入另一个MapReduce调用中。或者在另一个可以处理这些多个分割文件的分布式应用中使用。</p>
<h3 id="Master结构"><a href="#Master结构" class="headerlink" title="Master结构"></a>Master结构</h3><p>在Master中包含了一些数据结构。它保存了每个Map任务和每个Reduce任务的状态（闲置，正在运行，以及完成），以及非空闲任务的worker机器的ID。</p>
<p>master就像是一个喷泉（知秋注：管理了一堆喷口，数据准备好就喷到需要接收的地方），它将map任务所生成的中间文件区域的位置传播给reduce任务。故，对于每个完成的map任务，master会保存由map任务所生成的R个中间文件区域的位置和大小。当map任务完成后，会对该位置和数据大小信息进行更新。这些信息会被逐渐递增地推送给那些正在运行的Reduce工作。</p>
<h2 id="容错"><a href="#容错" class="headerlink" title="容错"></a>容错</h2><h3 id="Worker故障"><a href="#Worker故障" class="headerlink" title="Worker故障"></a>Worker故障</h3><p>master会周期性ping下每个worker。如果在一定时间内无法收到来自某个worker的响应，那么master就会将该worker标记为failed。所有由该worker完成的Map任务都会被重设为初始的空闲（idle）状态。因此，之后这些任务就可以安排给其他的worker去完成。类似的，在一台故障的worker上正在执行的任何Map任务或者Reduce任务也会被设置为空闲状态，并等待重新调度。</p>
<p>当worker故障时，由于已经完成的Map任务的输出结果已经保存在该worker的硬盘中了，并且该worker已经无法访问，所以该输出也无法访问。因此，该任务必须重新执行。然而，已经完成的Reduce任务则无需再执行，因为它们的输出结果已经存储在全局文件系统中了。</p>
<h3 id="Master故障"><a href="#Master故障" class="headerlink" title="Master故障"></a>Master故障</h3><p>一个简单的解决好办法就是让master周期性的将上文所描述的数据结构写入磁盘，即checkpoint。如果这个master挂掉了，那么就可以从最新的checkpoint创建出一个新的备份，并启动master进程。然而，因为只有一个master，所以我们并不希望它发生故障。因此如果master故障了，我们目前的实现会中断MapReduce计算。客户端可以检查该master的状态，并且根据需要可以重新执行MapReduce操作。</p>
<h3 id="落伍者问题"><a href="#落伍者问题" class="headerlink" title="落伍者问题"></a>落伍者问题</h3><p>我们有一个通用机制来降低落伍者导致的这种问题所带来的影响。当一个MapReduce计算接近完成时，master会调度一个备用（backup）任务来执行剩下的处于正在执行中（in-progress）的任务。无论是这个主任务还是这个备用任务完成了，我们都会将这个任务标记为完成。我们对这个机制进行了调优。通常情况下，它只会比正常操作多占几个百分点的计算资源。我们发现这样做能够显著减少运行大型MapReduce计算时所要花费的时间。</p>
<h2 id="遗留问题"><a href="#遗留问题" class="headerlink" title="遗留问题"></a>遗留问题</h2><p>这种架构的问题是超大集群服务间的相互交流对网络传输的要求跟高, 这个架构的瓶颈也是网络传输速度, 只能在设计上尽可能避免使用网络传输</p>
<h1 id="GFS"><a href="#GFS" class="headerlink" title="GFS"></a>GFS</h1><p>GFS用于配合MapReduce, 它会将接收到的数据以64kb分散到所有服务器中, 这样在进行MapReduce时这些数据本身就已经被划分为了一个个map.<br>同时为了避免使用网络传输, 谷歌将GFS和MapReduce部署在同一服务器集群中, 这样当进行map或reduce操作时, master会要求其尽可能从当前服务器进行map和reduce操作.<br>大型存储集群要解决的核心问题就是一致性与性能的权衡, 这二者一方提升的代价往往是另一方下降.    </p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title>解决智力问题</title>
    <url>/2022/01/16/leetcode%E9%A2%98%E8%A7%A3/%E8%A7%A3%E5%86%B3%E6%99%BA%E5%8A%9B%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给你一个下标从 0 开始的二维整数数组 questions ，其中 questions[i] = [pointsi, brainpoweri] 。</p>
<p>这个数组表示一场考试里的一系列题目，你需要 按顺序 （也就是从问题 0 开始依次解决），针对每个问题选择 解决 或者 跳过 操作。解决问题 i 将让你 获得  pointsi 的分数，但是你将 无法 解决接下来的 brainpoweri 个问题（即只能跳过接下来的 brainpoweri 个问题）。如果你跳过问题 i ，你可以对下一个问题决定使用哪种操作。</p>
<p>比方说，给你 questions = [[3, 2], [4, 3], [4, 4], [2, 5]] ：<br>如果问题 0 被解决了， 那么你可以获得 3 分，但你不能解决问题 1 和 2 。<br>如果你跳过问题 0 ，且解决问题 1 ，你将获得 4 分但是不能解决问题 2 和 3 。<br>请你返回这场考试里你能获得的 最高 分数。</p>
<span id="more"></span>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>这里可以将题目转换为获得start开始的一个最大串, 比如例题, 我们可以选择start=0开始的某个串, 如果选择第0个为串的头, 就要取得串的第二个数, 串的第二个数字可以转化为start=0+2+1开始的某个串.<br>这样思考就形成了一个递归问题. 接着, 我们需要对算法进行优化, 当我们取得一个start的最大串, 就可以将它存储起来, 当进行循环时遇到这个数字, 说明后面的最大计算已经完成, 只需与前面的数字进行最大值的比较就能得到整体的最大值.</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int[][] questions;</span><br><span class="line">//记录已经算出的start</span><br><span class="line">HashMap&lt;Integer, Long&gt; map;</span><br><span class="line"></span><br><span class="line">public long mostPoints(int[][] questions) &#123;</span><br><span class="line">    map = new HashMap&lt;&gt;();</span><br><span class="line">    this.questions = questions;</span><br><span class="line">    return getMax(0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public long getMax(int start) &#123;</span><br><span class="line">    long max = 0;</span><br><span class="line">    long sum = 0;</span><br><span class="line">    for (int i = start; i &lt; questions.length; i++) &#123;</span><br><span class="line">        if (map.containsKey(i)) &#123;</span><br><span class="line">        	//这里的max就是前面未算的最大值, 而取出的value就是后面的, 二者取最大就可以</span><br><span class="line">            max = Math.max(map.get(i), max);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        if (questions[i][1] + i + 1 &gt;= questions.length) &#123;</span><br><span class="line">            sum = questions[i][0];</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            sum = questions[i][0] + getMax(questions[i][1] + i + 1);</span><br><span class="line">        &#125;</span><br><span class="line">        max = Math.max(sum, max);</span><br><span class="line">    &#125;</span><br><span class="line">    //到这里已经算出当前start对应的最大值了, 存储</span><br><span class="line">    map.put(start, max);</span><br><span class="line">    return max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode解析</category>
        <category>中等</category>
      </categories>
      <tags>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux笔记</title>
    <url>/2022/01/14/%E7%AC%94%E8%AE%B0/Linux%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h1><p>/etc:配置文件子目录<br>/user:用户应用程序及文件<br>/boot:启动Linux使用的核心文件<br>/tmp:临时文件<br>/dev:硬件文件<br>/mnt:临时挂载其他系统<br>/opt:主机额外安装软件存放的目录<br>/usr/local:安装软件安装的目录<br>/var:存放经常被修改的文件的目录, 日志等</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title>Nginx</title>
    <url>/2022/01/12/%E7%AC%94%E8%AE%B0/Nginx/</url>
    <content><![CDATA[<h1 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h1><p>用于在分布式前实现动静分离,负载均衡和反向代理, 以它为中介管理多个后台服务器</p>
<h1 id="如何保证session可用"><a href="#如何保证session可用" class="headerlink" title="如何保证session可用"></a>如何保证session可用</h1><p>对id进行hash操作, 使id与服务器形成固定的映射(不建议),使用Redis最好.</p>
<h1 id="常用命令-nginx目录下操作"><a href="#常用命令-nginx目录下操作" class="headerlink" title="常用命令(nginx目录下操作)"></a>常用命令(nginx目录下操作)</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 查看版本号</span><br><span class="line">./nginx -v</span><br><span class="line"># 开启</span><br><span class="line">./nginx</span><br><span class="line"># 关闭</span><br><span class="line">./nginx -s stop</span><br><span class="line"># 重加载</span><br><span class="line">./nginx -s reload</span><br></pre></td></tr></table></figure>

<h1 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h1><h2 id="全局块"><a href="#全局块" class="headerlink" title="全局块"></a>全局块</h2><p>开始到events块之间的内容, 主要设置一些影响nginx服务器整体运行的配置指令</p>
<p>worker processes:工作进程数</p>
<h2 id="events块"><a href="#events块" class="headerlink" title="events块"></a>events块</h2><p>影响Nginx服务器与用户的网络连接, 常用的设置包括是否开启对多work process下的网络连接进行序列化, 是否允许同时接收多个网络连接, 选取哪种事件驱动模型来处理连接请求, 每个work process可以同时支持的最大连接数等.</p>
<p>worker_connections:每个work process支持的最大连接数.</p>
<h2 id="http块"><a href="#http块" class="headerlink" title="http块"></a>http块</h2><p>server{<br>    listen:监听端口号<br>    server_name:主机名称<br>    location / {<br>            root   html;<br>            index  index.html index.htm;<br>        }<br>}</p>
<h2 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h2><p>实现效果: 打开特定页面跳转到linux系统的tomcat主页面</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  101.200.131.200;</span><br><span class="line">    # 这里进行配置的并不是全路径, 而是类似于拦截器, 识别到对应的标志后 </span><br><span class="line">    # 就使用对应的服务器进行资源的查找</span><br><span class="line">    location / &#123;</span><br><span class="line">        root   html;</span><br><span class="line">        proxy_pass http://101.200.131.200:8080;</span><br><span class="line">        index  index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line">    # 这里将路径中有1的请求分发给8081</span><br><span class="line">    location ~ /1/ &#123;</span><br><span class="line">    	proxy_pass http://101.200.131.200:8081;</span><br><span class="line">    &#125;</span><br><span class="line">    location ~ /2/ &#123;</span><br><span class="line">    	proxy_pass http://101.200.131.200:8082;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>location =:不含正则表达式的url<br>location ~:正则表达, 区分大小写<br>location ~* :正则表达式, 不区分大小写</p>
<h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p>因为要进行相同的工作, 所以两个服务器要求接收相同路径可以跳转到相同的资源</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http&#123;</span><br><span class="line">	# 启用负载均衡</span><br><span class="line">	upstream myserver &#123;</span><br><span class="line">		server 101.200.131.200:8080;</span><br><span class="line">		server 101.200.131.200:8081;</span><br><span class="line">	&#125;</span><br><span class="line">	server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  101.200.131.200;</span><br><span class="line">    location / &#123;</span><br><span class="line">        root   html;</span><br><span class="line">        proxy_pass http://myserver;</span><br><span class="line">        index  index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分配策略:<br>1.轮询(默认)<br>2.weight: 在每个服务器后加wieght = n设置服务器权重<br>3.ip_hash(解决session问题): 在upstream中加入ip_hash;即可<br>4.fair(根据服务器响应时间分配): 在upstream中加入fair;即可</p>
<h2 id="动静分离"><a href="#动静分离" class="headerlink" title="动静分离"></a>动静分离</h2><p>nginx处理静态请求, tomcat处理动态请求</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">location /image/ &#123;</span><br><span class="line">    # 将路径中含有image的请求的根路径定位为/data文件</span><br><span class="line">    root  /data/;</span><br><span class="line">    # 列出访问目录</span><br><span class="line">    autoindex on;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="配置主从nginx"><a href="#配置主从nginx" class="headerlink" title="配置主从nginx"></a>配置主从nginx</h2><p>使用keepalived配置主从服务器, 并对外使用虚拟ip<br>安装keepalived(/etc/keepalived/)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install keepalived -y</span><br></pre></td></tr></table></figure>
<p>修改配置文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">global_defs &#123;</span><br><span class="line">   notification_email &#123;</span><br><span class="line">     acassen@firewall.loc</span><br><span class="line">     failover@firewall.loc</span><br><span class="line">     sysadmin@firewall.loc</span><br><span class="line">   &#125;</span><br><span class="line">   notification_email_from Alexandre.Cassen@firewall.loc</span><br><span class="line">   smtp_server 192.168.200.1</span><br><span class="line">   smtp_connect_timeout 30</span><br><span class="line">   # 服务器名称</span><br><span class="line">   router_id LVS_DEVEL</span><br><span class="line">&#125;</span><br><span class="line"># 配置检测脚本</span><br><span class="line">vrrp_script chk_http_port &#123;</span><br><span class="line">    # 路径</span><br><span class="line">    script &quot;/usr/local/src/nginx_check.sh&quot;</span><br><span class="line">    #间隔</span><br><span class="line">    interval 2</span><br><span class="line">    #脚本执行成功后的权重</span><br><span class="line">    weight 2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">    state MASTER   #主服务器Master副服务器Backup</span><br><span class="line">    interface eth0  #网卡</span><br><span class="line">    virtual_router_id 51  #主,备机的这个id必须相同  </span><br><span class="line">    priority 100   </span><br><span class="line">    advert_int 1</span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass 1111</span><br><span class="line">    &#125;</span><br><span class="line">    # 虚拟ip地址</span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">        192.168.200.16</span><br><span class="line">        192.168.200.17</span><br><span class="line">        192.168.200.18</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title>SpringCloud</title>
    <url>/2022/02/07/%E6%A1%86%E6%9E%B6/SpringCloud/</url>
    <content><![CDATA[<h1 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h1><p>RestTemplate:<br>用于不同服务器间的交互.<br>参数: url,requestMap,ResponseBean.class<br>注入容器(Configration文件):</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Bean</span><br><span class="line">   public RestTemplate getRestTemplate()&#123;</span><br><span class="line">       return new RestTemplate();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>公共部分提取:<br>使用maven打包公共文件后引入到其他模块的依赖之中.</p>
<h1 id="服务注册中心"><a href="#服务注册中心" class="headerlink" title="服务注册中心"></a>服务注册中心</h1><p>当服务数量到达一个量级时, 服务与服务间的调用会变得非常复杂, 所以需要一个工具来管理服务间的依赖关系, 相互调用, 负载均衡, 容错等功能. 即服务注册中心, 通过服务的发现与注册, 对服务进行统一的管理.</p>
<h2 id="Eureka"><a href="#Eureka" class="headerlink" title="Eureka"></a>Eureka</h2><p>全部设置完成后, 在RestTemplate处配置好负载均衡功能, 微服务间的交互便不再使用直接地址, 而是使用application name进行交互(集群交互的基础).</p>
<h3 id="Eureka-Server"><a href="#Eureka-Server" class="headerlink" title="Eureka Server"></a>Eureka Server</h3><p>提供服务注册, 注册后监听心跳, 如果一段时间未收到心跳, 则将服务移出.</p>
<p>创建:<br>1.配置pom<br>2.yml文件配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 7001</span><br><span class="line"></span><br><span class="line">eureka:</span><br><span class="line">  instance:</span><br><span class="line">    hostname: eureka7001.com</span><br><span class="line">  client:</span><br><span class="line">    #false表示不向注册中心注册自己</span><br><span class="line">    register-with-eureka: false</span><br><span class="line">    #false表示自己就是注册中心, 无需检索</span><br><span class="line">    fetch-registry: false</span><br><span class="line">    service-url:</span><br><span class="line">      # 设置eureka的交互地址</span><br><span class="line">      defaultZone: &quot;http://eureka7002.com:7002/eureka/,</span><br><span class="line">                    http://eureka7003.com:7003/eureka/&quot;</span><br></pre></td></tr></table></figure>
<p>3.在main函数使用@EnableEurekaServer注解注册</p>
<h3 id="Eureka-Client"><a href="#Eureka-Client" class="headerlink" title="Eureka Client"></a>Eureka Client</h3><p>通过注册中心进行访问<br>对所有需要进行注册中心的微服务进行eureka client配置.<br>1.pom配置<br>2.yml配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">eureka:</span><br><span class="line">  instance:</span><br><span class="line">    instance-id: payment8002</span><br><span class="line">    #访问路径可以显示ip</span><br><span class="line">    prefer-ip-address: true</span><br><span class="line">  client:</span><br><span class="line">    #注册</span><br><span class="line">    register-with-eureka: true</span><br><span class="line">    #是否从注册中心抓取注册信息, 单节点无所谓,集群必须设置为true才能配合ribbon使用负载均衡</span><br><span class="line">    fetch-registry: true</span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: &quot;http://eureka7001.com:7001/eureka/,</span><br><span class="line">                    http://eureka7002.com:7002/eureka/</span><br><span class="line">                    http://eureka7003.com:7003/eureka/&quot;</span><br></pre></td></tr></table></figure>
<p>3.main函数注解</p>
<h3 id="Eureka的保护机制"><a href="#Eureka的保护机制" class="headerlink" title="Eureka的保护机制"></a>Eureka的保护机制</h3><p>当Eureka短时间内丢失大量客户, 此时Eureka会判断可能是网络原因导致无法接受到心跳, 就会进入到保护机制.<br>在保护机制下, 不会再注销任何微服务, 这样可以防止因为网络原因使本可以正常允许的微服务被注销.<br>如何关闭:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 服务端</span><br><span class="line">eureka:</span><br><span class="line">  server:</span><br><span class="line">    enable-self-preservation: false</span><br><span class="line">    # 清理无效节点的时间间隔</span><br><span class="line">    eviction-interval-timer-in-ms: 2000</span><br><span class="line"># 客户端</span><br><span class="line">eureka:</span><br><span class="line">  instance:</span><br><span class="line">    # 心跳间隔</span><br><span class="line">    lease-renewal-interval-in-seconds: 1</span><br><span class="line">    # 超时剔除时间 </span><br><span class="line">    lease-expiration-duration-in-seconds: 2</span><br></pre></td></tr></table></figure>
<h2 id="服务发现Discovery"><a href="#服务发现Discovery" class="headerlink" title="服务发现Discovery"></a>服务发现Discovery</h2><p>对于注册进eureka的微服务, 可以通过服务发现来获得该服务的信息<br>main函数使用@EnableDiscoveryClient注解, 之后controller就可以使用discoveryClient进行服务发现.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//DiscoveryClient类应该从cloud包中导入，而不是从netflix包导入</span><br><span class="line">//从netflix包中导入的DiscoveryClient类没有getServices()方法，且无法自动注入</span><br><span class="line">@Autowired</span><br><span class="line">private DiscoveryClient discoveryClient;</span><br><span class="line"></span><br><span class="line">@GetMapping(&quot;/discovery&quot;)</span><br><span class="line">private Object discovery()&#123;</span><br><span class="line">    //取得服务列表</span><br><span class="line">    List&lt;String&gt; services = discoveryClient.getServices();</span><br><span class="line">    for (String element : services)&#123;</span><br><span class="line">        log.info(&quot;**********element:&quot;+element);</span><br><span class="line">    &#125;</span><br><span class="line">    //获得服务实例</span><br><span class="line">    List&lt;ServiceInstance&gt; instances = discoveryClient.getInstances(&quot;PAYMENT-SERVICE&quot;);</span><br><span class="line">    for (ServiceInstance instance : instances)&#123;</span><br><span class="line">        log.info(instance.getServiceId()+&quot;\t&quot;+instance.getHost()+&quot;\t&quot;+</span><br><span class="line">                instance.getPort()+&quot;\t&quot;+instance.getUri());</span><br><span class="line">    &#125;</span><br><span class="line">    return discoveryClient;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h2><p>Eureka是为AP设计: 选择可用性 A(Availability)，此时，那个失去联系的节点依然可以向系统提供服务，不过它的数据就不能保证是同步的了<br>Zookeeper是为CP设计: 选择一致性C(Consistency)，为了保证数据库的一致性，我们必须等待失去联系的节点恢复过来，在这个过程中，那个节点是不允许对外提供服务的，这时候系统处于不可用状态(失去了A属性)。</p>
<h3 id="yml注册"><a href="#yml注册" class="headerlink" title="yml注册"></a>yml注册</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8003</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="comment">#指定别名</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">payment-service</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">zookeeper:</span></span><br><span class="line">      <span class="attr">connect-string:</span> <span class="number">101.200</span><span class="number">.131</span><span class="number">.200</span><span class="string">:2181</span></span><br></pre></td></tr></table></figure>
<h3 id="linux处理"><a href="#linux处理" class="headerlink" title="linux处理"></a>linux处理</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 安装</span><br><span class="line">docker pull zookeeper</span><br><span class="line">docker run -d --name zk -p 2181:2181 zookeeper</span><br><span class="line"># 进入</span><br><span class="line">docker exec -it zk /bin/bash</span><br><span class="line">cd bin</span><br><span class="line">./zkCli.sh</span><br><span class="line"># 查看服务</span><br><span class="line">ls /</span><br><span class="line">[services, zookeeper]</span><br><span class="line">ls /services</span><br><span class="line">[payment-service]</span><br><span class="line"># 继续深入目录就可以看到转发信息的json串</span><br></pre></td></tr></table></figure>
<h2 id="Consul"><a href="#Consul" class="headerlink" title="Consul"></a>Consul</h2>]]></content>
      <categories>
        <category>框架</category>
      </categories>
  </entry>
  <entry>
    <title>RabbitMQ</title>
    <url>/2022/01/26/%E7%AC%94%E8%AE%B0/RabbitMQ/</url>
    <content><![CDATA[<h1 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h1><p>1.流量削峰<br>2.应用解耦<br>3.异步处理</p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p><a href="https://github.com/rabbitmq/erlang-rpm/releases">https://github.com/rabbitmq/erlang-rpm/releases</a> 选择合适的erlang版本进行下载<br>使用rpm命令进行安装.<br><a href="https://www.rabbitmq.com/install-rpm.html#downloads">https://www.rabbitmq.com/install-rpm.html#downloads</a> 选择合适版本进行下载<br>使用rpm命令进行安装.<br>使用rabbitmq-plugins enable rabbitmq_managemanent安装web页面插件<br>配置开启防火墙,15672端口.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#配置用户</span><br><span class="line">rabbitmqctl add_user 账号 密码</span><br><span class="line">#设置角色</span><br><span class="line">rabbitmqctl set_user_tags 账号 administrator </span><br><span class="line">#设置权限</span><br><span class="line">rabbitmqctl set_permissions -p &quot;/&quot; admin &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;</span><br><span class="line">#查看账户</span><br><span class="line">rabbitmqctl list_users</span><br></pre></td></tr></table></figure>
<h1 id="生产消费模型"><a href="#生产消费模型" class="headerlink" title="生产消费模型"></a>生产消费模型</h1><p>为了接收消息, 首先开启防火墙的5672端口<br>生产者:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Producer &#123;</span><br><span class="line">    public static final String QUEUE_NAME= &quot;hello&quot;;</span><br><span class="line">    public static final String HOST = &quot;101.200.131.200&quot;;</span><br><span class="line">    public static void main(String[] args) throws IOException, TimeoutException &#123;</span><br><span class="line">        //创建工厂并连接</span><br><span class="line">        ConnectionFactory factory = new ConnectionFactory();</span><br><span class="line">        factory.setHost(HOST);</span><br><span class="line">        factory.setUsername(&quot;admin&quot;);</span><br><span class="line">        factory.setPassword(&quot;lixin123&quot;);</span><br><span class="line">        //创建连接</span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        //获取信道</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        //声明队列:名称, 持久化(false),不支持多消费者(false),自动删除(true),其他参数</span><br><span class="line">        channel.queueDeclare(QUEUE_NAME,false,false,false,null);</span><br><span class="line">        String message = &quot;hello, world&quot;;</span><br><span class="line">        //发送消息:交换机,路由key值,消息配置,消息体</span><br><span class="line">        channel.basicPublish(&quot;&quot;,QUEUE_NAME,null,message.getBytes());</span><br><span class="line">        System.out.println(&quot;消息发送完毕&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>消费者:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Consumer &#123;</span><br><span class="line">    public static final String QUEUE_NAME= &quot;hello&quot;;</span><br><span class="line">    public static final String HOST = &quot;101.200.131.200&quot;;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IOException, TimeoutException &#123;</span><br><span class="line">        //创建工厂并连接</span><br><span class="line">        ConnectionFactory factory = new ConnectionFactory();</span><br><span class="line">        factory.setHost(HOST);</span><br><span class="line">        factory.setUsername(&quot;admin&quot;);</span><br><span class="line">        factory.setPassword(&quot;lixin123&quot;);</span><br><span class="line">        //创建连接</span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        //创建信道</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        //实例化消息回调</span><br><span class="line">        DeliverCallback deliverCallback = (var1,var2)-&gt;&#123;</span><br><span class="line">            //这里输出得到的消息</span><br><span class="line">            System.out.println(new String(var2.getBody()));</span><br><span class="line">        &#125;;</span><br><span class="line">        //实例化取消消息时的回调</span><br><span class="line">        CancelCallback cancelCallback = (var1)-&gt;&#123;</span><br><span class="line">            System.out.println(var1+&quot;消息消费被取消&quot;);</span><br><span class="line">        &#125;;</span><br><span class="line">        //接收消息:队列名,是否自动答,消息回调,取消回调</span><br><span class="line">        channel.basicConsume(QUEUE_NAME,true,deliverCallback,cancelCallback);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="轮询分发消息"><a href="#轮询分发消息" class="headerlink" title="轮询分发消息"></a>轮询分发消息</h1><p>当生产者端大量发送消息时, 就会产生需要多个消费者进行处理分摊压力的情况, 队列会轮询向消费者分发消息.</p>
<h1 id="消息应答"><a href="#消息应答" class="headerlink" title="消息应答"></a>消息应答</h1><p>只有当消费者处理消息完成后通知队列, 队列才会将当前消息进行删除. 当队列判断消费者未能处理消息, 则会对消息进行重新入队.</p>
<h2 id="自动应答-异步"><a href="#自动应答-异步" class="headerlink" title="自动应答(异步)"></a>自动应答(异步)</h2><p>吞吐量高, 但安全性较低. 适合消费者可以高效处理消息的情况.</p>
<h2 id="手动应答"><a href="#手动应答" class="headerlink" title="手动应答"></a>手动应答</h2><p>Channel.basicAck(用于肯定确认)<br>Channel.basicNack(用于否定确认)<br>Channel.basicReject(用于否定确认,少一个批量应答参数)<br>参数: 消息tag,是否批量,<br>批量应答: 对于当前以及之前所有未应答的消息进行统一的应答.</p>
<h1 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h1><p>持久化需要队列与消息都进行持久化.生产者负责.<br>队列持久化由queueDeclare设置, 消息持久化由basicPublish设置.<br>但即使这样在队列将消息持久化到磁盘的过程种出现宕机, 也可能导致持久化失败. 因此需要当队列将消息存储到磁盘后向生产者进行回复, 即发布确认.<br>持久化的会在写入磁盘后进行回复, 非持久化的会在收到后回复.<br>发布确认:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//开启</span><br><span class="line">channel.confirmSelect();</span><br><span class="line">//发布确认</span><br><span class="line">channel.basicPublish();</span><br><span class="line">channel.waitForConfirms();</span><br></pre></td></tr></table></figure>
<p>根据waitForconFirms的不同使用方法, 分为单个发布确认, 批量发布确认, 以及异步发布确认.<br>异步发布确认(性价比最高):<br>生产者只负责不断的发送消息以及维护一个已发送但未确认的列表, 不再等待消息的确认, 而是接收broker的回复与持有的列表进行比较做出相应处理.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Channel channel = RabbitmqUtil.getChannel();</span><br><span class="line">channel.queueDeclare(QUEUE_NAME,true,false,false,null);</span><br><span class="line">//开启发布确认</span><br><span class="line">channel.confirmSelect();</span><br><span class="line">//准备消息监听器</span><br><span class="line">//创建一个发送列表&lt;消息编号,内容&gt;</span><br><span class="line">ConcurrentSkipListMap&lt;Long, String&gt; map = new ConcurrentSkipListMap&lt;&gt;();</span><br><span class="line">//实现监听器需要的接口</span><br><span class="line">//成功回调函数</span><br><span class="line">ConfirmCallback ackCallBack = (deliveryTag, multiple)-&gt;&#123;</span><br><span class="line">    //删除发送成功的消息</span><br><span class="line">    //批量确认</span><br><span class="line">    if (multiple)&#123;</span><br><span class="line">        //返回此映射的部分视图</span><br><span class="line">        ConcurrentNavigableMap&lt;Long, String&gt; navigableMap = map.headMap(deliveryTag);</span><br><span class="line">        navigableMap.clear();</span><br><span class="line">    //单个确认</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        map.remove(deliveryTag);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">//失败回调函数</span><br><span class="line">ConfirmCallback nackCallBack = (deliveryTag, multiple)-&gt;&#123;</span><br><span class="line">    System.out.println(&quot;uncheck:&quot;+deliveryTag);</span><br><span class="line">&#125;;</span><br><span class="line">channel.addConfirmListener(ackCallBack,nackCallBack);</span><br><span class="line">for (int i = 1;i&lt;100;i++)&#123;</span><br><span class="line">    channel.basicPublish(&quot;&quot;,QUEUE_NAME,null,Integer.toString(i).getBytes());</span><br><span class="line">    //记录发送的消息</span><br><span class="line">    map.put(channel.getNextPublishSeqNo(),Integer.toString(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="不公平分发"><a href="#不公平分发" class="headerlink" title="不公平分发"></a>不公平分发</h1><p>消费者负责. channel.basicQos()进行不公平分发设置.<br>这里要填入数字, 这个数字是一个预取值, 用来限制当前通道允许的最大未确认消息数.</p>
<h1 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h1><p>一个队列只能允许一个消息一个消费者进行消费, 如果要同时多个消费者消费同一消息, 则需要交换机分配多个队列实现.<br>分为默认(),直接(direct),主题(topic),标题(headers),扇出(fanout).<br>在交换机处设置要发送的队列,以及用于接收生产者消息的routing key.<br>channel.queueDeclare().getQueue()创建临时队列, 连接关闭就会删除.</p>
<h2 id="fanout"><a href="#fanout" class="headerlink" title="fanout"></a>fanout</h2><p>发布订阅模式, 它不会处理routingKey, 只需要将队列绑定到交换机上实现广播.<br>消费者:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Channel channel = RabbitmqUtil.getChannel();</span><br><span class="line">//声明一个交换机</span><br><span class="line">channel.exchangeDeclare(&quot;logs&quot;,&quot;fanout&quot;);</span><br><span class="line">//声明一个临时队列</span><br><span class="line">String queueName = channel.queueDeclare().getQueue();</span><br><span class="line">//绑定</span><br><span class="line">channel.queueBind(queueName,&quot;logs&quot;,&quot;routingKey&quot;);</span><br><span class="line">channel.basicConsume(QUEUE_NAME,true,RabbitmqUtil.getDeliverCallback(),RabbitmqUtil.getCancelCallback());</span><br></pre></td></tr></table></figure>
<p>生产者:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Channel channel = RabbitmqUtil.getChannel();</span><br><span class="line">//声明一个交换机,声明两次是因为不知道哪个先启动</span><br><span class="line">channel.exchangeDeclare(&quot;logs&quot;,&quot;fanout&quot;);</span><br><span class="line">String message = &quot;message&quot;;</span><br><span class="line">channel.basicPublish(&quot;logs&quot;,&quot;routingKey&quot;,null,message.getBytes(StandardCharsets.UTF_8));</span><br></pre></td></tr></table></figure>
<h2 id="direct"><a href="#direct" class="headerlink" title="direct"></a>direct</h2><p>路由模式<br>相比扇出模式, 它的区别只是它会识别routingKey.</p>
<h2 id="topic"><a href="#topic" class="headerlink" title="topic"></a>topic</h2><p>在路由模式进行进一步的升级, 它要求routingKey必须是一个单词列表, 用点号分开.<br>在这种约束下, 就可以使用类似正则表达式的形式对多个队列进行匹配.</p>
<ul>
<li>代替任意字符, # 代替零个或多个单词.<br>示例:<br>队列1key:a.<em>.</em><br>队列2key:<em>.b.</em><br>队列3key:<em>.</em>.c<br>生产者key:a.a.c一三队列接收<h1 id="死信队列"><a href="#死信队列" class="headerlink" title="死信队列"></a>死信队列</h1>死信来源:</li>
</ul>
<p>1.消息TTL过期<br>2.队列满<br>3.消息被拒绝(basic.reject或basic.nack)并且requeue=false<br>普通消费者处进行普通交换和队列以及死信交换和队列的声明和绑定.<br>之后死信消费者处只需要进行死信的消费即可.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//普通交换机</span><br><span class="line">public static final String NORMAL_EXCHANGE = &quot;normalExchange&quot;;</span><br><span class="line">//死信交换机</span><br><span class="line">public static final String DEAD_EXCHANGE = &quot;deadExchange&quot;;</span><br><span class="line">//普通队列</span><br><span class="line">public static final String NORMAL_QUEUE = &quot;normalQueue&quot;;</span><br><span class="line">//死信队列</span><br><span class="line">public static final String DEAD_QUEUE = &quot;deadQueue&quot;;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws IOException, TimeoutException &#123;</span><br><span class="line">    Channel channel = RabbitmqUtil.getChannel();</span><br><span class="line">    //声明普通交换机</span><br><span class="line">    channel.exchangeDeclare(NORMAL_EXCHANGE,&quot;direct&quot;);</span><br><span class="line">    //声明死信交换机</span><br><span class="line">    channel.exchangeDeclare(DEAD_EXCHANGE,&quot;direct&quot;);</span><br><span class="line">    //声明普通队列</span><br><span class="line">    //这里就需要用到参数map对普通队列进行额外的设定</span><br><span class="line">    Map&lt;String, Object&gt; arguments = new HashMap&lt;&gt;();</span><br><span class="line">    //设定死信转发的交换机</span><br><span class="line">    arguments.put(&quot;x-dead-letter-exchange&quot;,DEAD_EXCHANGE);</span><br><span class="line">    //设定死转发使用的key</span><br><span class="line">    arguments.put(&quot;x-dead-letter-routing-key&quot;,&quot;dead&quot;);</span><br><span class="line">    //设定自动过期</span><br><span class="line">    arguments.put(&quot;x-message-ttl&quot;,10000);</span><br><span class="line">    //设定队列长度</span><br><span class="line">    arguments.put(&quot;x-max-length&quot;,10);</span><br><span class="line">    //消息的拒绝由DeliverCallback()接口实现.</span><br><span class="line">    //正式声明普通队列</span><br><span class="line">    channel.queueDeclare(NORMAL_QUEUE,false,false,false,arguments);</span><br><span class="line">    //声明死信队列</span><br><span class="line">    channel.queueDeclare(DEAD_QUEUE,false,false,false,null);</span><br><span class="line">    //为普通交换机绑定队列并设定key</span><br><span class="line">    channel.queueBind(NORMAL_QUEUE,NORMAL_EXCHANGE,&quot;normal&quot;);</span><br><span class="line">    //为死信交换机绑定队列并设定key</span><br><span class="line">    channel.queueBind(DEAD_QUEUE,DEAD_EXCHANGE,&quot;dead&quot;);</span><br><span class="line">    //对普通消息进行消费</span><br><span class="line">    channel.basicConsume(NORMAL_QUEUE,true,RabbitmqUtil.getDeliverCallback(),RabbitmqUtil.getCancelCallback());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
  </entry>
</search>
